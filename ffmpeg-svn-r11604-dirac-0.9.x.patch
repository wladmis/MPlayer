diff -urN ffmpeg-svn-r11604.orig/libavcodec/allcodecs.c ffmpeg-svn-r11604/libavcodec/allcodecs.c
--- ffmpeg-svn-r11604.orig/libavcodec/allcodecs.c	2008-01-11 02:16:42 +0200
+++ ffmpeg-svn-r11604/libavcodec/allcodecs.c	2008-01-24 02:02:47 +0200
@@ -73,6 +73,7 @@
     REGISTER_DECODER (CLJR, cljr);
     REGISTER_DECODER (CSCD, cscd);
     REGISTER_DECODER (CYUV, cyuv);
+    REGISTER_ENCDEC  (DIRAC, dirac);
     REGISTER_ENCDEC  (DNXHD, dnxhd);
     REGISTER_DECODER (DSICINVIDEO, dsicinvideo);
     REGISTER_ENCDEC  (DVVIDEO, dvvideo);
@@ -284,6 +285,7 @@
     REGISTER_PARSER  (AAC, aac);
     REGISTER_PARSER  (AC3, ac3);
     REGISTER_PARSER  (CAVSVIDEO, cavsvideo);
+    REGISTER_PARSER  (DIRAC, dirac);
     REGISTER_PARSER  (DCA, dca);
     REGISTER_PARSER  (DVBSUB, dvbsub);
     REGISTER_PARSER  (DVDSUB, dvdsub);
diff -urN ffmpeg-svn-r11604.orig/libavcodec/avcodec.h ffmpeg-svn-r11604/libavcodec/avcodec.h
--- ffmpeg-svn-r11604.orig/libavcodec/avcodec.h	2008-01-11 02:16:42 +0200
+++ ffmpeg-svn-r11604/libavcodec/avcodec.h	2008-01-24 02:02:47 +0200
@@ -284,6 +284,8 @@
     CODEC_ID_XSUB,
     CODEC_ID_SSA,
 
+    CODEC_ID_DIRAC = 0x18000,
+
     CODEC_ID_MPEG2TS= 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
                                 * stream (only used by libavformat) */
 };
diff -urN ffmpeg-svn-r11604.orig/libavcodec/dirac.c ffmpeg-svn-r11604/libavcodec/dirac.c
--- ffmpeg-svn-r11604.orig/libavcodec/dirac.c	1970-01-01 03:00:00 +0300
+++ ffmpeg-svn-r11604/libavcodec/dirac.c	2008-01-24 01:57:31 +0200
@@ -0,0 +1,764 @@
+/**
+ * @file dirac.c
+ * Dirac codec support via dirac_encoder.
+ * @author Andrew Kennedy <dirac@rd.bbc.co.uk>
+ * www.sourceforge.net/projects/dirac
+ *
+ * This file is part of libavcodec.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+
+#include "avcodec.h"
+
+#undef NDEBUG
+#include <assert.h>
+
+
+#include <libdirac_encoder/dirac_encoder.h>
+#include <libdirac_decoder/dirac_parser.h>
+
+/** ffmpeg qscale to Dirac quality conversion table */
+static const float quality_factor_conv[] = {10.0, 9.8, 9.6, 9.4, 9.2, 9.0, 8.8, 
+          8.6, 8.4, 8.2, 8.0, 7.8, 7.6, 7.3, 7.0, 6.7, 6.4, 6.0, 5.6, 5.2, 4.8, 
+          4.4, 4.0, 3.6, 3.2, 2.8, 2.4, 2.0, 1.6, 1.2, 1.0 };
+
+/** contains a single frame returned from Dirac*/
+typedef struct FfmpegDiracOutputFrame
+{
+    /** frame data */
+    unsigned char *p_data;
+    
+    /** frame size */
+    int size;
+    
+    /** frame type */
+    int type;
+    
+    /** next frame to be output in sequence */
+    struct FfmpegDiracOutputFrame *p_next_frame;
+    
+ } FfmpegDiracOutputFrame;
+  
+typedef struct FfmpegDiracParams
+{
+    /* context params */
+    dirac_encoder_context_t enc_ctx;
+
+    /* frame being encoded */
+    AVFrame picture;
+
+      /* decoder */
+    dirac_decoder_t*  p_decoder;
+    
+    /* encoder */
+    dirac_encoder_t*  p_encoder;
+
+    /* input frame buffer */
+    unsigned char *p_in_frame_buf;
+    
+    /** output frame buf */
+    unsigned char* p_out_frame_buf;
+    
+    /** next frame to be output*/
+    struct FfmpegDiracOutputFrame *p_next_output_frame;
+    
+      /** last frame to be output*/
+    struct FfmpegDiracOutputFrame *p_last_output_frame;
+    
+} FfmpegDiracParams;
+
+
+typedef struct FfmpegDiracParseContext
+{
+
+    /** stream buffer variables */
+    unsigned char* p_dirac_videobuffer;
+    int dirac_videobuf_code_len;
+    unsigned char dirac_videobuf_code[5];
+    int dirac_videobuf_len;
+    int in_frame;
+    int dirac_overread_size;
+
+} FfmpegDiracParseContext ;
+
+
+/**
+* Works out Dirac-compatible pre-set option from file size
+*/
+static dirac_encoder_presets_t GetDiracPreset(AVCodecContext *avccontext)
+{
+
+    if(avccontext->width==176 && avccontext->height==120)
+        return VIDEO_FORMAT_QSIF525;
+    else if(avccontext->width==176 && avccontext->height==144)
+        return VIDEO_FORMAT_QCIF;
+    else if(avccontext->width==352 && avccontext->height==240)
+        return VIDEO_FORMAT_SIF525;
+    else if(avccontext->width==352 && avccontext->height==288)
+        return VIDEO_FORMAT_CIF;
+    else if(avccontext->width==704 && avccontext->height==480)
+        return VIDEO_FORMAT_4SIF525;
+    else if(avccontext->width==704 && avccontext->height==576)
+        return VIDEO_FORMAT_4CIF;
+    else if(avccontext->width==720 && avccontext->height==480)
+        return VIDEO_FORMAT_SD_480I60;
+    else if(avccontext->width==720 && avccontext->height==576)
+        return VIDEO_FORMAT_SD_576I50;
+    else if(avccontext->height==1280 && avccontext->height==720)
+    {
+        if (avccontext->time_base.den == 60000 && 
+            avccontext->time_base.num == 1001)
+        {
+            return VIDEO_FORMAT_HD_720P60;
+        }
+        else
+        {
+            return VIDEO_FORMAT_HD_720P50;
+        }
+    }    
+    else if(avccontext->height==1920 && avccontext->width==1080)
+    {
+        if (avccontext->time_base.den == 30000 && 
+            avccontext->time_base.num == 1001)
+        {
+            return VIDEO_FORMAT_HD_1080I60;
+        }
+        else if (avccontext->time_base.den == 25 && 
+            avccontext->time_base.num == 1)
+        {
+            return VIDEO_FORMAT_HD_1080I50;
+        }
+        else if (avccontext->time_base.den == 60 && 
+            avccontext->time_base.num == 1001)
+        {
+            return VIDEO_FORMAT_HD_1080P60;
+        }
+        else
+        {
+            return VIDEO_FORMAT_HD_1080P50;
+        }
+    }
+    return VIDEO_FORMAT_CUSTOM;
+}
+
+/**
+* Works out Dirac-compatible chroma format 
+*/
+static int GetDiracChromaFormat(AVCodecContext *avccontext)
+{
+   FfmpegDiracParams* p_dirac_params = avccontext->priv_data;
+ 
+    switch(avccontext->pix_fmt)
+    {
+        case PIX_FMT_YUV420P:
+            p_dirac_params->enc_ctx.src_params.chroma =  format420;
+            break;
+
+        case PIX_FMT_YUV422P:
+            p_dirac_params->enc_ctx.src_params.chroma =  format422;
+            break;
+    
+        case PIX_FMT_YUV444P:
+            p_dirac_params->enc_ctx.src_params.chroma =  format444;
+            break;
+    
+        default:
+            av_log (avccontext, AV_LOG_ERROR, "this codec supports only Planar YUV formats (yuv420p, yuv422p, yuv444p\n");
+            return -1;
+    }
+    return format420;
+}
+ 
+ /**
+ * returns Ffmppeg chroma format 
+ */
+static int GetFfmpegChromaFormat(dirac_chroma_t dirac_chroma)
+{
+    switch(dirac_chroma)
+    {
+        case format420:
+            return PIX_FMT_YUV420P;
+        case format422:
+            return PIX_FMT_YUV422P;
+        case format444:
+            return PIX_FMT_YUV444P;
+      
+        default:
+            break;
+     }
+      
+     return PIX_FMT_YUV420P;
+}
+  
+
+static int dirac_encode_init(AVCodecContext *avccontext)
+{
+  
+   FfmpegDiracParams* p_dirac_params = avccontext->priv_data;
+   int no_local=1;  
+   int verbose=avccontext->debug;
+   dirac_encoder_presets_t preset;
+   
+   if(avccontext->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL){
+        av_log(avccontext, AV_LOG_ERROR, "this codec is under development, files encoded with it may not be decodable with future versions!!!\n"
+               "use vstrict=-2 / -strict -2 to use it anyway\n");
+        return -1;
+    }
+   
+   /* get dirac preset*/
+   preset = GetDiracPreset(avccontext);
+
+    /* set data to zero */
+    memset (p_dirac_params, 0, sizeof(FfmpegDiracParams));
+     
+ 
+     /* initialise the encoder context */
+    dirac_encoder_context_init (&(p_dirac_params->enc_ctx), preset);
+   
+    if (GetDiracChromaFormat(avccontext) == -1)
+        return -1;
+    p_dirac_params->enc_ctx.src_params.frame_rate.numerator=avccontext->time_base.den;
+    p_dirac_params->enc_ctx.src_params.frame_rate.denominator=avccontext->time_base.num;
+    p_dirac_params->enc_ctx.src_params.width=avccontext->width;
+    p_dirac_params->enc_ctx.src_params.height=avccontext->height;
+   
+    avccontext->frame_size = avpicture_get_size(avccontext->pix_fmt, avccontext->width, avccontext->height);
+    avccontext->coded_frame= &p_dirac_params->picture;
+     
+    if (no_local)
+    {
+        p_dirac_params->enc_ctx.decode_flag = 0;
+        p_dirac_params->enc_ctx.instr_flag = 0;
+    }
+    else
+    {
+        p_dirac_params->enc_ctx.decode_flag = 1;
+        p_dirac_params->enc_ctx.instr_flag = 1;
+    }
+    
+    if(avccontext->global_quality != 0)
+       p_dirac_params->enc_ctx.enc_params.qf=quality_factor_conv[(avccontext->global_quality/FF_QP2LAMBDA)-1];
+    else if(avccontext->bit_rate >= 1000)
+       p_dirac_params->enc_ctx.enc_params.trate=avccontext->bit_rate/1000;
+
+    if ((preset > VIDEO_FORMAT_QCIF || preset < VIDEO_FORMAT_QSIF525) && 
+        avccontext->bit_rate == 200000)
+    {
+        p_dirac_params->enc_ctx.enc_params.trate = 0;
+    }
+
+	if (avccontext->flags & CODEC_FLAG_INTERLACED_ME)
+	{
+	    // all material can be coded as interlaced or progressive
+		// irrespective of the type of source material
+		p_dirac_params->enc_ctx.enc_params.picture_coding_mode = 1;
+	}
+
+    p_dirac_params->p_encoder = dirac_encoder_init( &(p_dirac_params->enc_ctx), verbose );
+   
+   
+
+    if (!p_dirac_params->p_encoder)
+    {
+        av_log(avccontext, AV_LOG_ERROR, "Unrecoverable Error: dirac_encoder_init failed. ");
+        return EXIT_FAILURE;
+    }
+    
+   
+    /* allocate enough memory for the incoming data */
+    p_dirac_params->p_in_frame_buf = (unsigned char*) av_malloc(avccontext->frame_size);
+    
+    return 0 ;
+}
+
+
+static int dirac_encode_frame(AVCodecContext *avccontext,
+                              unsigned char *frame,
+                              int buf_size, void *data)
+{
+    int enc_size=0;
+    dirac_encoder_state_t state;
+    FfmpegDiracParams* p_dirac_params = avccontext->priv_data;
+    AVFrame* p_frame_src;
+    struct FfmpegDiracOutputFrame* p_frame_output=NULL;
+    struct FfmpegDiracOutputFrame* p_next_output_frame=NULL;
+
+
+    if(data==0)
+    {
+        /* look for any delayed frames at EOF*/
+        p_next_output_frame=p_dirac_params->p_next_output_frame;
+        if(p_next_output_frame==NULL)
+        {
+            /* get terminate data*/
+            p_dirac_params->p_encoder->enc_buf.buffer=frame;
+            p_dirac_params->p_encoder->enc_buf.size = buf_size;
+            if (dirac_encoder_end_sequence( p_dirac_params->p_encoder ) > 0)
+                return p_dirac_params->p_encoder->enc_buf.size;
+
+            return 0;
+        }
+     
+        memcpy(frame, p_next_output_frame->p_data, p_next_output_frame->size);
+        enc_size=p_next_output_frame->size;
+
+        /*remove frame*/
+        p_dirac_params->p_next_output_frame=p_next_output_frame->p_next_frame;
+        av_free(p_next_output_frame->p_data);
+        av_free(p_next_output_frame);
+        
+        return enc_size;
+    }
+    
+    p_dirac_params->picture = *(AVFrame*)data;
+    p_frame_src=(AVFrame*)data;
+    
+    /** allocate frame data to dirac input buffer */
+    /*
+    * input line size may differe from what the codec supports. Especially
+    * when transcoding from one format to another. So use avpicture_layout
+    * to copy the frame.
+    */
+    avpicture_layout ((AVPicture *)data, avccontext->pix_fmt, avccontext->width, avccontext->height,p_dirac_params->p_in_frame_buf, avccontext->frame_size);
+
+    /* load next frame*/
+    if (dirac_encoder_load( p_dirac_params->p_encoder, p_dirac_params->p_in_frame_buf, avccontext->frame_size ) < 0)
+    {
+        av_log(avccontext, AV_LOG_ERROR, "Unrecoverable Encoder Error. Quitting...\n");
+        return -1;
+    }
+     
+
+     do {
+            p_dirac_params->p_encoder->enc_buf.buffer = frame;
+            p_dirac_params->p_encoder->enc_buf.size = buf_size;
+            /* process frame */
+            state = dirac_encoder_output ( p_dirac_params->p_encoder );
+     
+            switch (state)
+            {
+                case ENC_STATE_AVAIL:
+                    assert (p_dirac_params->p_encoder->enc_buf.size > 0);
+                    /* create output frame*/
+                    p_frame_output=(struct FfmpegDiracOutputFrame*)av_malloc(sizeof(FfmpegDiracOutputFrame));
+                    memset(p_frame_output, 0, sizeof(FfmpegDiracOutputFrame));
+                
+                    /* set output data */
+                    p_frame_output->p_data=(unsigned char*)av_malloc(p_dirac_params->p_encoder->enc_buf.size);
+                    memcpy(p_frame_output->p_data,p_dirac_params->p_encoder->enc_buf.buffer,p_dirac_params->p_encoder->enc_buf.size);
+                    p_frame_output->size=p_dirac_params->p_encoder->enc_buf.size;
+                    p_frame_output->type=p_dirac_params->p_encoder->enc_fparams.ftype;
+                    if(p_dirac_params->p_next_output_frame==NULL)
+                    {
+                        p_dirac_params->p_next_output_frame=p_frame_output;
+                        p_dirac_params->p_last_output_frame=p_frame_output;
+                    }
+                    else
+                    {
+                        p_dirac_params->p_last_output_frame->p_next_frame=p_frame_output;
+                        p_dirac_params->p_last_output_frame=p_frame_output;
+                    }
+                    break;
+
+                case ENC_STATE_BUFFER:
+                    break;
+
+                case ENC_STATE_INVALID:
+                    av_log(avccontext, AV_LOG_ERROR, "Unrecoverable Encoder Error. Quitting...\n");
+                    return -1;
+                
+                default:
+                    av_log(avccontext, AV_LOG_ERROR, "Unknown Encoder state\n");
+                    return -1;
+            }
+        }
+        while(state==ENC_STATE_AVAIL);
+
+    /* copy 'next' frame in queue */
+    p_next_output_frame=p_dirac_params->p_next_output_frame;
+    if(p_next_output_frame==NULL)
+        return 0;
+
+    memcpy(frame, p_next_output_frame->p_data, p_next_output_frame->size);
+    avccontext->coded_frame->key_frame= p_next_output_frame->type == INTRA_FRAME;    
+    avccontext->coded_frame->pts= 0;    
+    enc_size=p_next_output_frame->size;
+
+    /*remove frame*/
+    p_dirac_params->p_next_output_frame=p_next_output_frame->p_next_frame;
+    av_free(p_next_output_frame->p_data);
+    av_free(p_next_output_frame);
+
+    return enc_size;
+}
+
+
+static int dirac_encode_close(AVCodecContext *avccontext)
+{
+   
+    FfmpegDiracParams* p_dirac_params = avccontext->priv_data;
+        
+     // close the encoder
+    dirac_encoder_close(p_dirac_params->p_encoder );     
+
+    av_free(p_dirac_params->p_in_frame_buf);
+    
+    return 0 ;
+}
+
+
+AVCodec dirac_encoder = {
+    "dirac",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_DIRAC,
+    sizeof(FfmpegDiracParams),
+    dirac_encode_init,
+    dirac_encode_frame,
+    dirac_encode_close,
+   .capabilities= CODEC_CAP_DELAY,
+} ;
+
+/**-------------------------DECODER------------------------------------------*/
+
+static int dirac_decode_init(AVCodecContext *avccontext)
+{
+
+    FfmpegDiracParams *p_dirac_params = (FfmpegDiracParams*)avccontext->priv_data ;
+    p_dirac_params->p_decoder =  dirac_decoder_init(avccontext->debug);
+
+    if (!p_dirac_params->p_decoder)
+        return -1;
+
+    return 0 ;
+}
+
+static int dirac_decode_frame(AVCodecContext *avccontext,
+                                void *data, int *data_size,
+                                uint8_t *buf, int buf_size)
+{
+   
+    FfmpegDiracParams *p_dirac_params=(FfmpegDiracParams*)avccontext->priv_data;
+    AVPicture *picture = (AVPicture*)data;
+    AVPicture pic;
+    int pict_size;
+    unsigned char *buffer[3];
+
+    *data_size = 0;
+
+    if(buf_size>0) 
+        /* set data to decode into buffer */
+        dirac_buffer (p_dirac_params->p_decoder, buf, buf+buf_size);
+    while (1)
+    {
+         /* parse data and process result */
+         DecoderState state = dirac_parse (p_dirac_params->p_decoder);
+         switch (state)
+         {
+            case STATE_BUFFER:
+                 return buf_size;
+
+            case STATE_SEQUENCE:
+                
+                /* tell ffmpeg about sequence details*/
+                avccontext->height=p_dirac_params->p_decoder->src_params.height;
+                avccontext->width=p_dirac_params->p_decoder->src_params.width;
+                avccontext->pix_fmt=GetFfmpegChromaFormat(p_dirac_params->p_decoder->src_params.chroma);
+                avccontext->time_base.den =p_dirac_params->p_decoder->src_params.frame_rate.numerator;
+                avccontext->time_base.num =p_dirac_params->p_decoder->src_params.frame_rate.denominator;
+                
+                /* calc output dimensions */
+                avpicture_fill(&pic, NULL, avccontext->pix_fmt, avccontext->width, avccontext->height); 
+                pict_size = avpicture_get_size(avccontext->pix_fmt, avccontext->width, avccontext->height);
+                
+                /* allocate output buffer */
+                if(p_dirac_params->p_out_frame_buf==0)
+                    p_dirac_params->p_out_frame_buf = (unsigned char *)av_malloc (pict_size);
+                buffer[0]=p_dirac_params->p_out_frame_buf;
+                buffer[1]=p_dirac_params->p_out_frame_buf+(pic.linesize[0]*avccontext->height);
+                buffer[2]=buffer[1]+(pic.linesize[1]*p_dirac_params->p_decoder->src_params.chroma_height);
+                
+                /* tell dirac about output destination */
+                dirac_set_buf(p_dirac_params->p_decoder, buffer, NULL);
+                break;
+                        
+            case STATE_SEQUENCE_END:
+                break;
+
+            case STATE_PICTURE_AVAIL:
+                /* fill pic with current buffer data from dirac*/
+                avpicture_fill(picture, p_dirac_params->p_out_frame_buf, avccontext->pix_fmt, avccontext->width, avccontext->height);
+                //*data_size=avpicture_get_size(avccontext->pix_fmt, avccontext->width, avccontext->height);
+                *data_size=1;
+                return buf_size;
+
+            case STATE_PICTURE_START:
+                 break;
+    
+            case STATE_INVALID: 
+                return -1;
+
+            default:
+                break;
+        }
+    }
+        
+    return buf_size;
+}
+
+
+static int dirac_decode_close(AVCodecContext *avccontext)
+{
+    FfmpegDiracParams *p_dirac_params=(FfmpegDiracParams*)avccontext->priv_data;    
+                
+    dirac_decoder_close (p_dirac_params->p_decoder);
+
+    av_free(p_dirac_params->p_out_frame_buf);
+    
+    return 0 ;
+}
+
+
+AVCodec dirac_decoder = {
+     "dirac",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_DIRAC,
+    sizeof(FfmpegDiracParams),
+    dirac_decode_init,
+    NULL,
+    dirac_decode_close,
+    dirac_decode_frame,
+    CODEC_CAP_DELAY
+} ;
+
+
+static int dirac_sync_video_packet (const uint8_t **buf, int buf_size,
+                                    FfmpegDiracParseContext *p_dirac_params,
+                                    int *start)
+{
+    int bytes_read = 0;
+    unsigned char* p_dirac_videobuf_code = p_dirac_params->dirac_videobuf_code;
+    p_dirac_params->dirac_videobuf_len=0;
+
+    while(p_dirac_params->dirac_videobuf_code_len<5)
+    {
+        p_dirac_videobuf_code[p_dirac_params->dirac_videobuf_code_len++]=*(*buf);
+        (*buf)++;
+        ++bytes_read;
+    }
+    while (1)
+    {
+        int c;
+        if(p_dirac_videobuf_code[0]==0x42 && p_dirac_videobuf_code[1]==0x42 && p_dirac_videobuf_code[2]==0x43 && p_dirac_videobuf_code[3]==0x44)
+            break;
+                
+        if (bytes_read >= buf_size  )
+            return -1;
+
+        ++(*start);
+        p_dirac_videobuf_code[0]=p_dirac_videobuf_code[1];
+        p_dirac_videobuf_code[1]=p_dirac_videobuf_code[2];
+        p_dirac_videobuf_code[2]=p_dirac_videobuf_code[3];
+        p_dirac_videobuf_code[3]=p_dirac_videobuf_code[4];
+        c = *(*buf);
+        (*buf)++;
+        ++bytes_read;
+        p_dirac_videobuf_code[4]=c;
+    }
+    
+    return p_dirac_videobuf_code[4];
+}
+
+static int dirac_find_frame_end(FfmpegDiracParseContext *p_dirac_params, 
+                                const uint8_t *buf, 
+                                const uint8_t *p_buf_end, int cur_idx)
+{
+    int byte;
+    int end_idx=cur_idx;
+
+     /* find end of frame */
+    int shift = 0xffffffff;
+    p_dirac_params->dirac_videobuf_code_len = 0;
+    while (p_dirac_params->in_frame)
+    {
+        if(buf==p_buf_end)
+            return -1;
+
+        byte = *buf;
+        if (byte < 0)
+            return -1;
+
+        if (shift == 0x42424344)
+        {
+            p_dirac_params->in_frame = 0;
+            p_dirac_params->dirac_videobuf_code_len = 5;
+            p_dirac_params->dirac_videobuf_code[0] = 0x42;
+            p_dirac_params->dirac_videobuf_code[1] = 0x42;
+            p_dirac_params->dirac_videobuf_code[2] = 0x43;
+            p_dirac_params->dirac_videobuf_code[3] = 0x44;
+            p_dirac_params->dirac_videobuf_code[4] = byte;
+            return end_idx;
+        }
+        shift = (shift << 8 ) | byte;
+        buf++;
+        end_idx++;
+    }
+    
+    return -1;
+
+}
+
+/*
+* Access unit header = 0x00
+* Intra_Ref start = 0x0C
+* Intra_NonRef start = 0x08
+* Inter_Ref_1Ref start = 0x0D
+* Inter_Ref_2Ref start = 0x0E
+* Inter_NonRef_1Ref start = 0x09
+* Inter_NonRef_2Ref start = 0x0A
+* End of sequence = 0x10
+*/
+#define FRAME_START(c) ((c) == 0x00 || (c) == 0x0C || (c) == 0x08 || (c) == 0x0D || (c) == 0x0E || (c) == 0x09 || (c) == 0x0A || (c) == 0x10)
+
+static int dirac_find_frame_start(FfmpegDiracParseContext *p_dirac_params, const uint8_t **buf, int buf_size)
+{
+    unsigned int shift = 0xffffffff;
+    int msg_type = 0;
+    int start=0;
+
+     /* find start of data */
+     msg_type = dirac_sync_video_packet(buf, buf_size, p_dirac_params, &start);
+
+    if (msg_type < 0)
+        return -1;
+
+        
+    /* find start of frame */
+    while (!p_dirac_params->in_frame)
+    {
+        int byte;
+        if (FRAME_START(msg_type))
+        {
+            p_dirac_params->in_frame = 1;
+            return start;
+        }
+
+        byte = *(*buf);
+        (*buf)++;
+        
+        if (byte < 0)
+        {
+            p_dirac_params->dirac_videobuf_code_len = 0;
+            return -1;
+        }
+
+        if (shift == 0x42424344)
+        {
+            if (FRAME_START(byte))
+            {
+                p_dirac_params->in_frame = 1;
+                return start;
+            }
+        }
+        shift = (shift << 8 ) | byte;
+        start++;
+    }
+    
+    return -1;
+
+}
+
+
+static int parse_dirac(AVCodecParserContext *s,
+                      AVCodecContext *avctx,
+                      const uint8_t **poutbuf, int *poutbuf_size, 
+                      const uint8_t *buf, int buf_size)
+{
+
+    int frame_start=0;
+    int frame_end;
+    const uint8_t *p_cur=buf;
+    
+    FfmpegDiracParseContext *p_dirac_params = (FfmpegDiracParseContext*)s->priv_data ;
+ 
+    if(buf_size==0)
+        return 0;
+    
+    
+    if(!p_dirac_params->in_frame)
+    {
+        frame_start=dirac_find_frame_start(p_dirac_params, &p_cur, buf_size);
+        if(frame_start==-1)
+        {
+            *poutbuf = NULL;
+            *poutbuf_size = 0;
+             return buf_size;
+        }
+    }
+    
+    frame_end = dirac_find_frame_end(p_dirac_params, p_cur, buf+buf_size, p_cur-buf);
+
+    /* no frame end - store data */
+    if(frame_end < 0)
+    {
+        memcpy(p_dirac_params->p_dirac_videobuffer+p_dirac_params->dirac_videobuf_len,
+               buf+frame_start, buf_size-frame_start);
+        p_dirac_params->dirac_videobuf_len+=buf_size-frame_start;
+               
+        *poutbuf = NULL;
+        *poutbuf_size = 0;
+         return buf_size;
+    }
+
+    /* have frame end */
+    memcpy(p_dirac_params->p_dirac_videobuffer+p_dirac_params->dirac_videobuf_len,
+           buf+frame_start, frame_end-frame_start+1);   
+           p_dirac_params->dirac_videobuf_len+=frame_end-frame_start+1;
+           
+    /* construct new frame */
+    *poutbuf=av_malloc(p_dirac_params->dirac_videobuf_len);
+    memcpy(*poutbuf, p_dirac_params->p_dirac_videobuffer, p_dirac_params->dirac_videobuf_len);
+    *poutbuf_size = p_dirac_params->dirac_videobuf_len;
+    
+    
+    return frame_end+1;
+}   
+   
+    
+    
+static int dirac_parse_close(AVCodecParserContext *s)
+{
+    FfmpegDiracParseContext *pc = s->priv_data;
+    av_freep(&pc->p_dirac_videobuffer);
+    return 0;
+}
+
+static int dirac_parse_open(AVCodecParserContext *s)
+{
+    FfmpegDiracParseContext *pc = s->priv_data;
+    pc->p_dirac_videobuffer = (unsigned char *)av_malloc(0x100000);
+    return 0;
+        
+}
+
+
+AVCodecParser dirac_parser = {
+    { CODEC_ID_DIRAC },
+    sizeof(FfmpegDiracParseContext),
+    dirac_parse_open,
+    parse_dirac,
+    dirac_parse_close,
+};
diff -urN ffmpeg-svn-r11604.orig/libavcodec/Makefile ffmpeg-svn-r11604/libavcodec/Makefile
--- ffmpeg-svn-r11604.orig/libavcodec/Makefile	2008-01-21 04:07:24 +0200
+++ ffmpeg-svn-r11604/libavcodec/Makefile	2008-01-24 02:03:42 +0200
@@ -305,6 +305,7 @@
 # external codec libraries
 OBJS-$(CONFIG_LIBA52)                  += liba52.o
 OBJS-$(CONFIG_LIBAMR)                  += libamr.o
+OBJS-$(CONFIG_LIBDIRAC)                += dirac.o
 OBJS-$(CONFIG_LIBFAAC)                 += libfaac.o
 OBJS-$(CONFIG_LIBFAAD)                 += libfaad.o
 OBJS-$(CONFIG_LIBGSM)                  += libgsm.o
diff -urN ffmpeg-svn-r11604.orig/libavformat/allformats.c ffmpeg-svn-r11604/libavformat/allformats.c
--- ffmpeg-svn-r11604.orig/libavformat/allformats.c	2008-01-21 04:07:25 +0200
+++ ffmpeg-svn-r11604/libavformat/allformats.c	2008-01-24 02:02:47 +0200
@@ -68,6 +68,7 @@
     REGISTER_DEMUXER  (C93, c93);
     REGISTER_MUXER    (CRC, crc);
     REGISTER_DEMUXER  (DAUD, daud);
+    REGISTER_MUXDEMUX (DIRAC, dirac);
     REGISTER_DEMUXER  (DSICIN, dsicin);
     REGISTER_DEMUXER  (DTS, dts);
     REGISTER_MUXDEMUX (DV, dv);
diff -urN ffmpeg-svn-r11604.orig/libavformat/raw.c ffmpeg-svn-r11604/libavformat/raw.c
--- ffmpeg-svn-r11604.orig/libavformat/raw.c	2008-01-21 04:07:25 +0200
+++ ffmpeg-svn-r11604/libavformat/raw.c	2008-01-24 02:02:47 +0200
@@ -236,6 +236,23 @@
     return 0;
 }
 
+/* drc read */
+static int dirac_read_header(AVFormatContext *s,
+                             AVFormatParameters *ap)
+{
+    AVStream *st;
+
+    st = av_new_stream(s, 0);
+    if (!st)
+        return AVERROR_NOMEM;
+
+    st->codec->codec_type = CODEC_TYPE_VIDEO;
+    st->codec->codec_id = CODEC_ID_DIRAC;
+    st->need_parsing = 1;
+    /* the parameters will be extracted from the compressed bitstream */
+    return 0;
+}
+
 static int shorten_read_header(AVFormatContext *s,
                                AVFormatParameters *ap)
 {
@@ -761,6 +778,33 @@
     .value = CODEC_ID_VC1,
 };
 
+AVInputFormat dirac_demuxer = {
+    "dirac",
+    "raw dirac",
+    0,
+    NULL,
+    dirac_read_header,
+    raw_read_partial_packet,
+    raw_read_close,
+    .extensions = "drc",
+    .value = CODEC_ID_DIRAC,
+};
+
+#ifdef CONFIG_MUXERS
+AVOutputFormat dirac_muxer = {
+    "dirac",
+    "raw dirac",
+    "dirac", 
+    "drc",
+    0,
+    0,
+    CODEC_ID_DIRAC,
+    NULL,
+    raw_write_packet,
+    NULL,
+};
+#endif //CONFIG_MUXERS
+
 /* pcm formats */
 
 #define PCMINPUTDEF(name, long_name, ext, codec) \
diff -urN ffmpeg-svn-r11604.orig/libavformat/riff.c ffmpeg-svn-r11604/libavformat/riff.c
--- ffmpeg-svn-r11604.orig/libavformat/riff.c	2007-09-22 01:38:40 +0300
+++ ffmpeg-svn-r11604/libavformat/riff.c	2008-01-24 02:02:47 +0200
@@ -172,6 +172,7 @@
     { CODEC_ID_JPEG2000, MKTAG('M', 'J', '2', 'C') },
     { CODEC_ID_VMNC, MKTAG('V', 'M', 'n', 'c') },
     { CODEC_ID_TARGA, MKTAG('t', 'g', 'a', ' ') },
+    { CODEC_ID_DIRAC, MKTAG('d', 'r', 'a', 'c') },
     { CODEC_ID_NONE, 0 },
 };
 
