diff -urN MPlayer-1.0pre5.orig/libdha/sysdep/pci_linux.c MPlayer-1.0pre5/libdha/sysdep/pci_linux.c
--- MPlayer-1.0pre5.orig/libdha/sysdep/pci_linux.c	2004-06-26 19:40:56 +0700
+++ MPlayer-1.0pre5/libdha/sysdep/pci_linux.c	2004-08-08 09:42:07 +0700
@@ -5,7 +5,7 @@
 */
 #include <errno.h>
 #ifdef __i386__
-// is this needed? #include <sys/perm.h>
+#include <sys/perm.h>
 #else
 #if !defined(__sparc__) && !defined(__powerpc__) && !defined(__x86_64__)
 #include <sys/io.h>
diff -urN MPlayer-1.0pre5.orig/libdha/sysdep/pci_linux.c.orig MPlayer-1.0pre5/libdha/sysdep/pci_linux.c.orig
--- MPlayer-1.0pre5.orig/libdha/sysdep/pci_linux.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libdha/sysdep/pci_linux.c.orig	2004-06-26 19:40:56 +0700
@@ -0,0 +1,189 @@
+/*
+   This file is based on:
+   $XFree86: xc/programs/Xserver/hw/xfree86/etc/scanpci.c,v 3.34.2.17 1998/11/10 11:55:40 dawes Exp $
+   Modified for readability by Nick Kurshev
+*/
+#include <errno.h>
+#ifdef __i386__
+// is this needed? #include <sys/perm.h>
+#else
+#if !defined(__sparc__) && !defined(__powerpc__) && !defined(__x86_64__)
+#include <sys/io.h>
+#endif
+#endif
+
+#include "config.h"
+
+#ifdef CONFIG_DHAHELPER
+#include <fcntl.h>
+int dhahelper_initialized = 0;
+int dhahelper_fd = 0;
+#endif
+
+#ifdef CONFIG_SVGAHELPER
+#include <svgalib_helper.h>
+#ifdef __linux__
+#include <linux/ioctl.h>
+#endif
+#include <fcntl.h>
+#ifndef SVGALIB_HELPER_IOC_MAGIC
+/* svgalib 1.9.18+ compatibility ::atmos */
+#define SVGALIB_HELPER_IOCGPCIINL SVGAHELPER_PCIINL
+#endif
+int svgahelper_initialized = 0;
+int svgahelper_fd = 0;
+
+static int pci_config_type(void)
+{
+    return 1;
+}
+
+static long pci_config_read_long(
+          unsigned char bus,
+          unsigned char dev,
+          int func, 
+          unsigned cmd)
+{
+    unsigned long config_cmd;
+    pcic_t p;
+    
+    p.address = cmd;
+    p.pcipos = (bus << 8) | dev | (func << 5);
+    
+    if (ioctl(svgahelper_fd, SVGALIB_HELPER_IOCGPCIINL, &p))
+	return -1;
+
+    return p.val;
+}
+
+static int pci_get_vendor(
+          unsigned char bus,
+          unsigned char dev,
+          int func)
+{
+    return pci_config_read_long(bus, dev, func, 0);
+}
+#endif
+
+static __inline__ int enable_os_io(void)
+{
+#ifdef CONFIG_SVGAHELPER
+    svgahelper_fd = open(DEV_SVGA, O_RDWR);
+    if (svgahelper_fd > 0)
+    {
+	svgahelper_initialized = 1;
+	return(0);
+    }
+    svgahelper_initialized = -1;
+#endif
+
+#ifdef CONFIG_DHAHELPER
+    dhahelper_fd = open("/dev/dhahelper", O_RDWR);
+    if (dhahelper_fd > 0)
+    {
+	dhahelper_initialized = 1;
+	return(0);
+    }
+    dhahelper_initialized = -1;
+#endif
+
+#if defined(__powerpc__) && defined(__linux__)
+/* should be fixed? */
+#else    
+    if (iopl(3) != 0)
+	return(errno);
+#endif    
+    return(0);
+}
+
+static __inline__ int disable_os_io(void)
+{
+#ifdef CONFIG_SVGAHELPER
+    if (svgahelper_initialized == 1)
+	close(svgahelper_fd);
+    else
+#endif
+#ifdef CONFIG_DHAHELPER
+    if (dhahelper_initialized == 1)
+	close(dhahelper_fd);
+    else
+#endif
+#if defined(__powerpc__) && defined(__linux__)
+/* should be fixed? */
+#else    
+    if (iopl(0) != 0)
+	return(errno);
+#endif    
+    return(0);
+}
+
+#if (defined(__powerpc__) || defined(__sparc__) || defined(__sparc64__) \
+    || defined(__x86_64__)) && defined(__linux__) && !defined(CONFIG_SVGAHELPER)
+#define CONFIG_PCI_LINUX_PROC
+#endif
+
+#if defined(CONFIG_PCI_LINUX_PROC)
+static int pci_config_type( void ) { return 1; }
+
+/* pci operations for (powerpc) Linux 
+   questions, suggestions etc: 
+   mplayer-dev-eng@mplayerhq.hu, colin@colino.net*/
+#include <fcntl.h>
+//#include <sys/io.h>
+#include <linux/pci.h>
+#include "../../bswap.h"
+
+static int pci_get_vendor(
+          unsigned char bus,
+          unsigned char dev,
+          int func)
+{
+    int retval;
+    char path[100];
+    int fd;
+    short vendor, device;
+    sprintf(path,"/proc/bus/pci/%02d/%02x.0", bus, dev);
+    fd = open(path,O_RDONLY|O_SYNC);
+    if (fd == -1) {
+	    retval=0xFFFF;
+    }
+    else if (pread(fd, &vendor, 2, PCI_VENDOR_ID) == 2 &&
+             pread(fd, &device, 2, PCI_DEVICE_ID) == 2) {
+	    vendor = le2me_16(vendor);
+	    device = le2me_16(device);
+	    retval = vendor + (device<<16); /*no worries about byte order, 
+	    				      all ppc are bigendian*/
+    } else {
+	    retval = 0xFFFF;
+    }   
+    if (fd > 0) {
+	    close(fd);
+    }
+    return retval;
+}
+
+static long pci_config_read_long(
+          unsigned char bus,
+          unsigned char dev,
+          int func, 
+          unsigned cmd)
+{
+    long retval;
+    char path[100];
+    int fd;
+    sprintf(path,"/proc/bus/pci/%02d/%02x.0", bus, dev);
+    fd = open(path,O_RDONLY|O_SYNC);
+    if (fd == -1) {
+	    retval=0;
+    }
+    else if (pread(fd, &retval, 4, cmd) == 4) {
+	    retval = le2me_32(retval);
+    } else {
+	    retval = 0;
+    }   
+    if (fd > 0) {
+	    close(fd);
+    }
+    return retval;
+}
+#endif
diff -urN MPlayer-1.0pre5.orig/libfaad2/sbr_dec.c MPlayer-1.0pre5/libfaad2/sbr_dec.c
--- MPlayer-1.0pre5.orig/libfaad2/sbr_dec.c	2004-06-23 20:50:51 +0700
+++ MPlayer-1.0pre5/libfaad2/sbr_dec.c	2004-08-08 09:42:07 +0700
@@ -192,7 +192,7 @@
 #if 1
         /* insert high frequencies here */
         /* hf generation using patching */
-        hf_generation(sbr, sbr->Xcodec[ch], sbr->Xsbr[ch]
+        hf_generation(sbr, (const qmf_t *)(sbr->Xcodec[ch]), sbr->Xsbr[ch]
 #ifdef SBR_LOW_POWER
             ,deg
 #endif
diff -urN MPlayer-1.0pre5.orig/libfaad2/sbr_dec.c.orig MPlayer-1.0pre5/libfaad2/sbr_dec.c.orig
--- MPlayer-1.0pre5.orig/libfaad2/sbr_dec.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libfaad2/sbr_dec.c.orig	2004-06-23 20:50:51 +0700
@@ -0,0 +1,481 @@
+/*
+** FAAD2 - Freeware Advanced Audio (AAC) Decoder including SBR decoding
+** Copyright (C) 2003-2004 M. Bakker, Ahead Software AG, http://www.nero.com
+**  
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+** 
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+** 
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software 
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+**
+** Any non-GPL usage of this software or parts of this software is strictly
+** forbidden.
+**
+** Commercial non-GPL licensing of this software is possible.
+** For more info contact Ahead Software through Mpeg4AAClicense@nero.com.
+**
+** Initially modified for use with MPlayer by Arpad Gereöffy on 2003/08/30
+** $Id: sbr_dec.c,v 1.4 2004/06/23 13:50:51 diego Exp $
+** detailed CVS changelog at http://www.mplayerhq.hu/cgi-bin/cvsweb.cgi/main/
+**/
+
+
+#include "common.h"
+#include "structs.h"
+
+#ifdef SBR_DEC
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "syntax.h"
+#include "bits.h"
+#include "sbr_syntax.h"
+#include "sbr_qmf.h"
+#include "sbr_hfgen.h"
+#include "sbr_hfadj.h"
+
+/* static function declarations */
+static uint8_t sbr_save_prev_data(sbr_info *sbr, uint8_t ch);
+
+sbr_info *sbrDecodeInit(uint16_t framelength, uint8_t id_aac,
+                        uint32_t sample_rate
+#ifdef DRM
+						, uint8_t IsDRM
+#endif
+                        )
+{
+    sbr_info *sbr = faad_malloc(sizeof(sbr_info));
+    memset(sbr, 0, sizeof(sbr_info));
+
+    /* save id of the parent element */
+    sbr->id_aac = id_aac;
+    sbr->sample_rate = sample_rate;
+
+    sbr->bs_freq_scale = 2;
+    sbr->bs_alter_scale = 1;
+    sbr->bs_noise_bands = 2;
+    sbr->bs_limiter_bands = 2;
+    sbr->bs_limiter_gains = 2;
+    sbr->bs_interpol_freq = 1;
+    sbr->bs_smoothing_mode = 1;
+    sbr->bs_start_freq = 5;
+    sbr->bs_amp_res = 1;
+    sbr->bs_samplerate_mode = 1;
+    sbr->prevEnvIsShort[0] = -1;
+    sbr->prevEnvIsShort[1] = -1;
+    sbr->header_count = 0;
+
+#ifdef DRM
+    sbr->Is_DRM_SBR = IsDRM;
+#endif
+    sbr->bs_samplerate_mode = 1;
+    sbr->tHFGen = T_HFGEN;
+    sbr->tHFAdj = T_HFADJ;
+
+    /* force sbr reset */
+    sbr->bs_start_freq_prev = -1;
+
+    if (framelength == 960)
+    {
+        sbr->numTimeSlotsRate = RATE * NO_TIME_SLOTS_960;
+        sbr->numTimeSlots = NO_TIME_SLOTS_960;
+    } else {
+        sbr->numTimeSlotsRate = RATE * NO_TIME_SLOTS;
+        sbr->numTimeSlots = NO_TIME_SLOTS;
+    }
+
+    return sbr;
+}
+
+void sbrDecodeEnd(sbr_info *sbr)
+{
+    uint8_t j;
+
+    if (sbr)
+    {
+        qmfa_end(sbr->qmfa[0]);
+        qmfs_end(sbr->qmfs[0]);
+        if (sbr->qmfs[1] != NULL)
+        {
+            qmfa_end(sbr->qmfa[1]);
+            qmfs_end(sbr->qmfs[1]);
+        }
+
+        for (j = 0; j < 5; j++)
+        {
+            if (sbr->G_temp_prev[0][j]) faad_free(sbr->G_temp_prev[0][j]);
+            if (sbr->Q_temp_prev[0][j]) faad_free(sbr->Q_temp_prev[0][j]);
+            if (sbr->G_temp_prev[1][j]) faad_free(sbr->G_temp_prev[1][j]);
+            if (sbr->Q_temp_prev[1][j]) faad_free(sbr->Q_temp_prev[1][j]);
+        }
+
+        faad_free(sbr);
+    }
+}
+
+static uint8_t sbr_save_prev_data(sbr_info *sbr, uint8_t ch)
+{
+    uint8_t i;
+
+    /* save data for next frame */
+    sbr->kx_prev = sbr->kx;
+
+    sbr->L_E_prev[ch] = sbr->L_E[ch];
+
+    /* sbr->L_E[ch] can become 0 on files with bit errors */
+    if (sbr->L_E[ch] <= 0)
+        return 19;
+
+    sbr->f_prev[ch] = sbr->f[ch][sbr->L_E[ch] - 1];
+    for (i = 0; i < 64; i++)
+    {
+        sbr->E_prev[ch][i] = sbr->E[ch][i][sbr->L_E[ch] - 1];
+        sbr->Q_prev[ch][i] = sbr->Q[ch][i][sbr->L_Q[ch] - 1];
+    }
+
+    for (i = 0; i < 64; i++)
+    {
+        sbr->bs_add_harmonic_prev[ch][i] = sbr->bs_add_harmonic[ch][i];
+    }
+    sbr->bs_add_harmonic_flag_prev[ch] = sbr->bs_add_harmonic_flag[ch];
+
+    if (sbr->l_A[ch] == sbr->L_E[ch])
+        sbr->prevEnvIsShort[ch] = 0;
+    else
+        sbr->prevEnvIsShort[ch] = -1;
+
+    return 0;
+}
+
+static void sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[MAX_NTSR][64],
+                                uint8_t ch, uint8_t dont_process)
+{
+    int16_t i, k, l;
+
+#ifdef SBR_LOW_POWER
+    ALIGN real_t deg[64];
+#endif
+
+    if (sbr->frame == 0)
+    {
+        uint8_t j;
+        sbr->qmfa[ch] = qmfa_init(32);
+        sbr->qmfs[ch] = qmfs_init(64);
+
+        for (j = 0; j < 5; j++)
+        {
+            sbr->G_temp_prev[ch][j] = faad_malloc(64*sizeof(real_t));
+            sbr->Q_temp_prev[ch][j] = faad_malloc(64*sizeof(real_t));
+        }
+
+        memset(sbr->Xsbr[ch], 0, (sbr->numTimeSlotsRate+sbr->tHFGen)*64 * sizeof(qmf_t));
+        memset(sbr->Xcodec[ch], 0, (sbr->numTimeSlotsRate+sbr->tHFGen)*32 * sizeof(qmf_t));
+    }
+
+    /* subband analysis */
+    if (dont_process)
+        sbr_qmf_analysis_32(sbr, sbr->qmfa[ch], channel_buf, sbr->Xcodec[ch], sbr->tHFGen, 32);
+    else
+        sbr_qmf_analysis_32(sbr, sbr->qmfa[ch], channel_buf, sbr->Xcodec[ch], sbr->tHFGen, sbr->kx);
+
+    if (!dont_process)
+    {
+#if 1
+        /* insert high frequencies here */
+        /* hf generation using patching */
+        hf_generation(sbr, sbr->Xcodec[ch], sbr->Xsbr[ch]
+#ifdef SBR_LOW_POWER
+            ,deg
+#endif
+            ,ch);
+#endif
+
+#ifdef SBR_LOW_POWER
+        for (l = sbr->t_E[ch][0]; l < sbr->t_E[ch][sbr->L_E[ch]]; l++)
+        {
+            for (k = 0; k < sbr->kx; k++)
+            {
+                QMF_RE(sbr->Xsbr[ch][sbr->tHFAdj + l][k]) = 0;
+            }
+        }
+#endif
+
+#if 1
+        /* hf adjustment */
+        hf_adjustment(sbr, sbr->Xsbr[ch]
+#ifdef SBR_LOW_POWER
+            ,deg
+#endif
+            ,ch);
+#endif
+    }
+
+    if ((sbr->just_seeked != 0) || dont_process)
+    {
+        for (l = 0; l < sbr->numTimeSlotsRate; l++)
+        {
+            for (k = 0; k < 32; k++)
+            {
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xcodec[ch][l + sbr->tHFAdj][k]);
+#ifndef SBR_LOW_POWER
+                QMF_IM(X[l][k]) = QMF_IM(sbr->Xcodec[ch][l + sbr->tHFAdj][k]);
+#endif
+            }
+            for (k = 32; k < 64; k++)
+            {
+                QMF_RE(X[l][k]) = 0;
+#ifndef SBR_LOW_POWER
+                QMF_IM(X[l][k]) = 0;
+#endif
+            }
+        }
+    } else {
+        for (l = 0; l < sbr->numTimeSlotsRate; l++)
+        {
+            uint8_t xover_band;
+
+            if (l < sbr->t_E[ch][0])
+                xover_band = sbr->kx_prev;
+            else
+                xover_band = sbr->kx;
+
+            for (k = 0; k < xover_band; k++)
+            {
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xcodec[ch][l + sbr->tHFAdj][k]);
+#ifndef SBR_LOW_POWER
+                QMF_IM(X[l][k]) = QMF_IM(sbr->Xcodec[ch][l + sbr->tHFAdj][k]);
+#endif
+            }
+            for (k = xover_band; k < 64; k++)
+            {
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+#ifndef SBR_LOW_POWER
+                QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+#endif
+            }
+#ifdef SBR_LOW_POWER
+            QMF_RE(X[l][xover_band - 1]) += QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][xover_band - 1]);
+#endif
+        }
+    }
+
+    for (i = 0; i < sbr->tHFGen; i++)
+    {
+        memmove(sbr->Xcodec[ch][i], sbr->Xcodec[ch][i+sbr->numTimeSlotsRate], 32 * sizeof(qmf_t));
+        memmove(sbr->Xsbr[ch][i], sbr->Xsbr[ch][i+sbr->numTimeSlotsRate], 64 * sizeof(qmf_t));
+    }
+}
+
+uint8_t sbrDecodeCoupleFrame(sbr_info *sbr, real_t *left_chan, real_t *right_chan,
+                             const uint8_t just_seeked, const uint8_t upsample_only)
+{
+    uint8_t dont_process = 0;
+    uint8_t ret = 0;
+    ALIGN qmf_t X[MAX_NTSR][64];
+
+    if (sbr == NULL)
+        return 20;
+
+    /* case can occur due to bit errors */
+    if (sbr->id_aac != ID_CPE)
+        return 21;
+
+    if (sbr->ret || (sbr->header_count == 0))
+    {
+        /* don't process just upsample */
+        dont_process = 1;
+
+        /* Re-activate reset for next frame */
+        if (sbr->ret && sbr->Reset)
+            sbr->bs_start_freq_prev = -1;
+    }
+
+    if (just_seeked)
+    {
+        sbr->just_seeked = 1;
+    } else {
+        sbr->just_seeked = 0;
+    }
+
+    sbr_process_channel(sbr, left_chan, X, 0, dont_process);
+    /* subband synthesis */
+#ifndef USE_SSE
+    sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X, left_chan);
+#else
+    sbr->qmfs[ch]->qmf_func(sbr, sbr->qmfs[0], X, left_chan);
+#endif
+
+    sbr_process_channel(sbr, right_chan, X, 1, dont_process);
+    /* subband synthesis */
+#ifndef USE_SSE
+    sbr_qmf_synthesis_64(sbr, sbr->qmfs[1], X, right_chan);
+#else
+    sbr->qmfs[ch]->qmf_func(sbr, sbr->qmfs[1], X, right_chan);
+#endif
+
+    if (sbr->bs_header_flag)
+        sbr->just_seeked = 0;
+
+    if (sbr->header_count != 0 && sbr->ret == 0)
+    {
+        ret = sbr_save_prev_data(sbr, 0);
+        if (ret) return ret;
+        ret = sbr_save_prev_data(sbr, 1);
+        if (ret) return ret;
+    }
+
+    sbr->frame++;
+
+    return 0;
+}
+
+uint8_t sbrDecodeSingleFrame(sbr_info *sbr, real_t *channel,
+                             const uint8_t just_seeked, const uint8_t upsample_only)
+{
+    uint8_t dont_process = 0;
+    uint8_t ret = 0;
+    ALIGN qmf_t X[MAX_NTSR][64];
+
+    if (sbr == NULL)
+        return 20;
+
+    /* case can occur due to bit errors */
+    if (sbr->id_aac != ID_SCE && sbr->id_aac != ID_LFE)
+        return 21;
+
+    if (sbr->ret || (sbr->header_count == 0))
+    {
+        /* don't process just upsample */
+        dont_process = 1;
+
+        /* Re-activate reset for next frame */
+        if (sbr->ret && sbr->Reset)
+            sbr->bs_start_freq_prev = -1;
+    }
+
+    if (just_seeked)
+    {
+        sbr->just_seeked = 1;
+    } else {
+        sbr->just_seeked = 0;
+    }
+
+    sbr_process_channel(sbr, channel, X, 0, dont_process);
+    /* subband synthesis */
+#ifndef USE_SSE
+    sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X, channel);
+#else
+    sbr->qmfs[ch]->qmf_func(sbr, sbr->qmfs[0], X, channel);
+#endif
+
+    if (sbr->bs_header_flag)
+        sbr->just_seeked = 0;
+
+    if (sbr->header_count != 0 && sbr->ret == 0)
+    {
+        ret = sbr_save_prev_data(sbr, 0);
+        if (ret) return ret;
+    }
+
+    sbr->frame++;
+
+    return 0;
+}
+
+static void ps_dummy_function(qmf_t X_mono[MAX_NTSR][64],
+                              qmf_t X_left[MAX_NTSR][64], qmf_t X_right[MAX_NTSR][64])
+{
+    uint8_t i, j;
+
+    for (i = 0; i < MAX_NTSR; i++)
+    {
+        for (j = 0; j < 64; j++)
+        {
+            QMF_RE(X_left[i][j]) = QMF_RE(X_mono[i][j]);
+            QMF_RE(X_right[i][j]) = QMF_RE(X_mono[i][j]);
+#ifndef SBR_LOW_POWER
+            QMF_IM(X_left[i][j]) = QMF_IM(X_mono[i][j]);
+            QMF_IM(X_right[i][j]) = QMF_IM(X_mono[i][j]);
+#endif
+        }
+    }
+}
+
+#if (defined(PS_DEC) || defined(DRM_PS))
+uint8_t sbrDecodeSingleFramePS(sbr_info *sbr, real_t *left_channel, real_t *right_channel,
+                               const uint8_t just_seeked, const uint8_t upsample_only)
+{
+    uint8_t dont_process = 0;
+    uint8_t ret = 0;
+    ALIGN qmf_t X_mono[MAX_NTSR][64];
+    ALIGN qmf_t X_left[MAX_NTSR][64];
+    ALIGN qmf_t X_right[MAX_NTSR][64];
+
+    if (sbr == NULL)
+        return 20;
+
+    /* case can occur due to bit errors */
+    if (sbr->id_aac != ID_SCE && sbr->id_aac != ID_LFE)
+        return 21;
+
+    if (sbr->ret || (sbr->header_count == 0))
+    {
+        /* don't process just upsample */
+        dont_process = 1;
+
+        /* Re-activate reset for next frame */
+        if (sbr->ret && sbr->Reset)
+            sbr->bs_start_freq_prev = -1;
+    }
+
+    if (just_seeked)
+    {
+        sbr->just_seeked = 1;
+    } else {
+        sbr->just_seeked = 0;
+    }
+
+    if (sbr->frame == 0)
+    {
+        sbr->qmfs[1] = qmfs_init(64);
+    }
+
+    sbr_process_channel(sbr, left_channel, X_mono, 0, dont_process);
+
+    /* perform parametric stereo */
+    ps_dummy_function(X_mono, X_left, X_right);
+
+    /* subband synthesis */
+#ifndef USE_SSE
+    sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X_left, left_channel);
+    sbr_qmf_synthesis_64(sbr, sbr->qmfs[1], X_right, right_channel);
+#else
+    sbr->qmfs[ch]->qmf_func(sbr, sbr->qmfs[0], X_left, left_channel);
+    sbr->qmfs[ch]->qmf_func(sbr, sbr->qmfs[1], X_right, right_channel);
+#endif
+
+    if (sbr->bs_header_flag)
+        sbr->just_seeked = 0;
+
+    if (sbr->header_count != 0 && sbr->ret == 0)
+    {
+        ret = sbr_save_prev_data(sbr, 0);
+        if (ret) return ret;
+    }
+
+    sbr->frame++;
+
+    return 0;
+}
+#endif
+
+#endif
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/pullup.c MPlayer-1.0pre5/libmpcodecs/pullup.c
--- MPlayer-1.0pre5.orig/libmpcodecs/pullup.c	2004-06-10 12:06:34 +0700
+++ MPlayer-1.0pre5/libmpcodecs/pullup.c	2004-08-08 09:42:07 +0700
@@ -216,16 +216,16 @@
 struct pullup_buffer *pullup_lock_buffer(struct pullup_buffer *b, int parity)
 {
 	if (!b) return 0;
-	if (parity+1 & 1) b->lock[0]++;
-	if (parity+1 & 2) b->lock[1]++;
+	if ((parity+1) & 1) b->lock[0]++;
+	if ((parity+1) & 2) b->lock[1]++;
 	return b;
 }
 
 void pullup_release_buffer(struct pullup_buffer *b, int parity)
 {
 	if (!b) return;
-	if (parity+1 & 1) b->lock[0]--;
-	if (parity+1 & 2) b->lock[1]--;
+	if ((parity+1) & 1) b->lock[0]--;
+	if ((parity+1) & 2) b->lock[1]--;
 }
 
 struct pullup_buffer *pullup_get_buffer(struct pullup_context *c, int parity)
@@ -251,8 +251,8 @@
 	
 	/* Search for any half-free buffer */
 	for (i = 0; i < c->nbuffers; i++) {
-		if (parity+1 & 1 && c->buffers[i].lock[0]) continue;
-		if (parity+1 & 2 && c->buffers[i].lock[1]) continue;
+		if ((parity+1) & 1 && c->buffers[i].lock[0]) continue;
+		if ((parity+1) & 2 && c->buffers[i].lock[1]) continue;
 		alloc_buffer(c, &c->buffers[i]);
 		return pullup_lock_buffer(&c->buffers[i], parity);
 	}
@@ -660,8 +660,8 @@
 	if (c->nbuffers < 10) c->nbuffers = 10;
 	c->buffers = calloc(c->nbuffers, sizeof (struct pullup_buffer));
 
-	c->metric_w = (c->w[mp] - (c->junk_left + c->junk_right << 3)) >> 3;
-	c->metric_h = (c->h[mp] - (c->junk_top + c->junk_bottom << 1)) >> 3;
+	c->metric_w = (c->w[mp] - ((c->junk_left + c->junk_right) << 3)) >> 3;
+	c->metric_h = (c->h[mp] - ((c->junk_top + c->junk_bottom) << 1)) >> 3;
 	c->metric_offset = c->junk_left*c->bpp[mp] + (c->junk_top<<1)*c->stride[mp];
 	c->metric_len = c->metric_w * c->metric_h;
 	
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/pullup.c.orig MPlayer-1.0pre5/libmpcodecs/pullup.c.orig
--- MPlayer-1.0pre5.orig/libmpcodecs/pullup.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpcodecs/pullup.c.orig	2004-06-10 12:06:34 +0700
@@ -0,0 +1,718 @@
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "pullup.h"
+#include "config.h"
+
+
+
+#ifdef HAVE_MMX
+static int diff_y_mmx(unsigned char *a, unsigned char *b, int s)
+{
+	int ret;
+	asm volatile (
+		"movl $4, %%ecx \n\t"
+		"pxor %%mm4, %%mm4 \n\t"
+		"pxor %%mm7, %%mm7 \n\t"
+		
+		".balign 16 \n\t"
+		"1: \n\t"
+		
+		"movq (%%esi), %%mm0 \n\t"
+		"movq (%%esi), %%mm2 \n\t"
+		"addl %%eax, %%esi \n\t"
+		"movq (%%edi), %%mm1 \n\t"
+		"addl %%eax, %%edi \n\t"
+		"psubusb %%mm1, %%mm2 \n\t"
+		"psubusb %%mm0, %%mm1 \n\t"
+		"movq %%mm2, %%mm0 \n\t"
+		"movq %%mm1, %%mm3 \n\t"
+		"punpcklbw %%mm7, %%mm0 \n\t"
+		"punpcklbw %%mm7, %%mm1 \n\t"
+		"punpckhbw %%mm7, %%mm2 \n\t"
+		"punpckhbw %%mm7, %%mm3 \n\t"
+		"paddw %%mm0, %%mm4 \n\t"
+		"paddw %%mm1, %%mm4 \n\t"
+		"paddw %%mm2, %%mm4 \n\t"
+		"paddw %%mm3, %%mm4 \n\t"
+		
+		"decl %%ecx \n\t"
+		"jnz 1b \n\t"
+
+		"movq %%mm4, %%mm3 \n\t"
+		"punpcklwd %%mm7, %%mm4 \n\t"
+		"punpckhwd %%mm7, %%mm3 \n\t"
+		"paddd %%mm4, %%mm3 \n\t"
+		"movd %%mm3, %%eax \n\t"
+		"psrlq $32, %%mm3 \n\t"
+		"movd %%mm3, %%edx \n\t"
+		"addl %%edx, %%eax \n\t"
+		"emms \n\t"
+		: "=a" (ret)
+		: "S" (a), "D" (b), "a" (s)
+		: "%edx"
+		);
+	return ret;
+}
+
+static int licomb_y_mmx(unsigned char *a, unsigned char *b, int s)
+{
+	int ret;
+	asm volatile (
+		"movl $4, %%ecx \n\t"
+		"pxor %%mm6, %%mm6 \n\t"
+		"pxor %%mm7, %%mm7 \n\t"
+		"subl %%eax, %%edi \n\t"
+		
+		".balign 16 \n\t"
+		"2: \n\t"
+
+		"movq (%%esi), %%mm0 \n\t"
+		"movq (%%edi), %%mm1 \n\t"
+		"punpcklbw %%mm7, %%mm0 \n\t"
+		"movq (%%edi,%%eax), %%mm2 \n\t"
+		"punpcklbw %%mm7, %%mm1 \n\t"
+		"punpcklbw %%mm7, %%mm2 \n\t"
+		"paddw %%mm0, %%mm0 \n\t"
+		"paddw %%mm2, %%mm1 \n\t"
+		"movq %%mm0, %%mm2 \n\t"
+		"psubusw %%mm1, %%mm0 \n\t"
+		"psubusw %%mm2, %%mm1 \n\t"
+		"paddw %%mm0, %%mm6 \n\t"
+		"paddw %%mm1, %%mm6 \n\t"
+
+		"movq (%%esi), %%mm0 \n\t"
+		"movq (%%edi), %%mm1 \n\t"
+		"punpckhbw %%mm7, %%mm0 \n\t"
+		"movq (%%edi,%%eax), %%mm2 \n\t"
+		"punpckhbw %%mm7, %%mm1 \n\t"
+		"punpckhbw %%mm7, %%mm2 \n\t"
+		"paddw %%mm0, %%mm0 \n\t"
+		"paddw %%mm2, %%mm1 \n\t"
+		"movq %%mm0, %%mm2 \n\t"
+		"psubusw %%mm1, %%mm0 \n\t"
+		"psubusw %%mm2, %%mm1 \n\t"
+		"paddw %%mm0, %%mm6 \n\t"
+		"paddw %%mm1, %%mm6 \n\t"
+		
+		"movq (%%edi,%%eax), %%mm0 \n\t"
+		"movq (%%esi), %%mm1 \n\t"
+		"punpcklbw %%mm7, %%mm0 \n\t"
+		"movq (%%esi,%%eax), %%mm2 \n\t"
+		"punpcklbw %%mm7, %%mm1 \n\t"
+		"punpcklbw %%mm7, %%mm2 \n\t"
+		"paddw %%mm0, %%mm0 \n\t"
+		"paddw %%mm2, %%mm1 \n\t"
+		"movq %%mm0, %%mm2 \n\t"
+		"psubusw %%mm1, %%mm0 \n\t"
+		"psubusw %%mm2, %%mm1 \n\t"
+		"paddw %%mm0, %%mm6 \n\t"
+		"paddw %%mm1, %%mm6 \n\t"
+		
+		"movq (%%edi,%%eax), %%mm0 \n\t"
+		"movq (%%esi), %%mm1 \n\t"
+		"punpckhbw %%mm7, %%mm0 \n\t"
+		"movq (%%esi,%%eax), %%mm2 \n\t"
+		"punpckhbw %%mm7, %%mm1 \n\t"
+		"punpckhbw %%mm7, %%mm2 \n\t"
+		"paddw %%mm0, %%mm0 \n\t"
+		"paddw %%mm2, %%mm1 \n\t"
+		"movq %%mm0, %%mm2 \n\t"
+		"psubusw %%mm1, %%mm0 \n\t"
+		"psubusw %%mm2, %%mm1 \n\t"
+		"paddw %%mm0, %%mm6 \n\t"
+		"paddw %%mm1, %%mm6 \n\t"
+
+		"addl %%eax, %%esi \n\t"
+		"addl %%eax, %%edi \n\t"
+		"decl %%ecx \n\t"
+		"jnz 2b \n\t"
+		
+		"movq %%mm6, %%mm5 \n\t"
+		"punpcklwd %%mm7, %%mm6 \n\t"
+		"punpckhwd %%mm7, %%mm5 \n\t"
+		"paddd %%mm6, %%mm5 \n\t"
+		"movd %%mm5, %%eax \n\t"
+		"psrlq $32, %%mm5 \n\t"
+		"movd %%mm5, %%edx \n\t"
+		"addl %%edx, %%eax \n\t"
+		
+		"emms \n\t"
+		: "=a" (ret)
+		: "S" (a), "D" (b), "a" (s)
+		: "%edx"
+		);
+	return ret;
+}
+#endif
+
+#define ABS(a) (((a)^((a)>>31))-((a)>>31))
+
+static int diff_y(unsigned char *a, unsigned char *b, int s)
+{
+	int i, j, diff=0;
+	for (i=4; i; i--) {
+		for (j=0; j<8; j++) diff += ABS(a[j]-b[j]);
+		a+=s; b+=s;
+	}
+	return diff;
+}
+
+static int licomb_y(unsigned char *a, unsigned char *b, int s)
+{
+	int i, j, diff=0;
+	for (i=4; i; i--) {
+		for (j=0; j<8; j++)
+			diff += ABS((a[j]<<1) - b[j-s] - b[j])
+				+ ABS((b[j]<<1) - a[j] - a[j+s]);
+		a+=s; b+=s;
+	}
+	return diff;
+}
+
+static int qpcomb_y(unsigned char *a, unsigned char *b, int s)
+{
+	int i, j, diff=0;
+	for (i=4; i; i--) {
+		for (j=0; j<8; j++)
+			diff += ABS(a[j] - 3*b[j-s] + 3*a[j+s] - b[j]);
+		a+=s; b+=s;
+	}
+	return diff;
+}
+
+#if 0
+static int licomb_y_test(unsigned char *a, unsigned char *b, int s)
+{
+	int c = licomb_y(a,b,s);
+	int m = licomb_y_mmx(a,b,s);
+	if (c != m) printf("%d != %d\n", c, m);
+	return m;
+}
+#endif
+
+
+
+
+
+
+
+
+
+static void alloc_buffer(struct pullup_context *c, struct pullup_buffer *b)
+{
+	int i;
+	if (b->planes) return;
+	b->planes = calloc(c->nplanes, sizeof(unsigned char *));
+	for (i = 0; i < c->nplanes; i++) {
+		b->planes[i] = malloc(c->h[i]*c->stride[i]);
+		/* Deal with idiotic 128=0 for chroma: */
+		memset(b->planes[i], c->background[i], c->h[i]*c->stride[i]);
+	}
+}
+
+struct pullup_buffer *pullup_lock_buffer(struct pullup_buffer *b, int parity)
+{
+	if (!b) return 0;
+	if (parity+1 & 1) b->lock[0]++;
+	if (parity+1 & 2) b->lock[1]++;
+	return b;
+}
+
+void pullup_release_buffer(struct pullup_buffer *b, int parity)
+{
+	if (!b) return;
+	if (parity+1 & 1) b->lock[0]--;
+	if (parity+1 & 2) b->lock[1]--;
+}
+
+struct pullup_buffer *pullup_get_buffer(struct pullup_context *c, int parity)
+{
+	int i;
+
+	/* Try first to get the sister buffer for the previous field */
+	if (parity < 2 && c->last && parity != c->last->parity
+	    && !c->last->buffer->lock[parity]) {
+		alloc_buffer(c, c->last->buffer);
+		return pullup_lock_buffer(c->last->buffer, parity);
+	}
+	
+	/* Prefer a buffer with both fields open */
+	for (i = 0; i < c->nbuffers; i++) {
+		if (c->buffers[i].lock[0]) continue;
+		if (c->buffers[i].lock[1]) continue;
+		alloc_buffer(c, &c->buffers[i]);
+		return pullup_lock_buffer(&c->buffers[i], parity);
+	}
+
+	if (parity == 2) return 0;
+	
+	/* Search for any half-free buffer */
+	for (i = 0; i < c->nbuffers; i++) {
+		if (parity+1 & 1 && c->buffers[i].lock[0]) continue;
+		if (parity+1 & 2 && c->buffers[i].lock[1]) continue;
+		alloc_buffer(c, &c->buffers[i]);
+		return pullup_lock_buffer(&c->buffers[i], parity);
+	}
+	
+	return 0;
+}
+
+
+
+
+
+
+static void compute_metric(struct pullup_context *c,
+	struct pullup_field *fa, int pa,
+	struct pullup_field *fb, int pb,
+	int (*func)(unsigned char *, unsigned char *, int), int *dest)
+{
+	unsigned char *a, *b;
+	int x, y;
+	int mp = c->metric_plane;
+	int xstep = c->bpp[mp];
+	int ystep = c->stride[mp]<<3;
+	int s = c->stride[mp]<<1; /* field stride */
+	int w = c->metric_w*xstep;
+
+	if (!fa->buffer || !fb->buffer) return;
+
+	/* Shortcut for duplicate fields (e.g. from RFF flag) */
+	if (fa->buffer == fb->buffer && pa == pb) {
+		memset(dest, 0, c->metric_len * sizeof(int));
+		return;
+	}
+
+	a = fa->buffer->planes[mp] + pa * c->stride[mp] + c->metric_offset;
+	b = fb->buffer->planes[mp] + pb * c->stride[mp] + c->metric_offset;
+
+	for (y = c->metric_h; y; y--) {
+		for (x = 0; x < w; x += xstep) {
+			*dest++ = func(a + x, b + x, s);
+		}
+		a += ystep; b += ystep;
+	}
+}
+
+
+
+
+
+static void alloc_metrics(struct pullup_context *c, struct pullup_field *f)
+{
+	f->diffs = calloc(c->metric_len, sizeof(int));
+	f->comb = calloc(c->metric_len, sizeof(int));
+	/* add more metrics here as needed */
+}
+
+static struct pullup_field *make_field_queue(struct pullup_context *c, int len)
+{
+	struct pullup_field *head, *f;
+	f = head = calloc(1, sizeof(struct pullup_field));
+	alloc_metrics(c, f);
+	for (; len > 0; len--) {
+		f->next = calloc(1, sizeof(struct pullup_field));
+		f->next->prev = f;
+		f = f->next;
+		alloc_metrics(c, f);
+	}
+	f->next = head;
+	head->prev = f;
+	return head;
+}
+
+static void check_field_queue(struct pullup_context *c)
+{
+	if (c->head->next == c->first) {
+		struct pullup_field *f = calloc(1, sizeof(struct pullup_field));
+		alloc_metrics(c, f);
+		f->prev = c->head;
+		f->next = c->first;
+		c->head->next = f;
+		c->first->prev = f;
+	}
+}
+
+void pullup_submit_field(struct pullup_context *c, struct pullup_buffer *b, int parity)
+{
+	struct pullup_field *f;
+	
+	/* Grow the circular list if needed */
+	check_field_queue(c);
+	
+	/* Cannot have two fields of same parity in a row; drop the new one */
+	if (c->last && c->last->parity == parity) return;
+
+	f = c->head;
+	f->parity = parity;
+	f->buffer = pullup_lock_buffer(b, parity);
+	f->flags = 0;
+	f->breaks = 0;
+	f->affinity = 0;
+
+	compute_metric(c, f, parity, f->prev->prev, parity, c->diff, f->diffs);
+	compute_metric(c, parity?f->prev:f, 0, parity?f:f->prev, 1, c->comb, f->comb);
+
+	/* Advance the circular list */
+	if (!c->first) c->first = c->head;
+	c->last = c->head;
+	c->head = c->head->next;
+}
+
+void pullup_flush_fields(struct pullup_context *c)
+{
+	struct pullup_field *f;
+	
+	for (f = c->first; f && f != c->head; f = f->next) {
+		pullup_release_buffer(f->buffer, f->parity);
+		f->buffer = 0;
+	}
+	c->first = c->last = 0;
+}
+
+
+
+
+
+
+
+
+#define F_HAVE_BREAKS 1
+#define F_HAVE_AFFINITY 2
+
+
+#define BREAK_LEFT 1
+#define BREAK_RIGHT 2
+
+
+
+
+static int queue_length(struct pullup_field *begin, struct pullup_field *end)
+{
+	int count = 1;
+	struct pullup_field *f;
+	
+	if (!begin || !end) return 0;
+	for (f = begin; f != end; f = f->next) count++;
+	return count;
+}
+
+static int find_first_break(struct pullup_field *f, int max)
+{
+	int i;
+	for (i = 0; i < max; i++) {
+		if (f->breaks & BREAK_RIGHT || f->next->breaks & BREAK_LEFT)
+			return i+1;
+		f = f->next;
+	}
+	return 0;
+}
+
+static void compute_breaks(struct pullup_context *c, struct pullup_field *f0)
+{
+	int i;
+	struct pullup_field *f1 = f0->next;
+	struct pullup_field *f2 = f1->next;
+	struct pullup_field *f3 = f2->next;
+	int l, max_l=0, max_r=0;
+
+	if (f0->flags & F_HAVE_BREAKS) return;
+	f0->flags |= F_HAVE_BREAKS;
+
+	/* Special case when fields are 100% identical */
+	if (f0->buffer == f2->buffer && f1->buffer != f3->buffer) {
+		f2->breaks |= BREAK_RIGHT;
+		return;
+	}
+	if (f0->buffer != f2->buffer && f1->buffer == f3->buffer) {
+		f1->breaks |= BREAK_LEFT;
+		return;
+	}
+
+	for (i = 0; i < c->metric_len; i++) {
+		l = f2->diffs[i] - f3->diffs[i];
+		if (l > max_l) max_l = l;
+		if (-l > max_r) max_r = -l;
+	}
+	/* Don't get tripped up when differences are mostly quant error */
+	if (max_l + max_r < 128) return;
+	if (max_l > 4*max_r) f1->breaks |= BREAK_LEFT;
+	if (max_r > 4*max_l) f2->breaks |= BREAK_RIGHT;
+}
+
+static void compute_affinity(struct pullup_context *c, struct pullup_field *f)
+{
+	int i;
+	int max_l=0, max_r=0, l;
+	if (f->flags & F_HAVE_AFFINITY) return;
+	f->flags |= F_HAVE_AFFINITY;
+	for (i = 0; i < c->metric_len; i++) {
+		l = f->comb[i] - f->next->comb[i];
+		if (l > max_l) max_l = l;
+		if (-l > max_r) max_r = -l;
+	}
+	if (max_l + max_r < 64) return;
+	if (max_r > 2*max_l) f->affinity = -1;
+	else if (max_l > 2*max_r) f->affinity = 1;
+}
+
+static void foo(struct pullup_context *c)
+{
+	struct pullup_field *f = c->first;
+	int i, n = queue_length(f, c->last);
+	for (i = 0; i < n-1; i++) {
+		if (i < n-3) compute_breaks(c, f);
+		compute_affinity(c, f);
+		f = f->next;
+	}
+}
+
+static int decide_frame_length(struct pullup_context *c)
+{
+	struct pullup_field *f0 = c->first;
+	struct pullup_field *f1 = f0->next;
+	struct pullup_field *f2 = f1->next;
+	struct pullup_field *f3 = f2->next;
+	
+	if (queue_length(c->first, c->last) < 6) return 0;
+	foo(c);
+
+	if (f0->affinity == -1) return 1;
+
+	switch (find_first_break(f0, 3)) {
+	case 1:
+		if (!c->strict_breaks && f0->affinity == 1 && f1->affinity == -1)
+			return 2;
+		else return 1;
+	case 2:
+		/* FIXME: strictly speaking, f0->prev is no longer valid... :) */
+		if (c->strict_pairs
+			&& (f0->prev->breaks & BREAK_RIGHT) && (f2->breaks & BREAK_LEFT)
+			&& (f0->affinity != 1 || f1->affinity != -1) )
+			return 1;
+		if (f1->affinity == 1) return 1;
+		else return 2;
+	case 3:
+		if (f2->affinity == 1) return 2;
+		else return 3;
+	default:
+		/* 9 possibilities covered before switch */
+		if (f1->affinity == 1) return 1; /* covers 6 */
+		else if (f1->affinity == -1) return 2; /* covers 6 */
+		else if (f2->affinity == -1) { /* covers 2 */
+			if (f0->affinity == 1) return 3;
+			else return 1;
+		}
+		else return 2; /* the remaining 6 */
+	}
+}
+
+
+static void print_aff_and_breaks(struct pullup_context *c, struct pullup_field *f)
+{
+	int i;
+	int max_l, max_r, l;
+	struct pullup_field *f0 = f;
+	const char aff_l[] = "+..", aff_r[] = "..+";
+	printf("\naffinity: ");
+	for (i = 0; i < 6; i++) {
+		printf("%c%d%c", aff_l[1+f->affinity], i, aff_r[1+f->affinity]);
+		f = f->next;
+	}
+	f = f0;
+	printf("\nbreaks:   ");
+	for (i=0; i<6; i++) {
+		printf("%c%d%c", f->breaks & BREAK_LEFT ? '|' : '.', i, f->breaks & BREAK_RIGHT ? '|' : '.');
+		f = f->next;
+	}
+	printf("\n");
+}
+
+
+
+
+
+struct pullup_frame *pullup_get_frame(struct pullup_context *c)
+{
+	int i;
+	struct pullup_frame *fr = c->frame;
+	int n = decide_frame_length(c);
+	int aff = c->first->next->affinity;
+
+	if (!n) return 0;
+	if (fr->lock) return 0;
+
+	if (c->verbose) {
+		print_aff_and_breaks(c, c->first);
+		printf("duration: %d    \n", n);
+	}
+
+	fr->lock++;
+	fr->length = n;
+	fr->parity = c->first->parity;
+	fr->buffer = 0;
+	for (i = 0; i < n; i++) {
+		/* We cheat and steal the buffer without release+relock */
+		fr->ifields[i] = c->first->buffer;
+		c->first->buffer = 0;
+		c->first = c->first->next;
+	}
+	
+	if (n == 1) {
+		fr->ofields[fr->parity] = fr->ifields[0];
+		fr->ofields[fr->parity^1] = 0;
+	} else if (n == 2) {
+		fr->ofields[fr->parity] = fr->ifields[0];
+		fr->ofields[fr->parity^1] = fr->ifields[1];
+	} else if (n == 3) {
+		if (aff == 0)
+			aff = (fr->ifields[0] == fr->ifields[1]) ? -1 : 1;
+		/* else if (c->verbose) printf("forced aff: %d    \n", aff); */
+		fr->ofields[fr->parity] = fr->ifields[1+aff];
+		fr->ofields[fr->parity^1] = fr->ifields[1];
+	}
+	pullup_lock_buffer(fr->ofields[0], 0);
+	pullup_lock_buffer(fr->ofields[1], 1);
+	
+	if (fr->ofields[0] == fr->ofields[1]) {
+		fr->buffer = fr->ofields[0];
+		pullup_lock_buffer(fr->buffer, 2);
+		return fr;
+	}
+	return fr;
+}
+
+static void copy_field(struct pullup_context *c, struct pullup_buffer *dest,
+	struct pullup_buffer *src, int parity)
+{
+	int i, j;
+	unsigned char *d, *s;
+	for (i = 0; i < c->nplanes; i++) {
+		s = src->planes[i] + parity*c->stride[i];
+		d = dest->planes[i] + parity*c->stride[i];
+		for (j = c->h[i]>>1; j; j--) {
+			memcpy(d, s, c->stride[i]);
+			s += c->stride[i]<<1;
+			d += c->stride[i]<<1;
+		}
+	}
+}
+
+void pullup_pack_frame(struct pullup_context *c, struct pullup_frame *fr)
+{
+	int i;
+	int par = fr->parity;
+	if (fr->buffer) return;
+	if (fr->length < 2) return; /* FIXME: deal with this */
+	for (i = 0; i < 2; i++)
+	{
+		if (fr->ofields[i]->lock[i^1]) continue;
+		fr->buffer = fr->ofields[i];
+		pullup_lock_buffer(fr->buffer, 2);
+		copy_field(c, fr->buffer, fr->ofields[i^1], i^1);
+		return;
+	}
+	fr->buffer = pullup_get_buffer(c, 2);
+	copy_field(c, fr->buffer, fr->ofields[0], 0);
+	copy_field(c, fr->buffer, fr->ofields[1], 1);
+}
+
+void pullup_release_frame(struct pullup_frame *fr)
+{
+	int i;
+	for (i = 0; i < fr->length; i++)
+		pullup_release_buffer(fr->ifields[i], fr->parity ^ (i&1));
+	pullup_release_buffer(fr->ofields[0], 0);
+	pullup_release_buffer(fr->ofields[1], 1);
+	if (fr->buffer) pullup_release_buffer(fr->buffer, 2);
+	fr->lock--;
+}
+
+
+
+
+
+
+struct pullup_context *pullup_alloc_context()
+{
+	struct pullup_context *c;
+
+	c = calloc(1, sizeof(struct pullup_context));
+
+	return c;
+}
+
+void pullup_preinit_context(struct pullup_context *c)
+{
+	c->bpp = calloc(c->nplanes, sizeof(int));
+	c->w = calloc(c->nplanes, sizeof(int));
+	c->h = calloc(c->nplanes, sizeof(int));
+	c->stride = calloc(c->nplanes, sizeof(int));
+	c->background = calloc(c->nplanes, sizeof(int));
+}
+
+void pullup_init_context(struct pullup_context *c)
+{
+	int mp = c->metric_plane;
+	if (c->nbuffers < 10) c->nbuffers = 10;
+	c->buffers = calloc(c->nbuffers, sizeof (struct pullup_buffer));
+
+	c->metric_w = (c->w[mp] - (c->junk_left + c->junk_right << 3)) >> 3;
+	c->metric_h = (c->h[mp] - (c->junk_top + c->junk_bottom << 1)) >> 3;
+	c->metric_offset = c->junk_left*c->bpp[mp] + (c->junk_top<<1)*c->stride[mp];
+	c->metric_len = c->metric_w * c->metric_h;
+	
+	c->head = make_field_queue(c, 8);
+
+	c->frame = calloc(1, sizeof (struct pullup_frame));
+	c->frame->ifields = calloc(3, sizeof (struct pullup_buffer *));
+
+	switch(c->format) {
+	case PULLUP_FMT_Y:
+		c->diff = diff_y;
+		c->comb = licomb_y;
+#ifdef HAVE_MMX
+		if (c->cpu & PULLUP_CPU_MMX) {
+			c->diff = diff_y_mmx;
+			c->comb = licomb_y_mmx;
+		}
+#endif
+		/* c->comb = qpcomb_y; */
+		break;
+#if 0
+	case PULLUP_FMT_YUY2:
+		c->diff = diff_yuy2;
+		break;
+	case PULLUP_FMT_RGB32:
+		c->diff = diff_rgb32;
+		break;
+#endif
+	}
+}
+
+void pullup_free_context(struct pullup_context *c)
+{
+	struct pullup_field *f;
+	free(c->buffers);
+	f = c->head;
+	do {
+		free(f->diffs);
+		free(f->comb);
+		f = f->next;
+		free(f->prev);
+	} while (f != c->head);
+	free(c->frame);
+	free(c);
+}
+
+
+
+
+
+
+
+
+
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/vd_libmpeg2.c MPlayer-1.0pre5/libmpcodecs/vd_libmpeg2.c
--- MPlayer-1.0pre5.orig/libmpcodecs/vd_libmpeg2.c	2004-06-12 23:35:52 +0700
+++ MPlayer-1.0pre5/libmpcodecs/vd_libmpeg2.c	2004-08-08 09:42:07 +0700
@@ -72,7 +72,7 @@
     mpeg2_close (mpeg2dec);
 }
 
-static void draw_slice (void * _sh, uint8_t ** src, unsigned int y){ 
+static void draw_slice (void * _sh, uint8_t * const * src, unsigned int y){ 
     sh_video_t* sh = (sh_video_t*) _sh;
     mpeg2dec_t* mpeg2dec = sh->context;
     const mpeg2_info_t * info = mpeg2_info (mpeg2dec);
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/vd_vfw.c MPlayer-1.0pre5/libmpcodecs/vd_vfw.c
--- MPlayer-1.0pre5.orig/libmpcodecs/vd_vfw.c	2002-11-07 05:54:24 +0600
+++ MPlayer-1.0pre5/libmpcodecs/vd_vfw.c	2004-08-08 09:42:07 +0700
@@ -177,7 +177,7 @@
     ret = ICDecompressGetFormat(priv->handle, sh->bih, priv->o_bih);
     if(ret < 0){
 	mp_msg(MSGT_WIN32,MSGL_ERR,"ICDecompressGetFormat failed: Error %d\n", (int)ret);
-	for (i=0; i < o_bih_len; i++) mp_msg(MSGT_WIN32, MSGL_DBG2, "%02x ", priv->o_bih[i]);
+	for (i=0; i < o_bih_len; i++) mp_msg(MSGT_WIN32, MSGL_DBG2, "%02x ", priv->o_bih[i].biSize);
 	return 0;
     }
     mp_msg(MSGT_WIN32,MSGL_V,"ICDecompressGetFormat OK\n");
diff -urN MPlayer-1.0pre5.orig/TOOLS/subfont-c/subfont.c MPlayer-1.0pre5/TOOLS/subfont-c/subfont.c
--- MPlayer-1.0pre5.orig/TOOLS/subfont-c/subfont.c	2003-07-14 04:25:22 +0700
+++ MPlayer-1.0pre5/TOOLS/subfont-c/subfont.c	2004-08-08 09:42:07 +0700
@@ -304,7 +304,7 @@
 	    glyph_index = FT_Get_Char_Index(face, uni_charmap ? character:code);
 	    if (glyph_index==0) {
 		WARNING("Glyph for char 0x%02lx|U+%04lX|%c not found.", code, character,
-			 code<' '||code>255 ? '.':code);
+			 code<' '||code>255 ? '.':(char)code);
 		continue;
 	    }
 	}
@@ -368,7 +368,7 @@
 	fprintf(f, "0x%04lx %i %i;\tU+%04lX|%c\n", unicode_desc ? character:code,
 		pen_x,						// bitmap start
 		pen_xa-1,					// bitmap end
-		character, code<' '||code>255 ? '.':code);
+		character, code<' '||code>255 ? '.':(char)code);
 #endif
 	pen_x = ALIGN(pen_xa);
     }
