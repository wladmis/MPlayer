diff -urN mplayer-svn-r26706.orig/codec-cfg.c mplayer-svn-r26706/codec-cfg.c
--- mplayer-svn-r26706.orig/codec-cfg.c	2008-04-14 00:02:39 +0300
+++ mplayer-svn-r26706/codec-cfg.c	2008-05-09 21:08:51 +0300
@@ -179,6 +179,7 @@
 		{"ZRMJPEGIT", IMGFMT_ZRMJPEGIT},
 		{"ZRMJPEGIB", IMGFMT_ZRMJPEGIB},
 
+		{"VLD_MPEG2",IMGFMT_XVMC_VLD_MPEG2},
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
diff -urN mplayer-svn-r26706.orig/configure mplayer-svn-r26706/configure
--- mplayer-svn-r26706.orig/configure	2008-05-09 17:57:36 +0300
+++ mplayer-svn-r26706/configure	2008-05-09 21:08:51 +0300
@@ -445,7 +445,8 @@
   --extra-libs-mencoder=FLAGS extra linker flags for MEncoder
   --with-extraincdir=DIR      extra header search paths in DIR (*)
   --with-extralibdir=DIR      extra linker search paths in DIR (*)
-  --with-xvmclib=NAME         adapter-specific library name (e.g. XvMCNVIDIA)
+  --with-xvmclib=NAME         adapter-specific library name
+                              (e.g. XvMCNVIDIA/I810XvMC/viaXvMC/viaXvMCPro)
 
   --with-freetype-config=PATH path to freetype-config
   --with-fribidi-config=PATH  path to fribidi-config
@@ -3980,34 +3981,98 @@
 echores "$_xv"
 
 
-echocheck "XvMC"
-if test "$_xv" = yes && test "$_xvmc" != no ; then
-  _xvmc=no
-  cat > $TMPC <<EOF
-#include <X11/Xlib.h>
+xvmc_check()
+{
+  if test "$_xvmcvld" = yes; then
+    _xvmcinc="vldXvMC.h"
+  else
+    _xvmcinc="XvMClib.h"
+  fi
+
+  echo "#include <X11/Xlib.h>
 #include <X11/extensions/Xvlib.h>
-#include <X11/extensions/XvMClib.h>
+#include <X11/extensions/$_xvmcinc>
 int main(void) {
   (void) XvMCQueryExtension(0,0,0);
   (void) XvMCCreateContext(0,0,0,0,0,0,0);
-  return 0; }
-EOF
-  for _ld_tmp in $_xvmclib XvMCNVIDIA XvMCW I810XvMC ; do
-    cc_check -lXvMC -l$_ld_tmp && _xvmc=yes && _xvmclib="$_ld_tmp" && break
-  done
-fi
-if test "$_xvmc" = yes ; then
-  _def_xvmc='#define HAVE_XVMC 1'
-  _libs_mplayer="$_libs_mplayer -lXvMC -l$_xvmclib"
-  _vosrc="$_vosrc vo_xvmc.c"
-  _vomodules="xvmc $_vomodules"
-  _res_comment="using $_xvmclib"
-else
-  _def_xvmc='#undef HAVE_XVMC'
-  _novomodules="xvmc $_novomodules"
-  _libavdecoders=`echo $_libavdecoders | sed -e s/MPEG_XVMC_DECODER// `
+  return 0; }" > $TMPC
+
+  _success=0
+  cc_check $_inc_x11 -lXvMC -l$_xvmclib $_ld_xv $_ld_x11 && _success=1
+  return $_ok
+}
+ 
+# Note: here we try to determine what xvmc capability is available
+# if the xvmc wrapper is available then we link to that, also we
+# check whether we can include the vld (slice) level xvmc include file
+if test "$_x11" = yes && test "$_xv" = yes && test "$_xvmc" != no ; then
+  _xvmc=no
+ 
+# No explicit xvmc lib specified so try and find one
+  if test "$_xvmclib" = ""; then
+# Try with the xvmc wrapper+vld first
+    echocheck "XvMC (Wrapper+vld)"
+    _xvmclib="XvMCW"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+# Try with the xvmc wrapper
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (Wrapper)"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+
+# Try with the nvidia lib
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (NVIDIA)"
+      _xvmclib="XvMCNVIDIA"
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+
+# Try with the i810 lib
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (i810)"
+      _xvmclib="I810XvMC"
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  else
+# check for specified xvmc lib
+    echocheck "XvMC vld+("$_xvmclib")"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC ("$_xvmclib")"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  fi
+
+  if test "$_xvmc" = yes ; then
+    _def_xvmc='#define HAVE_XVMC 1'
+    _libs_mplayer="$_libs_mplayer -lXvMC -l$_xvmclib"
+    _libs_mencoder="$_libs_mplayer -l$_xvmclib"
+    _vosrc="$_vosrc vo_xvmc.c"
+    _vomodules="xvmc $_vomodules"
+  else
+    _novomodules="xvmc $_novomodules"
+    _libavdecoders=`echo $_libavdecoders | sed -e s/MPEG_XVMC_DECODER// `
+    _def_xvmc='#undef HAVE_XVMC'
+  fi
+
+  if test "$_xvmcvld" = yes; then
+    _def_xvmc_vld='#define HAVE_XVMC_VLD 1'
+  else
+    _def_xvmc_vld='#undef HAVE_XVMC_VLD'
+  fi
 fi
-echores "$_xvmc"
 
 
 echocheck "Xinerama"
@@ -8503,6 +8568,7 @@
 $_def_x11
 $_def_xv
 $_def_xvmc
+$_def_xvmc_vld
 $_def_vm
 $_def_xf86keysym
 $_def_xinerama
diff -urN mplayer-svn-r26706.orig/etc/codecs.conf mplayer-svn-r26706/etc/codecs.conf
--- mplayer-svn-r26706.orig/etc/codecs.conf	2008-05-07 03:43:55 +0300
+++ mplayer-svn-r26706/etc/codecs.conf	2008-05-09 21:08:51 +0300
@@ -144,6 +144,7 @@
   fourcc MMES,mmes   ; matrox mpeg2 in avi
   driver ffmpeg
   dll "mpegvideo_xvmc"
+  out VLD_MPEG2
   out IDCT_MPEG2
   out MOCO_MPEG2
 
diff -urN mplayer-svn-r26706.orig/help/help_mp-en.h mplayer-svn-r26706/help/help_mp-en.h
--- mplayer-svn-r26706.orig/help/help_mp-en.h	2008-05-07 03:43:54 +0300
+++ mplayer-svn-r26706/help/help_mp-en.h	2008-05-09 21:08:51 +0300
@@ -1653,6 +1653,7 @@
 #define MSGTR_MPCODECS_DRIFailure "[VD_FFMPEG] DRI failure.\n"
 #define MSGTR_MPCODECS_CouldntAllocateImageForCodec "[VD_FFMPEG] Couldn't allocate image for codec.\n"
 #define MSGTR_MPCODECS_XVMCAcceleratedMPEG2 "[VD_FFMPEG] XVMC-accelerated MPEG-2.\n"
+#define MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2 "[VD_FFMPEG] XVMC-VLD-accelerated MPEG-2.\n"
 #define MSGTR_MPCODECS_TryingPixfmt "[VD_FFMPEG] Trying pixfmt=%d.\n"
 #define MSGTR_MPCODECS_McGetBufferShouldWorkOnlyWithXVMC "[VD_FFMPEG] The mc_get_buffer should work only with XVMC acceleration!!"
 #define MSGTR_MPCODECS_UnexpectedInitVoError "[VD_FFMPEG] Unexpected init_vo error.\n"
diff -urN mplayer-svn-r26706.orig/libmpcodecs/img_format.c mplayer-svn-r26706/libmpcodecs/img_format.c
--- mplayer-svn-r26706.orig/libmpcodecs/img_format.c	2007-07-12 01:38:41 +0300
+++ mplayer-svn-r26706/libmpcodecs/img_format.c	2008-05-09 21:08:51 +0300
@@ -67,6 +67,7 @@
 	case IMGFMT_ZRMJPEGIB: return("Zoran MJPEG bottom field first");
 	case IMGFMT_XVMC_MOCO_MPEG2: return("MPEG1/2 Motion Compensation");
 	case IMGFMT_XVMC_IDCT_MPEG2: return("MPEG1/2 Motion Compensation and IDCT");
+	case IMGFMT_XVMC_VLD_MPEG2: return("MPEG1/2 Motion Compensation and VLD");
     }
     snprintf(unknow_format,20,"Unknown 0x%04x",format);
     return unknow_format;
diff -urN mplayer-svn-r26706.orig/libmpcodecs/img_format.h mplayer-svn-r26706/libmpcodecs/img_format.h
--- mplayer-svn-r26706.orig/libmpcodecs/img_format.h	2008-02-23 00:42:53 +0200
+++ mplayer-svn-r26706/libmpcodecs/img_format.h	2008-05-09 21:08:51 +0300
@@ -106,6 +106,7 @@
 //these are chroma420
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
+#define IMGFMT_XVMC_VLD_MPEG2 (IMGFMT_XVMC|0x42)
 
 typedef struct {
     void* data;
diff -urN mplayer-svn-r26706.orig/libmpcodecs/vd_ffmpeg.c mplayer-svn-r26706/libmpcodecs/vd_ffmpeg.c
--- mplayer-svn-r26706.orig/libmpcodecs/vd_ffmpeg.c	2008-04-14 00:02:35 +0300
+++ mplayer-svn-r26706/libmpcodecs/vd_ffmpeg.c	2008-05-09 21:08:51 +0300
@@ -12,6 +12,7 @@
 #include "mpbswap.h"
 
 #include "vd_internal.h"
+#include "libvo/video_out.h"
 
 static vd_info_t info = {
 	"FFmpeg's libavcodec codec family",
@@ -151,6 +152,8 @@
         case IMGFMT_XVMC_IDCT_MPEG2:
         case IMGFMT_XVMC_MOCO_MPEG2:
             if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
+        case IMGFMT_XVMC_VLD_MPEG2:
+            if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_VLD) return CONTROL_TRUE;
 #endif
 	}
         return CONTROL_FALSE;
@@ -221,6 +224,9 @@
     vd_ffmpeg_ctx *ctx;
     AVCodec *lavc_codec;
     int lowres_w=0;
+#ifdef HAVE_XVMC
+    char *voname = 0;
+#endif
     int do_vis_debug= lavc_param_vismv || (lavc_param_debug&(FF_DEBUG_VIS_MB_TYPE|FF_DEBUG_VIS_QP));
 
     if(!avcodec_initialized){
@@ -257,10 +263,11 @@
 #ifdef HAVE_XVMC
 
 #ifdef CODEC_CAP_HWACCEL
-    if(lavc_codec->capabilities & CODEC_CAP_HWACCEL){
+    if((lavc_codec->capabilities & CODEC_CAP_HWACCEL) &&
 #else
-    if(lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC){
+    if((lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC) &&
 #endif /* CODEC_CAP_HWACCEL */
+	voname && !strcmp(voname,"xvmc") ) {
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedCodec);
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
@@ -531,6 +538,7 @@
 #ifdef HAVE_XVMC
         case PIX_FMT_XVMC_MPEG2_MC:ctx->best_csp=IMGFMT_XVMC_MOCO_MPEG2;break;
         case PIX_FMT_XVMC_MPEG2_IDCT:ctx->best_csp=IMGFMT_XVMC_IDCT_MPEG2;break;
+        case PIX_FMT_XVMC_MPEG2_VLD:ctx->best_csp=IMGFMT_XVMC_VLD_MPEG2;break;
 #endif
 	default:
 	    ctx->best_csp=0;
@@ -915,7 +923,11 @@
         avctx->get_buffer= mc_get_buffer;
         avctx->release_buffer= mc_release_buffer;
         avctx->draw_horiz_band = mc_render_slice;
+        if (avctx->xvmc_acceleration != 4)
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedMPEG2);
+        else
+    	    mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2);
+
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
         avctx->flags|= CODEC_FLAG_EMU_EDGE;//do i need that??!!
diff -urN mplayer-svn-r26706.orig/libvo/vo_xvmc.c mplayer-svn-r26706/libvo/vo_xvmc.c
--- mplayer-svn-r26706.orig/libvo/vo_xvmc.c	2007-12-02 17:50:50 +0200
+++ mplayer-svn-r26706/libvo/vo_xvmc.c	2008-05-09 21:08:51 +0300
@@ -23,6 +23,14 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
+
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
+
 #include "x11_common.h"
 #include "xvmc_render.h"
 
@@ -51,6 +59,7 @@
 #error You need at least libavcodecs v51.40.2
 #endif
 
+extern unsigned int video_format; 
 
 static int benchmark;
 static int use_sleep;
@@ -59,6 +68,8 @@
 static int xv_port_request = 0;
 static int bob_deinterlace;
 static int top_field_first;
+static int use_deint_one;
+static int use_tv_clip;
 
 static int image_width,image_height;
 static int image_format;
@@ -123,7 +134,7 @@
   "XVideo Motion Compensation",
   "xvmc",
   "Ivan Kalvachev <iive@users.sf.net>",
-  ""
+  "Ivor Hewitt <ivor@ivor.org> - VIA VLD support"
 };
 
 const LIBVO_EXTERN(xvmc);
@@ -196,7 +207,23 @@
 }
 //end of vo_xv shm/xvimage code
 
+int hasVLDAcceleration()
+{
+#ifdef HAVE_XVMC_VLD
+    return XVMC_VLD == (surface_info.mc_type & XVMC_VLD);
+#else
+    return 0;
+#endif
+}            
+
 static int xvmc_check_surface_format(uint32_t format, XvMCSurfaceInfo * surf_info){
+#ifdef HAVE_XVMC_VLD
+    if (format == IMGFMT_XVMC_VLD_MPEG2 ){
+        if( surf_info->mc_type != (XVMC_VLD|XVMC_MPEG_2) ) return -1;
+        if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
+        return 0;
+    }
+#endif
    if ( format == IMGFMT_XVMC_IDCT_MPEG2 ){ 
       if( surf_info->mc_type != (XVMC_IDCT|XVMC_MPEG_2) ) return -1;
       if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
@@ -377,9 +404,16 @@
   {  "sleep",     OPT_ARG_BOOL, &use_sleep,       NULL },
   {  "queue",     OPT_ARG_BOOL, &use_queue,       NULL },
   {  "bobdeint",  OPT_ARG_BOOL, &bob_deinterlace, NULL },
+  {  "onedeint",  OPT_ARG_BOOL, &use_deint_one,   NULL },
+  {  "tv-clip",   OPT_ARG_BOOL, &use_tv_clip,     NULL },
   {  NULL }
 };
 
+   // If the video is not MPEG1 or MPEG2, we can't decode it, so
+   // fail cleanly to allow mplayer to fallback to another vo system
+   if (video_format != 0x10000001 && video_format != 0x10000002) return -1;
+
+
    //Obtain display handler
    if (!vo_init()) return -1;//vo_xv
 
@@ -415,6 +449,8 @@
    use_sleep = 0;
    use_queue = 0;
    bob_deinterlace = 0;
+   use_deint_one = 0;
+   use_tv_clip = 0;
 
    /* parse suboptions */
    if ( subopt_parse( arg, subopts ) != 0 )
@@ -505,20 +541,23 @@
    if(surface_info.chroma_format == XVMC_CHROMA_FORMAT_444)
       blocks_per_macroblock = 12;
 
-   rez = XvMCCreateBlocks(mDisplay,&ctx,numblocks*blocks_per_macroblock,&data_blocks);
-   if( rez != Success ){
-      XvMCDestroyContext(mDisplay,&ctx);
-      return -1;
-   }
-   printf("vo_xvmc: data_blocks allocated\n");
-
-   rez = XvMCCreateMacroBlocks(mDisplay,&ctx,numblocks,&mv_blocks);
-   if( rez != Success ){
-      XvMCDestroyBlocks(mDisplay,&data_blocks);
-      XvMCDestroyContext(mDisplay,&ctx);
-      return -1;
+   if (!hasVLDAcceleration())
+   {
+      rez = XvMCCreateBlocks(mDisplay,&ctx,numblocks*blocks_per_macroblock,&data_blocks);
+      if( rez != Success ){
+         XvMCDestroyContext(mDisplay,&ctx);
+         return -1;
+      }
+      printf("vo_xvmc: data_blocks allocated\n");
+
+      rez = XvMCCreateMacroBlocks(mDisplay,&ctx,numblocks,&mv_blocks);
+      if( rez != Success ){
+         XvMCDestroyBlocks(mDisplay,&data_blocks);
+         XvMCDestroyContext(mDisplay,&ctx);
+         return -1;
+      }
+      printf("vo_xvmc: mv_blocks allocated\n");
    }
-   printf("vo_xvmc: mv_blocks allocated\n");
 
    if(surface_render==NULL)
       surface_render=malloc(MAX_SURFACES*sizeof(xvmc_render_state_t));//easy mem debug
@@ -538,6 +577,11 @@
       surface_render[i].chroma_format = surface_info.chroma_format;
       surface_render[i].unsigned_intra = (surface_info.flags & XVMC_INTRA_UNSIGNED) == XVMC_INTRA_UNSIGNED;
       surface_render[i].p_surface = &surface_array[i];
+
+      surface_render[i].state = 0;
+      surface_render[i].disp = mDisplay;
+      surface_render[i].ctx = &ctx;
+
       if( mp_msg_test(MSGT_VO,MSGL_DBG4) )
           printf("vo_xvmc: surface[%d] = %p .rndr=%p\n",i,&surface_array[i], &surface_render[i]);
    }
@@ -614,8 +658,7 @@
          printf("vo_xvmc: OSD support by additional frontend rendering\n");
          break;
       case BACKEND_SUBPICTURE:
-         printf("vo_xvmc: OSD support by backend rendering (fast)\n");
-         printf("vo_xvmc: Please send feedback to confirm that it works,otherwise send bugreport!\n");
+	 printf("vo_xvmc: OSD support by backend rendering (fast, but untested with mplayer.)\n");
          break;
    }
 
@@ -993,6 +1036,8 @@
 int rez;
 int clipX,clipY,clipW,clipH;
 int i;
+ int srcY=0, srcH=image_height;
+ int fieldnobob;
 
    if(p_render_surface == NULL)
       return;
@@ -1002,22 +1047,38 @@
    clipW = vo_dwidth+vo_panscan_x;
    clipH = vo_dheight+vo_panscan_y;
    
+   if (use_tv_clip) {
+     /*
+      * Clip top few lines off to get rid of annoying flicker
+      * when using bob de-interlacing on TV sourced video.
+      */
+     srcY+=4;
+     srcH-=4;
+   }
+   
    if(draw_ck)
       vo_xv_draw_colorkey(clipX,clipY,clipW,clipH);
 
    if(benchmark)
       return;
 
+   fieldnobob = XVMC_FRAME_PICTURE;
+
+   if (use_deint_one) 
+     fieldnobob = (top_field_first) ? XVMC_TOP_FIELD : XVMC_BOTTOM_FIELD;
+
    for (i = 1; i <= bob_deinterlace + 1; i++) {
-   int field = top_field_first ? i : i ^ 3;
+     int field = top_field_first ? i : i ^ XVMC_FRAME_PICTURE;
    rez = XvMCPutSurface(mDisplay, p_render_surface->p_surface, 
                         vo_window,
-                        0, 0, image_width, image_height,
+			  0, srcY, image_width, srcH,
                         clipX, clipY, clipW, clipH,
-                        bob_deinterlace ? field : 3);
-                        //p_render_surface_to_show->display_flags);
+			  bob_deinterlace ? field : fieldnobob);
+     if (i == 1 && bob_deinterlace) {
+       usleep(10*1000);
+     }
    if(rez != Success){
-      printf("vo_xvmc: PutSurface failer, critical error %d!\n",rez);
+       printf("vo_xvmc: PutSurface failure, critical error %d!\n",rez);
       assert(0);
    }
    }
@@ -1109,9 +1170,11 @@
 
    if( number_of_surfaces ){
 
+      if (!hasVLDAcceleration())
+      {
       XvMCDestroyMacroBlocks(mDisplay,&mv_blocks);
       XvMCDestroyBlocks(mDisplay,&data_blocks);
-
+      }
       for(i=0; i<number_of_surfaces; i++)
       {
          XvMCHideSurface(mDisplay,&surface_array[i]);//it doesn't hurt, I hope
@@ -1145,7 +1208,13 @@
 static void uninit(void){
    if( mp_msg_test(MSGT_VO,MSGL_DBG4) ) {
       printf("vo_xvmc: uninit called\n"); }
-   xvmc_free();
+   //
+   // This function can be called as part of a signal handler, and
+   // calling xvmc_free() thus may result in a deadlock.
+   // Don't do it this way. 
+   // The xvmc subsystem should take care of this anyway.
+   //
+   // xvmc_free();
  //from vo_xv
 #ifdef HAVE_XF86VM
    vo_vm_close(mDisplay);
@@ -1189,6 +1258,17 @@
    assert( rndr != NULL );
    assert( rndr->magic == MP_XVMC_RENDER_MAGIC );
 
+   if (hasVLDAcceleration())
+   {
+        rez = XvMCPutSlice2(mDisplay,&ctx,(char*)rndr->slice_data,
+                            rndr->slice_datalen,
+                            rndr->slice_code);
+        if (rez)
+           printf("vo_xxmc::slice Error %d\n",rez);
+
+   }
+   else
+   {
    rez = XvMCRenderSurface(mDisplay,&ctx,rndr->picture_structure,
              		   rndr->p_surface,
                            rndr->p_past_surface,
@@ -1200,7 +1280,7 @@
    if(rez != Success)
    {
    int i;
-      printf("vo_xvmc::slice: RenderSirface returned %d\n",rez);
+      printf("vo_xvmc::slice: RenderSurface returned %d\n",rez);
 
       printf("vo_xvmc::slice: pict=%d,flags=%x,start_blocks=%d,num_blocks=%d\n",
              rndr->picture_structure,rndr->flags,rndr->start_mv_blocks_num,
@@ -1228,6 +1308,7 @@
    rez = XvMCFlushSurface(mDisplay, rndr->p_surface);
    assert(rez==Success);
 
+}
 //   rndr->start_mv_blocks_num += rndr->filled_mv_blocks_num;
    rndr->start_mv_blocks_num = 0;
    rndr->filled_mv_blocks_num = 0;
@@ -1337,8 +1418,16 @@
 
 // these are shared!! so watch out
 // do call RenderSurface before overwriting
+if (!hasVLDAcceleration())
+{
    mpi->planes[0] = (char*)data_blocks.blocks;   
    mpi->planes[1] = (char*)mv_blocks.macro_blocks;
+}
+else
+{
+   mpi->planes[0] = 1;
+   mpi->planes[1] = 0;
+}
    mpi->priv =
    mpi->planes[2] = (char*)rndr;
 
diff -urN mplayer-svn-r26706.orig/Makefile mplayer-svn-r26706/Makefile
--- mplayer-svn-r26706.orig/Makefile	2008-05-09 17:57:36 +0300
+++ mplayer-svn-r26706/Makefile	2008-05-09 21:08:51 +0300
@@ -739,6 +739,9 @@
 	@echo '// untranslated messages from the English master file:' >> help_mp.h
 	@help/help_diff.sh $(HELP_FILE) < help/help_mp-en.h >> help_mp.h
 endif
+ifeq ($(HAVE_XVMC_ACCEL),yes)
+CODEC_LIBS += $(X_LIB)
+endif
 
 define RECURSIVE_RULE
 $(part)/$(part).a: recurse
diff -urN mplayer-svn-r26706.orig/mplayer.c mplayer-svn-r26706/mplayer.c
--- mplayer-svn-r26706.orig/mplayer.c	2008-05-07 03:43:55 +0300
+++ mplayer-svn-r26706/mplayer.c	2008-05-09 21:08:51 +0300
@@ -87,6 +87,8 @@
 int quiet=0;
 int enable_mouse_movements=0;
 
+unsigned int video_format=0;
+
 #ifdef WIN32
 char * proc_priority=NULL;
 #endif
@@ -2144,6 +2146,11 @@
 
     //shouldn't we set dvideo->id=-2 when we fail?
     vo_config_count=0;
+  
+    // let the video driver know what format the video is in so it can
+    // reject it if it wants - lets vo_xvmc fail if ffmpeg12mc codec not used
+    video_format=sh_video->format; 
+
     //if((mpctx->video_out->preinit(vo_subdevice))!=0){
     if(!(mpctx->video_out=init_best_video_out(video_driver_list))){
       mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_ErrorInitializingVODevice);
diff -urN mplayer-svn-r26706.orig/xvmc_render.h mplayer-svn-r26706/xvmc_render.h
--- mplayer-svn-r26706.orig/xvmc_render.h	2008-02-23 00:42:57 +0200
+++ mplayer-svn-r26706/xvmc_render.h	2008-05-09 21:08:51 +0300
@@ -8,6 +8,9 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
 
 //the surface should be shown, video driver manipulates this
 #define MP_XVMC_STATE_DISPLAY_PENDING 1
@@ -30,8 +33,19 @@
   int idct;//Do we use IDCT acceleration?
   int chroma_format;//420,422,444
   int unsigned_intra;//+-128 for intra pictures after clip
+#ifdef HAVE_XVMC_VLD
+  int reserved1[3];
+  // These are for the XVMC VLD slice interface
+  int pict_type; //this is for skipping frames
+  int   slice_code; 
+  int   slice_datalen;
+  unsigned char *slice_data;
+  Display *disp;
+  XvMCContext *ctx;
+#endif
   XvMCSurface* p_surface;//pointer to rendered surface, never changed
 
+
 //these are changed by decoder
 //used by XvMCRenderSurface function
   XvMCSurface* p_past_surface;//pointer to the past surface
