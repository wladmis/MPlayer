diff -urN MPlayer-1.0pre5.orig/libaf/af_resample.c MPlayer-1.0pre5/libaf/af_resample.c
--- MPlayer-1.0pre5.orig/libaf/af_resample.c	2003-01-12 14:05:51 +0600
+++ MPlayer-1.0pre5/libaf/af_resample.c	2004-08-08 10:36:04 +0700
@@ -199,7 +199,7 @@
     if((s->setup & RSMP_MASK) == RSMP_LIN){
       s->pt=0LL;
       s->step=((uint64_t)n->rate<<STEPACCURACY)/(uint64_t)af->data->rate+1LL;
-      af_msg(AF_MSG_DEBUG0,"[resample] Linear interpolation step: 0x%016X.\n",
+      af_msg(AF_MSG_DEBUG0,"[resample] Linear interpolation step: 0x%016llX.\n",
 	     s->step);
       af->mul.n = af->data->rate;
       af->mul.d = n->rate;
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/ad_faad.c MPlayer-1.0pre5/libmpcodecs/ad_faad.c
--- MPlayer-1.0pre5.orig/libmpcodecs/ad_faad.c	2004-05-15 01:47:17 +0700
+++ MPlayer-1.0pre5/libmpcodecs/ad_faad.c	2004-08-08 10:36:04 +0700
@@ -120,7 +120,7 @@
     return 0;
   } else {
     mp_msg(MSGT_DECAUDIO,MSGL_V,"FAAD: Decoder init done (%dBytes)!\n", sh->a_in_buffer_len); // XXX: remove or move to debug!
-    mp_msg(MSGT_DECAUDIO,MSGL_V,"FAAD: Negotiated samplerate: %dHz  channels: %d\n", faac_samplerate, faac_channels);
+    mp_msg(MSGT_DECAUDIO,MSGL_V,"FAAD: Negotiated samplerate: %ldHz  channels: %d\n", faac_samplerate, faac_channels);
     sh->channels = faac_channels;
     sh->samplerate = faac_samplerate;
     //sh->o_bps = sh->samplesize*faac_channels*faac_samplerate;
@@ -218,7 +218,7 @@
       mp_msg(MSGT_DECAUDIO,MSGL_DBG2,"FAAD: Decoded zero samples!\n");
     } else {
       /* XXX: samples already multiplied by channels! */
-      mp_msg(MSGT_DECAUDIO,MSGL_DBG2,"FAAD: Successfully decoded frame (%d Bytes)!\n",
+      mp_msg(MSGT_DECAUDIO,MSGL_DBG2,"FAAD: Successfully decoded frame (%ld Bytes)!\n",
       sh->samplesize*faac_finfo.samples);
       memcpy(buf+len,faac_sample_buffer, sh->samplesize*faac_finfo.samples);
       len += sh->samplesize*faac_finfo.samples;
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/ad_faad.c.orig MPlayer-1.0pre5/libmpcodecs/ad_faad.c.orig
--- MPlayer-1.0pre5.orig/libmpcodecs/ad_faad.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpcodecs/ad_faad.c.orig	2004-05-15 01:47:17 +0700
@@ -0,0 +1,232 @@
+/* ad_faad.c - MPlayer AAC decoder using libfaad2
+ * This file is part of MPlayer, see http://mplayerhq.hu/ for info.  
+ * (c)2002 by Felix Buenemann <atmosfear at users.sourceforge.net>
+ * File licensed under the GPL, see http://www.fsf.org/ for more info.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "ad_internal.h"
+
+#ifdef HAVE_FAAD
+
+static ad_info_t info = 
+{
+	"AAC (MPEG2/4 Advanced Audio Coding)",
+	"faad",
+	"Felix Buenemann",
+	"faad2",
+	"uses libfaad2"
+};
+
+LIBAD_EXTERN(faad)
+
+#ifndef USE_INTERNAL_FAAD
+#include <faad.h>
+#else
+#include "../libfaad2/faad.h"
+#endif
+
+/* configure maximum supported channels, *
+ * this is theoretically max. 64 chans   */
+#define FAAD_MAX_CHANNELS 6
+#define FAAD_BUFFLEN (FAAD_MIN_STREAMSIZE*FAAD_MAX_CHANNELS)		       
+
+//#define AAC_DUMP_COMPRESSED  
+
+static faacDecHandle faac_hdec;
+static faacDecFrameInfo faac_finfo;
+
+static int preinit(sh_audio_t *sh)
+{
+  sh->audio_out_minsize=8192*FAAD_MAX_CHANNELS;
+  sh->audio_in_minsize=FAAD_BUFFLEN;
+  return 1;
+}
+
+static int init(sh_audio_t *sh)
+{
+  unsigned long faac_samplerate;
+  unsigned char faac_channels;
+  int faac_init;
+  faac_hdec = faacDecOpen();
+
+  // If we don't get the ES descriptor, try manual config
+  if(!sh->codecdata_len && sh->wf) {
+    sh->codecdata_len = sh->wf->cbSize;
+    sh->codecdata = (char*)(sh->wf+1);
+    mp_msg(MSGT_DECAUDIO,MSGL_DBG2,"FAAD: codecdata extracted from WAVEFORMATEX\n");
+  }
+  if(!sh->codecdata_len) {
+#if 1
+    faacDecConfigurationPtr faac_conf;
+    /* Set the default object type and samplerate */
+    /* This is useful for RAW AAC files */
+    faac_conf = faacDecGetCurrentConfiguration(faac_hdec);
+    if(sh->samplerate)
+      faac_conf->defSampleRate = sh->samplerate;
+    /* XXX: FAAD support FLOAT output, how do we handle
+      * that (FAAD_FMT_FLOAT)? ::atmos
+      */
+    if(sh->samplesize)
+      switch(sh->samplesize){
+	case 1: // 8Bit
+	  mp_msg(MSGT_DECAUDIO,MSGL_WARN,"FAAD: 8Bit samplesize not supported by FAAD, assuming 16Bit!\n");
+	default:
+	case 2: // 16Bit
+	  faac_conf->outputFormat = FAAD_FMT_16BIT;
+	  break;
+	case 3: // 24Bit
+	  faac_conf->outputFormat = FAAD_FMT_24BIT;
+	  break;
+	case 4: // 32Bit
+	  faac_conf->outputFormat = FAAD_FMT_32BIT;
+	  break;
+      }
+    //faac_conf->defObjectType = LTP; // => MAIN, LC, SSR, LTP available.
+
+    faacDecSetConfiguration(faac_hdec, faac_conf);
+#endif
+
+    sh->a_in_buffer_len = demux_read_data(sh->ds, sh->a_in_buffer, sh->a_in_buffer_size);
+
+    /* init the codec */
+#if (FAADVERSION <= 11)
+    faac_init = faacDecInit(faac_hdec, sh->a_in_buffer,
+       &faac_samplerate, &faac_channels);
+#else
+    faac_init = faacDecInit(faac_hdec, sh->a_in_buffer,
+       sh->a_in_buffer_len, &faac_samplerate, &faac_channels);
+#endif
+
+    sh->a_in_buffer_len -= (faac_init > 0)?faac_init:0; // how many bytes init consumed
+    // XXX FIXME: shouldn't we memcpy() here in a_in_buffer ?? --A'rpi
+
+  } else { // We have ES DS in codecdata
+    /*int i;
+    for(i = 0; i < sh_audio->codecdata_len; i++)
+      printf("codecdata_dump %d: 0x%02X\n", i, sh_audio->codecdata[i]);*/
+
+    faac_init = faacDecInit2(faac_hdec, sh->codecdata,
+       sh->codecdata_len,	&faac_samplerate, &faac_channels);
+  }
+  if(faac_init < 0) {
+    mp_msg(MSGT_DECAUDIO,MSGL_WARN,"FAAD: Failed to initialize the decoder!\n"); // XXX: deal with cleanup!
+    faacDecClose(faac_hdec);
+    // XXX: free a_in_buffer here or in uninit?
+    return 0;
+  } else {
+    mp_msg(MSGT_DECAUDIO,MSGL_V,"FAAD: Decoder init done (%dBytes)!\n", sh->a_in_buffer_len); // XXX: remove or move to debug!
+    mp_msg(MSGT_DECAUDIO,MSGL_V,"FAAD: Negotiated samplerate: %dHz  channels: %d\n", faac_samplerate, faac_channels);
+    sh->channels = faac_channels;
+    sh->samplerate = faac_samplerate;
+    //sh->o_bps = sh->samplesize*faac_channels*faac_samplerate;
+    if(!sh->i_bps) {
+      mp_msg(MSGT_DECAUDIO,MSGL_WARN,"FAAD: compressed input bitrate missing, assuming 128kbit/s!\n");
+      sh->i_bps = 128*1000/8; // XXX: HACK!!! ::atmos
+    } else 
+      mp_msg(MSGT_DECAUDIO,MSGL_V,"FAAD: got %dkbit/s bitrate from MP4 header!\n",sh->i_bps*8/1000);
+  }  
+  return 1;
+}
+
+static void uninit(sh_audio_t *sh)
+{
+  mp_msg(MSGT_DECAUDIO,MSGL_V,"FAAD: Closing decoder!\n");
+  faacDecClose(faac_hdec);
+}
+
+static int control(sh_audio_t *sh,int cmd,void* arg, ...)
+{
+    switch(cmd)
+    {
+#if 0      
+      case ADCTRL_RESYNC_STREAM:
+	  return CONTROL_TRUE;
+      case ADCTRL_SKIP_FRAME:
+	  return CONTROL_TRUE;
+#endif
+    }
+  return CONTROL_UNKNOWN;
+}
+
+static int decode_audio(sh_audio_t *sh,unsigned char *buf,int minlen,int maxlen)
+{
+  int j = 0, len = 0;	      
+  void *faac_sample_buffer;
+
+  while(len < minlen) {
+
+    /* update buffer for raw aac streams: */
+  if(!sh->codecdata_len)
+    if(sh->a_in_buffer_len < sh->a_in_buffer_size){
+      sh->a_in_buffer_len +=
+	demux_read_data(sh->ds,&sh->a_in_buffer[sh->a_in_buffer_len],
+	sh->a_in_buffer_size - sh->a_in_buffer_len);
+    }
+	  
+#ifdef DUMP_AAC_COMPRESSED
+    {int i;
+    for (i = 0; i < 16; i++)
+      printf ("%02X ", sh->a_in_buffer[i]);
+    printf ("\n");}
+#endif
+
+  if(!sh->codecdata_len){
+   // raw aac stream:
+   do {
+#if (FAADVERSION <= 11)
+    faac_sample_buffer = faacDecDecode(faac_hdec, &faac_finfo, sh->a_in_buffer+j);
+#else
+    faac_sample_buffer = faacDecDecode(faac_hdec, &faac_finfo, sh->a_in_buffer+j, sh->a_in_buffer_len);
+#endif
+	
+    /* update buffer index after faacDecDecode */
+    if(faac_finfo.bytesconsumed >= sh->a_in_buffer_len) {
+      sh->a_in_buffer_len=0;
+    } else {
+      sh->a_in_buffer_len-=faac_finfo.bytesconsumed;
+      memcpy(sh->a_in_buffer,&sh->a_in_buffer[faac_finfo.bytesconsumed],sh->a_in_buffer_len);
+    }
+
+    if(faac_finfo.error > 0) {
+      mp_msg(MSGT_DECAUDIO,MSGL_WARN,"FAAD: Trying to resync!\n");
+      j++;
+    } else
+      break;
+   } while(j < FAAD_BUFFLEN);	  
+  } else {
+   // packetized (.mp4) aac stream:
+    unsigned char* bufptr=NULL;
+    int buflen=ds_get_packet(sh->ds, &bufptr);
+    if(buflen<=0) break;
+#if (FAADVERSION <= 11)
+    faac_sample_buffer = faacDecDecode(faac_hdec, &faac_finfo, bufptr);
+#else
+    faac_sample_buffer = faacDecDecode(faac_hdec, &faac_finfo, bufptr, buflen);
+#endif
+//    printf("FAAC decoded %d of %d  (err: %d)  \n",faac_finfo.bytesconsumed,buflen,faac_finfo.error);
+  }
+  
+    if(faac_finfo.error > 0) {
+      mp_msg(MSGT_DECAUDIO,MSGL_WARN,"FAAD: Failed to decode frame: %s \n",
+      faacDecGetErrorMessage(faac_finfo.error));
+    } else if (faac_finfo.samples == 0) {
+      mp_msg(MSGT_DECAUDIO,MSGL_DBG2,"FAAD: Decoded zero samples!\n");
+    } else {
+      /* XXX: samples already multiplied by channels! */
+      mp_msg(MSGT_DECAUDIO,MSGL_DBG2,"FAAD: Successfully decoded frame (%d Bytes)!\n",
+      sh->samplesize*faac_finfo.samples);
+      memcpy(buf+len,faac_sample_buffer, sh->samplesize*faac_finfo.samples);
+      len += sh->samplesize*faac_finfo.samples;
+    //printf("FAAD: buffer: %d bytes  consumed: %d \n", k, faac_finfo.bytesconsumed);
+    }
+  }
+  return len;
+}
+
+#endif /* !HAVE_FAAD */
+
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/ad_realaud.c MPlayer-1.0pre5/libmpcodecs/ad_realaud.c
--- MPlayer-1.0pre5.orig/libmpcodecs/ad_realaud.c	2004-06-24 20:53:49 +0700
+++ MPlayer-1.0pre5/libmpcodecs/ad_realaud.c	2004-08-08 10:36:04 +0700
@@ -469,7 +469,7 @@
     else
 #endif
     prop=raGetFlavorProperty(sh->context,((short*)(sh->wf+1))[2],0,&len);
-    mp_msg(MSGT_DECAUDIO,MSGL_INFO,"Audio codec: [%d] %s\n",((short*)(sh->wf+1))[2],prop);
+    mp_msg(MSGT_DECAUDIO,MSGL_INFO,"Audio codec: [%d] %s\n",((short*)(sh->wf+1))[2],(char *)prop);
 
 #ifdef USE_WIN32DLL
     if (dll_type == 1)
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/ad_realaud.c.orig MPlayer-1.0pre5/libmpcodecs/ad_realaud.c.orig
--- MPlayer-1.0pre5.orig/libmpcodecs/ad_realaud.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpcodecs/ad_realaud.c.orig	2004-06-24 20:53:49 +0700
@@ -0,0 +1,656 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "config.h"
+
+#ifdef USE_REALCODECS
+
+//#include <stddef.h>
+#ifdef HAVE_LIBDL
+#include <dlfcn.h>
+#endif
+#include "help_mp.h"
+
+#include "ad_internal.h"
+#include "wine/windef.h"
+
+#ifdef USE_MACSHLB
+#include <CoreServices/CoreServices.h>
+#endif
+
+static ad_info_t info =  {
+	"RealAudio decoder",
+	"realaud",
+	"Alex Beregszaszi",
+	"Florian Schneider, Arpad Gereoffy, Alex Beregszaszi, Donnie Smith",
+	"binary real audio codecs"
+};
+
+LIBAD_EXTERN(realaud)
+
+void *__builtin_new(unsigned long size) {
+	return malloc(size);
+}
+
+// required for cook's uninit:
+void __builtin_delete(void* ize) {
+	free(ize);
+}
+
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+void *__ctype_b=NULL;
+#endif
+
+static unsigned long (*raCloseCodec)(void*);
+static unsigned long (*raDecode)(void*, char*,unsigned long,char*,unsigned int*,long);
+static unsigned long (*raFlush)(unsigned long,unsigned long,unsigned long);
+static unsigned long (*raFreeDecoder)(void*);
+static void*         (*raGetFlavorProperty)(void*,unsigned long,unsigned long,int*);
+//static unsigned long (*raGetNumberOfFlavors2)(void);
+static unsigned long (*raInitDecoder)(void*, void*);
+static unsigned long (*raOpenCodec)(void*);
+static unsigned long (*raOpenCodec2)(void*, void*);
+static unsigned long (*raSetFlavor)(void*,unsigned long);
+static void  (*raSetDLLAccessPath)(char*);
+static void  (*raSetPwd)(char*,char*);
+#ifdef USE_WIN32DLL
+static unsigned long WINAPI (*wraCloseCodec)(void*);
+static unsigned long WINAPI (*wraDecode)(void*, char*,unsigned long,char*,unsigned int*,long);
+static unsigned long WINAPI (*wraFlush)(unsigned long,unsigned long,unsigned long);
+static unsigned long WINAPI (*wraFreeDecoder)(void*);
+static void*         WINAPI (*wraGetFlavorProperty)(void*,unsigned long,unsigned long,int*);
+static unsigned long WINAPI (*wraInitDecoder)(void*, void*);
+static unsigned long WINAPI (*wraOpenCodec)(void*);
+static unsigned long WINAPI (*wraOpenCodec2)(void*, void*);
+static unsigned long WINAPI (*wraSetFlavor)(void*,unsigned long);
+static void          WINAPI (*wraSetDLLAccessPath)(char*);
+static void          WINAPI (*wraSetPwd)(char*,char*);
+
+static int dll_type = 0; /* 0 = unix dlopen, 1 = win32 dll */
+#endif
+
+static void *rv_handle = NULL;
+
+#if 0
+typedef struct {
+    int samplerate;
+    short bits;
+    short channels;
+    int unk1;
+    int unk2;
+    int packetsize;
+    int unk3;
+    void* unk4;
+} ra_init_t ;
+#else
+
+/*
+ Probably the linux .so-s were compiled with old GCC without setting
+ packing, so it adds 2 bytes padding after the quality field.
+ In windows it seems that there's no padding in it.
+ 
+ -- alex
+*/
+
+/* linux dlls doesn't need packing */
+typedef struct /*__attribute__((__packed__))*/ {
+    int samplerate;
+    short bits;
+    short channels;
+    short quality;
+    /* 2bytes padding here, by gcc */
+    int bits_per_frame;
+    int packetsize;
+    int extradata_len;
+    void* extradata;
+} ra_init_t;
+
+/* windows dlls need packed structs (no padding) */
+typedef struct __attribute__((__packed__)) {
+    int samplerate;
+    short bits;
+    short channels;
+    short quality;
+    int bits_per_frame;
+    int packetsize;
+    int extradata_len;
+    void* extradata;
+} wra_init_t;
+#endif
+
+#ifdef HAVE_LIBDL
+static int load_syms_linux(char *path)
+{
+    void *handle;
+
+    mp_msg(MSGT_DECVIDEO, MSGL_INFO, "opening shared obj '%s'\n", path);
+    handle = dlopen(path, RTLD_LAZY);
+    if (!handle)
+    {
+	mp_msg(MSGT_DECVIDEO, MSGL_WARN, "Error: %s\n", dlerror());
+	return 0;
+    }
+
+    raCloseCodec = dlsym(handle, "RACloseCodec");
+    raDecode = dlsym(handle, "RADecode");
+    raFlush = dlsym(handle, "RAFlush");
+    raFreeDecoder = dlsym(handle, "RAFreeDecoder");
+    raGetFlavorProperty = dlsym(handle, "RAGetFlavorProperty");
+    raOpenCodec = dlsym(handle, "RAOpenCodec");
+    raOpenCodec2 = dlsym(handle, "RAOpenCodec2");
+    raInitDecoder = dlsym(handle, "RAInitDecoder");
+    raSetFlavor = dlsym(handle, "RASetFlavor");
+    raSetDLLAccessPath = dlsym(handle, "SetDLLAccessPath");
+    raSetPwd = dlsym(handle, "RASetPwd"); // optional, used by SIPR
+    
+    if (raCloseCodec && raDecode && /*raFlush && */raFreeDecoder &&
+	raGetFlavorProperty && (raOpenCodec||raOpenCodec2) && raSetFlavor &&
+	/*raSetDLLAccessPath &&*/ raInitDecoder)
+    {
+	rv_handle = handle;
+	return 1;
+    }
+    
+    mp_msg(MSGT_DECAUDIO,MSGL_WARN,"Cannot resolve symbols - incompatible dll: %s\n",path);
+    dlclose(handle);
+    return 0;
+}
+#endif    
+
+#ifdef USE_WIN32DLL
+
+#ifdef WIN32_LOADER
+#include "../loader/ldt_keeper.h"
+#endif
+void* WINAPI LoadLibraryA(char* name);
+void* WINAPI GetProcAddress(void* handle,char *func);
+int WINAPI FreeLibrary(void *handle);
+
+static int load_syms_windows(char *path)
+{
+    void *handle;
+    
+    mp_msg(MSGT_DECVIDEO, MSGL_INFO, "opening win32 dll '%s'\n", path);
+#ifdef WIN32_LOADER
+    Setup_LDT_Keeper();
+#endif
+    handle = LoadLibraryA(path);
+    if (!handle)
+    {
+	mp_msg(MSGT_DECVIDEO, MSGL_WARN, "Error loading dll\n");
+	return 0;
+    }
+
+    wraCloseCodec = GetProcAddress(handle, "RACloseCodec");
+    wraDecode = GetProcAddress(handle, "RADecode");
+    wraFlush = GetProcAddress(handle, "RAFlush");
+    wraFreeDecoder = GetProcAddress(handle, "RAFreeDecoder");
+    wraGetFlavorProperty = GetProcAddress(handle, "RAGetFlavorProperty");
+    wraOpenCodec = GetProcAddress(handle, "RAOpenCodec");
+    wraOpenCodec2 = GetProcAddress(handle, "RAOpenCodec2");
+    wraInitDecoder = GetProcAddress(handle, "RAInitDecoder");
+    wraSetFlavor = GetProcAddress(handle, "RASetFlavor");
+    wraSetDLLAccessPath = GetProcAddress(handle, "SetDLLAccessPath");
+    wraSetPwd = GetProcAddress(handle, "RASetPwd"); // optional, used by SIPR
+    
+    if (wraCloseCodec && wraDecode && /*wraFlush && */wraFreeDecoder &&
+	wraGetFlavorProperty && (wraOpenCodec || wraOpenCodec2) && wraSetFlavor &&
+	/*wraSetDLLAccessPath &&*/ wraInitDecoder)
+    {
+	rv_handle = handle;
+	dll_type = 1;
+	return 1;
+    }
+    
+    mp_msg(MSGT_DECAUDIO,MSGL_WARN,"Cannot resolve symbols - incompatible dll: %s\n",path);
+    FreeLibrary(handle);
+    return 0;
+    
+}
+#endif
+
+
+#ifdef USE_MACSHLB
+/*
+ Helper function to create a function pointer (from a null terminated (!)
+ pascal string) like GetProcAddress(). Some assembler is required due
+ to different calling conventions, for further details, see 
+ http://developer.apple.com/ samplecode/CFM_MachO_CFM/listing1.html .
+
+ Caller is expected to DisposePtr(mfp).
+ N.B.: Code is used by vd_realaud.c as well.
+*/
+void *load_one_sym_mac(char *symbolName, CFragConnectionID *connID) {
+    OSErr err;
+    Ptr symbolAddr;
+    CFragSymbolClass symbolClass;
+    UInt32  *mfp;
+    char realname[255];
+    
+    if (strlen(symbolName) > 255)
+    {
+	mp_msg(MSGT_DECVIDEO, MSGL_V, "FindSymbol symbolname overflow\n");
+	return NULL;
+    }
+    
+    snprintf(realname, 255, "%c%s", strlen(symbolName), symbolName);
+
+    if ( (err = FindSymbol( *connID, realname, 
+                            &symbolAddr, &symbolClass )) != noErr ) {
+        mp_msg(MSGT_DECVIDEO,MSGL_V,"FindSymbol( \"%s\" ) failed with error code %d.\n", symbolName + 1, err );
+        return NULL;
+    }
+
+    if ( (mfp = (UInt32 *)NewPtr( 6 * sizeof(UInt32) )) == nil )
+        return NULL;
+
+    mfp[0] = 0x3D800000 | ((UInt32)symbolAddr >> 16);
+    mfp[1] = 0x618C0000 | ((UInt32)symbolAddr & 0xFFFF);
+    mfp[2] = 0x800C0000;
+    mfp[3] = 0x804C0004;
+    mfp[4] = 0x7C0903A6;
+    mfp[5] = 0x4E800420;
+    MakeDataExecutable( mfp, 6 * sizeof(UInt32) );
+
+    return( mfp );
+}
+
+static int load_syms_mac(char *path)
+{
+    Ptr mainAddr;
+    OSStatus status;
+    FSRef fsref;
+    FSSpec fsspec;
+    OSErr err;
+    Str255 errMessage;
+    CFragConnectionID *connID;
+
+    mp_msg(MSGT_DECVIDEO, MSGL_INFO, "opening mac shlb '%s'\n", path);
+
+    if ( (connID = (CFragConnectionID *)NewPtr( sizeof( CFragConnectionID ))) == nil ) {
+        mp_msg(MSGT_DECVIDEO,MSGL_WARN,"NewPtr() failed.\n" );
+        return 0;
+    }
+
+    if ( (status = FSPathMakeRef( path, &fsref, NULL )) != noErr ) {
+        mp_msg(MSGT_DECVIDEO,MSGL_WARN,"FSPathMakeRef() failed with error %d.\n", status );
+        return 0;
+    }
+
+    if ( (status = FSGetCatalogInfo( &fsref, kFSCatInfoNone, NULL, NULL, &fsspec, NULL )) != noErr ) {
+        mp_msg(MSGT_DECVIDEO,MSGL_WARN,"FSGetCatalogInfo() failed with error %d.\n", status );
+        return 0;
+    }
+
+    if ( (err = GetDiskFragment( &fsspec, 0, kCFragGoesToEOF, NULL, kPrivateCFragCopy, connID, &mainAddr, errMessage )) != noErr ) {
+
+        p2cstrcpy( errMessage, errMessage );
+        mp_msg(MSGT_DECVIDEO,MSGL_WARN,"GetDiskFragment() failed with error %d: %s\n", err, errMessage );
+        return 0;
+    }
+
+    raCloseCodec = load_one_sym_mac( "RACloseCodec", connID);
+    raDecode = load_one_sym_mac("RADecode", connID);
+    raFlush = load_one_sym_mac("RAFlush", connID);
+    raFreeDecoder = load_one_sym_mac("RAFreeDecoder", connID);
+    raGetFlavorProperty = load_one_sym_mac("RAGetFlavorProperty", connID);
+    raOpenCodec = load_one_sym_mac("RAOpenCodec", connID);
+    raOpenCodec2 = load_one_sym_mac("RAOpenCodec2", connID);
+    raInitDecoder = load_one_sym_mac("RAInitDecoder", connID);
+    raSetFlavor = load_one_sym_mac("RASetFlavor", connID);
+    raSetDLLAccessPath = load_one_sym_mac("SetDLLAccessPath", connID);
+    raSetPwd = load_one_sym_mac("RASetPwd", connID); // optional, used by SIPR
+
+    if (raCloseCodec && raDecode && /*raFlush && */raFreeDecoder &&
+    raGetFlavorProperty && (raOpenCodec || raOpenCodec2) && raSetFlavor &&
+    /*raSetDLLAccessPath &&*/ raInitDecoder)
+    {
+    rv_handle = connID;
+    return 1;
+    }
+
+    mp_msg(MSGT_DECAUDIO,MSGL_WARN,"Cannot resolve symbols - incompatible shlb: %s\n",path);
+    (void)CloseConnection(connID);
+    return 0;
+}
+
+#endif
+
+static int preinit(sh_audio_t *sh){
+  // let's check if the driver is available, return 0 if not.
+  // (you should do that if you use external lib(s) which is optional)
+  unsigned int result;
+  int len=0;
+  void* prop;
+  char *path;
+
+  path = malloc(strlen(REALCODEC_PATH)+strlen(sh->codec->dll)+2);
+  if (!path) return 0;
+  sprintf(path, REALCODEC_PATH "/%s", sh->codec->dll);
+
+    /* first try to load linux dlls, if failed and we're supporting win32 dlls,
+       then try to load the windows ones */
+      
+#ifdef USE_MACSHLB
+    if (strstr(sh->codec->dll,".shlb") && !load_syms_mac(path))
+#endif
+#ifdef HAVE_LIBDL       
+    if (strstr(sh->codec->dll,".dll") || !load_syms_linux(path))
+#endif
+#ifdef USE_WIN32DLL
+	if (!load_syms_windows(sh->codec->dll))
+#endif
+    {
+	mp_msg(MSGT_DECVIDEO, MSGL_ERR, MSGTR_MissingDLLcodec, sh->codec->dll);
+	mp_msg(MSGT_DECVIDEO, MSGL_HINT, "Read the RealAudio section of the DOCS!\n");
+	free(path);
+	return 0;
+    }
+
+#ifdef USE_WIN32DLL
+  if((raSetDLLAccessPath && dll_type == 0) || (wraSetDLLAccessPath && dll_type == 1)){
+#else
+  if(raSetDLLAccessPath){
+#endif
+      int i;
+      // used by 'SIPR'
+      path = realloc(path, strlen(REALCODEC_PATH) + 12);
+      sprintf(path, "DT_Codecs=" REALCODEC_PATH);
+      if(path[strlen(path)-1]!='/'){
+        path[strlen(path)+1]=0;
+        path[strlen(path)]='/';
+      }
+      path[strlen(path)+1]=0;
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+    {
+      for (i=0; i < strlen(path); i++)
+        if (path[i] == '/') path[i] = '\\';
+      wraSetDLLAccessPath(path);
+    }
+    else
+#endif
+      raSetDLLAccessPath(path);
+  }
+
+#ifdef USE_WIN32DLL
+    if (dll_type == 1){
+      if(wraOpenCodec2)
+	result=wraOpenCodec2(&sh->context,REALCODEC_PATH "\\");
+      else
+	result=wraOpenCodec(&sh->context);
+    } else
+#endif
+    if(raOpenCodec2)
+      result=raOpenCodec2(&sh->context,REALCODEC_PATH "/");
+    else
+      result=raOpenCodec(&sh->context);
+    if(result){
+      mp_msg(MSGT_DECAUDIO,MSGL_WARN,"Decoder open failed, error code: 0x%X\n",result);
+      return 0;
+    }
+//    printf("opencodec ok (result: %x)\n", result);
+  free(path); /* after this it isn't used anymore */
+
+  sh->samplerate=sh->wf->nSamplesPerSec;
+  sh->samplesize=sh->wf->wBitsPerSample/8;
+  sh->channels=sh->wf->nChannels;
+
+  { 
+    ra_init_t init_data={
+	sh->wf->nSamplesPerSec,
+	sh->wf->wBitsPerSample,
+	sh->wf->nChannels,
+	100, // quality
+	((short*)(sh->wf+1))[0],  // subpacket size
+	((short*)(sh->wf+1))[3],  // coded frame size
+	((short*)(sh->wf+1))[4], // codec data length
+	((char*)(sh->wf+1))+10 // extras
+    };
+#if defined(USE_WIN32DLL) || defined(USE_MACSHLB)
+    wra_init_t winit_data={
+	sh->wf->nSamplesPerSec,
+	sh->wf->wBitsPerSample,
+	sh->wf->nChannels,
+	100, // quality
+	((short*)(sh->wf+1))[0],  // subpacket size
+	((short*)(sh->wf+1))[3],  // coded frame size
+	((short*)(sh->wf+1))[4], // codec data length
+	((char*)(sh->wf+1))+10 // extras
+    };
+#endif
+#ifdef USE_MACSHLB
+	result=raInitDecoder(sh->context,&winit_data);
+#else
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+	result=wraInitDecoder(sh->context,&winit_data);
+    else
+#endif
+    result=raInitDecoder(sh->context,&init_data);
+#endif
+    if(result){
+      mp_msg(MSGT_DECAUDIO,MSGL_WARN,"Decoder init failed, error code: 0x%X\n",result);
+      return 0;
+    }
+//    printf("initdecoder ok (result: %x)\n", result);
+  }
+
+#ifdef USE_WIN32DLL
+    if((raSetPwd && dll_type == 0) || (wraSetPwd && dll_type == 1)){
+#else
+    if(raSetPwd){
+#endif
+	// used by 'SIPR'
+#ifdef USE_WIN32DLL
+	if (dll_type == 1)
+	    wraSetPwd(sh->context,"Ardubancel Quazanga");
+	else
+#endif
+	raSetPwd(sh->context,"Ardubancel Quazanga"); // set password... lol.
+    }
+  
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+	result=wraSetFlavor(sh->context,((short*)(sh->wf+1))[2]);
+    else
+#endif
+    result=raSetFlavor(sh->context,((short*)(sh->wf+1))[2]);
+    if(result){
+      mp_msg(MSGT_DECAUDIO,MSGL_WARN,"Decoder flavor setup failed, error code: 0x%X\n",result);
+      return 0;
+    }
+
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+	prop=wraGetFlavorProperty(sh->context,((short*)(sh->wf+1))[2],0,&len);
+    else
+#endif
+    prop=raGetFlavorProperty(sh->context,((short*)(sh->wf+1))[2],0,&len);
+    mp_msg(MSGT_DECAUDIO,MSGL_INFO,"Audio codec: [%d] %s\n",((short*)(sh->wf+1))[2],prop);
+
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+	prop=wraGetFlavorProperty(sh->context,((short*)(sh->wf+1))[2],1,&len);
+    else
+#endif
+    prop=raGetFlavorProperty(sh->context,((short*)(sh->wf+1))[2],1,&len);
+    if(prop){
+      sh->i_bps=((*((int*)prop))+4)/8;
+      mp_msg(MSGT_DECAUDIO,MSGL_INFO,"Audio bitrate: %5.3f kbit/s (%d bps)  \n",(*((int*)prop))*0.001f,sh->i_bps);
+    } else
+      sh->i_bps=12000; // dunno :(((  [12000 seems to be OK for crash.rmvb too]
+    
+//    prop=raGetFlavorProperty(sh->context,((short*)(sh->wf+1))[2],0x13,&len);
+//    mp_msg(MSGT_DECAUDIO,MSGL_INFO,"Samples/block?: %d  \n",(*((int*)prop)));
+
+  sh->audio_out_minsize=128000; // no idea how to get... :(
+  sh->audio_in_minsize=((short*)(sh->wf+1))[1]*sh->wf->nBlockAlign;
+  
+  return 1; // return values: 1=OK 0=ERROR
+}
+
+static int init(sh_audio_t *sh_audio){
+  // initialize the decoder, set tables etc...
+
+  // you can store HANDLE or private struct pointer at sh->context
+  // you can access WAVEFORMATEX header at sh->wf
+  
+  // set sample format/rate parameters if you didn't do it in preinit() yet.
+
+  return 1; // return values: 1=OK 0=ERROR
+}
+
+static void uninit(sh_audio_t *sh){
+  // uninit the decoder etc...
+  // again: you don't have to free() a_in_buffer here! it's done by the core.
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+    {
+	if (wraFreeDecoder) wraFreeDecoder(sh->context);
+	if (wraCloseCodec) wraCloseCodec(sh->context);
+    }
+#endif
+
+    if (raFreeDecoder) raFreeDecoder(sh->context);
+    if (raCloseCodec) raCloseCodec(sh->context);
+
+#ifdef USE_MACSHLB
+    if (rv_handle){
+      (void)CloseConnection(rv_handle);
+      DisposePtr((Ptr)rv_handle);
+    }
+    if (raCloseCodec) DisposePtr((Ptr)raCloseCodec);
+    if (raDecode) DisposePtr((Ptr)raDecode);
+    if (raFlush) DisposePtr((Ptr)raFlush);
+    if (raFreeDecoder) DisposePtr((Ptr)raFreeDecoder);
+    if (raGetFlavorProperty) DisposePtr((Ptr)raGetFlavorProperty);
+    if (raOpenCodec) DisposePtr((Ptr)raOpenCodec);
+    if (raOpenCodec2) DisposePtr((Ptr)raOpenCodec2);
+    if (raInitDecoder) DisposePtr((Ptr)raInitDecoder);
+#endif
+
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+    {
+	if (rv_handle) FreeLibrary(rv_handle);
+    } else
+#endif
+// this dlclose() causes some memory corruption, and crashes soon (in caller):
+//    if (rv_handle) dlclose(rv_handle);
+    rv_handle = NULL;
+}
+
+static unsigned char sipr_swaps[38][2]={
+    {0,63},{1,22},{2,44},{3,90},{5,81},{7,31},{8,86},{9,58},{10,36},{12,68},
+    {13,39},{14,73},{15,53},{16,69},{17,57},{19,88},{20,34},{21,71},{24,46},
+    {25,94},{26,54},{28,75},{29,50},{32,70},{33,92},{35,74},{38,85},{40,56},
+    {42,87},{43,65},{45,59},{48,79},{49,93},{51,89},{55,95},{61,76},{67,83},
+    {77,80} };
+
+static int decode_audio(sh_audio_t *sh,unsigned char *buf,int minlen,int maxlen){
+  int result;
+  int len=-1;
+  int sps=((short*)(sh->wf+1))[0];
+  int w=sh->wf->nBlockAlign; // 5
+  int h=((short*)(sh->wf+1))[1];
+  int cfs=((short*)(sh->wf+1))[3];
+
+//  printf("bs=%d  sps=%d  w=%d h=%d \n",sh->wf->nBlockAlign,sps,w,h);
+  
+#if 1
+  if(sh->a_in_buffer_len<=0){
+      // fill the buffer!
+		if (sh->format == mmioFOURCC('1','4','_','4')) {
+			demux_read_data(sh->ds, sh->a_in_buffer, sh->wf->nBlockAlign);
+			sh->a_in_buffer_size=
+			sh->a_in_buffer_len=sh->wf->nBlockAlign;
+		} else
+		if (sh->format == mmioFOURCC('2','8','_','8')) {
+			int i,j;
+			for (j = 0; j < h; j++)
+				for (i = 0; i < h/2; i++)
+					demux_read_data(sh->ds, sh->a_in_buffer+i*2*w+j*cfs, cfs);
+			sh->a_in_buffer_size=
+			sh->a_in_buffer_len=sh->wf->nBlockAlign*h;
+		} else
+    if(!sps){
+      // 'sipr' way
+      int j,n;
+      int bs=h*w*2/96; // nibbles per subpacket
+      unsigned char *p=sh->a_in_buffer;
+      demux_read_data(sh->ds, p, h*w);
+      for(n=0;n<38;n++){
+          int i=bs*sipr_swaps[n][0];
+          int o=bs*sipr_swaps[n][1];
+	  // swap nibbles of block 'i' with 'o'      TODO: optimize
+	  for(j=0;j<bs;j++){
+	      int x=(i&1) ? (p[(i>>1)]>>4) : (p[(i>>1)]&15);
+	      int y=(o&1) ? (p[(o>>1)]>>4) : (p[(o>>1)]&15);
+	      if(o&1) p[(o>>1)]=(p[(o>>1)]&0x0F)|(x<<4);
+	        else  p[(o>>1)]=(p[(o>>1)]&0xF0)|x;
+	      if(i&1) p[(i>>1)]=(p[(i>>1)]&0x0F)|(y<<4);
+	        else  p[(i>>1)]=(p[(i>>1)]&0xF0)|y;
+	      ++i;++o;
+	  }
+      }
+      sh->a_in_buffer_size=
+      sh->a_in_buffer_len=w*h;
+    } else {
+      // 'cook' way
+      int x,y;
+      w/=sps;
+      for(y=0;y<h;y++)
+        for(x=0;x<w;x++){
+	    demux_read_data(sh->ds, sh->a_in_buffer+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);
+	}
+      sh->a_in_buffer_size=
+      sh->a_in_buffer_len=w*h*sps;
+    }
+  }
+
+#else
+  if(sh->a_in_buffer_len<=0){
+      // fill the buffer!
+      demux_read_data(sh->ds, sh->a_in_buffer, sh->wf->nBlockAlign);
+      sh->a_in_buffer_size=
+      sh->a_in_buffer_len=sh->wf->nBlockAlign;
+  }
+#endif
+  
+#ifdef USE_WIN32DLL
+    if (dll_type == 1)
+      result=wraDecode(sh->context, sh->a_in_buffer+sh->a_in_buffer_size-sh->a_in_buffer_len, sh->wf->nBlockAlign,
+       buf, &len, -1);
+    else
+#endif
+  result=raDecode(sh->context, sh->a_in_buffer+sh->a_in_buffer_size-sh->a_in_buffer_len, sh->wf->nBlockAlign,
+       buf, &len, -1);
+  sh->a_in_buffer_len-=sh->wf->nBlockAlign;
+  
+//  printf("radecode: %d bytes, res=0x%X  \n",len,result);
+
+  return len; // return value: number of _bytes_ written to output buffer,
+              // or -1 for EOF (or uncorrectable error)
+}
+
+static int control(sh_audio_t *sh,int cmd,void* arg, ...){
+    // various optional functions you MAY implement:
+    switch(cmd){
+      case ADCTRL_RESYNC_STREAM:
+        // it is called once after seeking, to resync.
+	// Note: sh_audio->a_in_buffer_len=0; is done _before_ this call!
+	return CONTROL_TRUE;
+      case ADCTRL_SKIP_FRAME:
+        // it is called to skip (jump over) small amount (1/10 sec or 1 frame)
+	// of audio data - used to sync audio to video after seeking
+	// if you don't return CONTROL_TRUE, it will defaults to:
+	//      ds_fill_buffer(sh_audio->ds);  // skip 1 demux packet
+	return CONTROL_TRUE;
+    }
+  return CONTROL_UNKNOWN;
+}
+
+#endif
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/vd_xanim.c MPlayer-1.0pre5/libmpcodecs/vd_xanim.c
--- MPlayer-1.0pre5.orig/libmpcodecs/vd_xanim.c	2003-07-04 03:22:51 +0700
+++ MPlayer-1.0pre5/libmpcodecs/vd_xanim.c	2004-08-08 10:36:04 +0700
@@ -258,27 +258,27 @@
 	return(0);
     }
     
-    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, "Exported functions by codec: [functable: 0x%08x entries: %d]\n",
+    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, "Exported functions by codec: [functable: %p entries: %d]\n",
 	mod_hdr->funcs, mod_hdr->num_funcs);
     for (i = 0; i < (int)mod_hdr->num_funcs; i++)
     {
-	mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " %d: %d %d [iq:0x%08x d:0x%08x]\n",
+	mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " %d: %d %d [iq:%p d:%p]\n",
 		i, func[i].what, func[i].id, func[i].iq_func, func[i].dec_func);
 	if (func[i].what & XAVID_AVI_QUERY)
 	{
-	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " 0x%08x: avi init/query func (id: %d)\n",
+	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " %p: avi init/query func (id: %d)\n",
 		func[i].iq_func, func[i].id);
 	    priv->iq_func = (void *)func[i].iq_func;
 	}
 	if (func[i].what & XAVID_QT_QUERY)
 	{
-	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " 0x%08x: qt init/query func (id: %d)\n",
+	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " %p: qt init/query func (id: %d)\n",
 		func[i].iq_func, func[i].id);
 	    priv->iq_func = (void *)func[i].iq_func;
 	}
 	if (func[i].what & XAVID_DEC_FUNC)
 	{
-	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " 0x%08x: decoder func (init/query: 0x%08x) (id: %d)\n",
+	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, " %p: decoder func (init/query: %p) (id: %d)\n",
 		func[i].dec_func, func[i].iq_func, func[i].id);
 	    priv->dec_func = (void *)func[i].dec_func;
 	}
@@ -306,7 +306,7 @@
     {
 	case CODEC_SUPPORTED:
 	    priv->dec_func = (void *)codec_hdr->decoder;
-	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, "Codec is supported: found decoder for %s at 0x%08x\n",
+	    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, "Codec is supported: found decoder for %s at %p\n",
 		codec_hdr->description, codec_hdr->decoder);
 	    return(1);
 	case CODEC_UNSUPPORTED:
@@ -720,8 +720,8 @@
     priv->decinfo->xs = priv->decinfo->ys = 0;
     priv->decinfo->special = 0;
     priv->decinfo->extra = codec_hdr.extra;
-    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, "decinfo->extra, filled by codec: 0x%08x [%s]\n",
-	&priv->decinfo->extra, priv->decinfo->extra);
+    mp_msg(MSGT_DECVIDEO, MSGL_DBG2, "decinfo->extra, filled by codec: %p [%s]\n",
+	&priv->decinfo->extra, (char *)priv->decinfo->extra);
 
     return(1);
 }
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/vf.c MPlayer-1.0pre5/libmpcodecs/vf.c
--- MPlayer-1.0pre5.orig/libmpcodecs/vf.c	2004-05-31 22:07:58 +0700
+++ MPlayer-1.0pre5/libmpcodecs/vf.c	2004-08-08 10:36:04 +0700
@@ -369,7 +369,7 @@
 		  (mpi->flags&MP_IMGFLAG_YUV)?"YUV":((mpi->flags&MP_IMGFLAG_SWAPPED)?"BGR":"RGB"),
 		  (mpi->flags&MP_IMGFLAG_PLANAR)?"planar":"packed",
 	          mpi->bpp*mpi->width*mpi->height/8);
-	    mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %x,%x,%x strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n",
+	    mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n",
 		mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],
 		mpi->stride[0], mpi->stride[1], mpi->stride[2],
 		mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);
diff -urN MPlayer-1.0pre5.orig/libmpcodecs/vf.c.orig MPlayer-1.0pre5/libmpcodecs/vf.c.orig
--- MPlayer-1.0pre5.orig/libmpcodecs/vf.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpcodecs/vf.c.orig	2004-05-31 22:07:58 +0700
@@ -0,0 +1,619 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../config.h"
+#ifdef HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#include "../m_option.h"
+#include "../m_struct.h"
+
+
+#include "img_format.h"
+#include "mp_image.h"
+#include "vf.h"
+
+#include "../libvo/fastmemcpy.h"
+
+extern vf_info_t vf_info_vo;
+extern vf_info_t vf_info_rectangle;
+#ifndef HAVE_NO_POSIX_SELECT
+extern vf_info_t vf_info_bmovl;
+#endif
+extern vf_info_t vf_info_crop;
+extern vf_info_t vf_info_expand;
+#ifdef FF_POSTPROCESS
+extern vf_info_t vf_info_pp;
+#endif
+extern vf_info_t vf_info_scale;
+#ifdef USE_LIBFAME
+extern vf_info_t vf_info_fame;
+#endif
+extern vf_info_t vf_info_format;
+extern vf_info_t vf_info_noformat;
+extern vf_info_t vf_info_yuy2;
+extern vf_info_t vf_info_flip;
+extern vf_info_t vf_info_rgb2bgr;
+extern vf_info_t vf_info_rotate;
+extern vf_info_t vf_info_mirror;
+extern vf_info_t vf_info_palette;
+extern vf_info_t vf_info_lavc;
+extern vf_info_t vf_info_zrmjpeg;
+extern vf_info_t vf_info_dvbscale;
+extern vf_info_t vf_info_cropdetect;
+extern vf_info_t vf_info_test;
+extern vf_info_t vf_info_noise;
+extern vf_info_t vf_info_yvu9;
+extern vf_info_t vf_info_lavcdeint;
+extern vf_info_t vf_info_eq;
+extern vf_info_t vf_info_eq2;
+extern vf_info_t vf_info_halfpack;
+extern vf_info_t vf_info_dint;
+extern vf_info_t vf_info_1bpp;
+extern vf_info_t vf_info_2xsai;
+extern vf_info_t vf_info_unsharp;
+extern vf_info_t vf_info_swapuv;
+extern vf_info_t vf_info_il;
+extern vf_info_t vf_info_fil;
+extern vf_info_t vf_info_boxblur;
+extern vf_info_t vf_info_sab;
+extern vf_info_t vf_info_smartblur;
+extern vf_info_t vf_info_perspective;
+extern vf_info_t vf_info_down3dright;
+extern vf_info_t vf_info_field;
+extern vf_info_t vf_info_denoise3d;
+extern vf_info_t vf_info_hqdn3d;
+extern vf_info_t vf_info_detc;
+extern vf_info_t vf_info_telecine;
+extern vf_info_t vf_info_tinterlace;
+extern vf_info_t vf_info_tfields;
+extern vf_info_t vf_info_ivtc;
+extern vf_info_t vf_info_ilpack;
+extern vf_info_t vf_info_dsize;
+extern vf_info_t vf_info_decimate;
+extern vf_info_t vf_info_softpulldown;
+extern vf_info_t vf_info_pullup;
+extern vf_info_t vf_info_filmdint;
+extern vf_info_t vf_info_framestep;
+extern vf_info_t vf_info_tile;
+extern vf_info_t vf_info_delogo;
+extern vf_info_t vf_info_hue;
+extern vf_info_t vf_info_spp;
+extern vf_info_t vf_info_yuvcsp;
+extern vf_info_t vf_info_kerndeint;
+extern vf_info_t vf_info_rgbtest;
+extern vf_info_t vf_info_qp;
+extern vf_info_t vf_info_phase;
+extern vf_info_t vf_info_divtc;
+extern vf_info_t vf_info_harddup;
+extern vf_info_t vf_info_softskip;
+
+// list of available filters:
+static vf_info_t* filter_list[]={
+    &vf_info_rectangle,
+#ifndef HAVE_NO_POSIX_SELECT
+    &vf_info_bmovl,
+#endif
+    &vf_info_crop,
+    &vf_info_expand,
+#ifdef FF_POSTPROCESS
+    &vf_info_pp,
+#endif
+    &vf_info_scale,
+//    &vf_info_osd,
+    &vf_info_vo,
+#ifdef USE_LIBFAME
+    &vf_info_fame,
+#endif
+    &vf_info_format,
+    &vf_info_noformat,
+    &vf_info_yuy2,
+    &vf_info_flip,
+    &vf_info_rgb2bgr,
+    &vf_info_rotate,
+    &vf_info_mirror,
+    &vf_info_palette,
+#ifdef USE_LIBAVCODEC
+    &vf_info_lavc,
+    &vf_info_lavcdeint,
+#endif
+#ifdef HAVE_ZR
+    &vf_info_zrmjpeg,
+#endif
+    &vf_info_dvbscale,
+    &vf_info_cropdetect,
+    &vf_info_test,
+    &vf_info_noise,
+    &vf_info_yvu9,
+    &vf_info_eq,
+    &vf_info_eq2,
+    &vf_info_halfpack,
+    &vf_info_dint,
+    &vf_info_1bpp,
+    &vf_info_2xsai,
+    &vf_info_unsharp,
+    &vf_info_swapuv,
+    &vf_info_il,
+    &vf_info_fil,
+    &vf_info_boxblur,
+    &vf_info_sab,
+    &vf_info_smartblur,
+    &vf_info_perspective,
+    &vf_info_down3dright,
+    &vf_info_field,
+    &vf_info_denoise3d,
+    &vf_info_hqdn3d,
+    &vf_info_detc,
+    &vf_info_telecine,
+    &vf_info_tinterlace,
+    &vf_info_tfields,
+    &vf_info_ivtc,
+    &vf_info_ilpack,
+    &vf_info_dsize,
+    &vf_info_decimate,
+    &vf_info_softpulldown,
+    &vf_info_pullup,
+    &vf_info_filmdint,
+    &vf_info_framestep,
+    &vf_info_tile,
+    &vf_info_delogo,
+    &vf_info_hue,
+#ifdef USE_LIBAVCODEC
+    &vf_info_spp,
+#endif
+    &vf_info_yuvcsp,
+    &vf_info_kerndeint,
+    &vf_info_rgbtest,
+#ifdef USE_LIBAVCODEC
+    &vf_info_qp,
+#endif
+    &vf_info_phase,
+    &vf_info_divtc,
+    &vf_info_harddup,
+    &vf_info_softskip,
+    NULL
+};
+
+// For the vf option
+m_obj_settings_t* vf_settings = NULL;
+// For the vop option
+m_obj_settings_t* vo_plugin_args = NULL;
+m_obj_list_t vf_obj_list = {
+  (void**)filter_list,
+  M_ST_OFF(vf_info_t,name),
+  M_ST_OFF(vf_info_t,info),
+  M_ST_OFF(vf_info_t,opts)
+};
+
+//============================================================================
+// mpi stuff:
+
+void vf_mpi_clear(mp_image_t* mpi,int x0,int y0,int w,int h){
+    int y;
+    if(mpi->flags&MP_IMGFLAG_PLANAR){
+	y0&=~1;h+=h&1;
+	if(x0==0 && w==mpi->width){
+	    // full width clear:
+	    memset(mpi->planes[0]+mpi->stride[0]*y0,0,mpi->stride[0]*h);
+	    memset(mpi->planes[1]+mpi->stride[1]*(y0>>mpi->chroma_y_shift),128,mpi->stride[1]*(h>>mpi->chroma_y_shift));
+	    memset(mpi->planes[2]+mpi->stride[2]*(y0>>mpi->chroma_y_shift),128,mpi->stride[2]*(h>>mpi->chroma_y_shift));
+	} else
+	for(y=y0;y<y0+h;y+=2){
+	    memset(mpi->planes[0]+x0+mpi->stride[0]*y,0,w);
+	    memset(mpi->planes[0]+x0+mpi->stride[0]*(y+1),0,w);
+	    memset(mpi->planes[1]+(x0>>mpi->chroma_x_shift)+mpi->stride[1]*(y>>mpi->chroma_y_shift),128,(w>>mpi->chroma_x_shift));
+	    memset(mpi->planes[2]+(x0>>mpi->chroma_x_shift)+mpi->stride[2]*(y>>mpi->chroma_y_shift),128,(w>>mpi->chroma_x_shift));
+	}
+	return;
+    }
+    // packed:
+    for(y=y0;y<y0+h;y++){
+	unsigned char* dst=mpi->planes[0]+mpi->stride[0]*y+(mpi->bpp>>3)*x0;
+	if(mpi->flags&MP_IMGFLAG_YUV){
+	    unsigned int* p=(unsigned int*) dst;
+	    int size=(mpi->bpp>>3)*w/4;
+	    int i;
+#ifdef WORDS_BIGENDIAN
+#define CLEAR_PACKEDYUV_PATTERN 0x00800080
+#define CLEAR_PACKEDYUV_PATTERN_SWAPPED 0x80008000
+#else
+#define CLEAR_PACKEDYUV_PATTERN 0x80008000
+#define CLEAR_PACKEDYUV_PATTERN_SWAPPED 0x00800080
+#endif
+	    if(mpi->flags&MP_IMGFLAG_SWAPPED){
+	        for(i=0;i<size-3;i+=4) p[i]=p[i+1]=p[i+2]=p[i+3]=CLEAR_PACKEDYUV_PATTERN_SWAPPED;
+		for(;i<size;i++) p[i]=CLEAR_PACKEDYUV_PATTERN_SWAPPED;
+	    } else {
+	        for(i=0;i<size-3;i+=4) p[i]=p[i+1]=p[i+2]=p[i+3]=CLEAR_PACKEDYUV_PATTERN;
+		for(;i<size;i++) p[i]=CLEAR_PACKEDYUV_PATTERN;
+	    }
+	} else
+	    memset(dst,0,(mpi->bpp>>3)*w);
+    }
+}
+
+mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){
+  mp_image_t* mpi=NULL;
+  int w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;
+  
+  if(vf->put_image==vf_next_put_image){
+      // passthru mode, if the plugin uses the fallback/default put_image() code
+      return vf_get_image(vf->next,outfmt,mp_imgtype,mp_imgflag,w,h);
+  }
+  
+  // Note: we should call libvo first to check if it supports direct rendering
+  // and if not, then fallback to software buffers:
+  switch(mp_imgtype){
+  case MP_IMGTYPE_EXPORT:
+    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);
+    mpi=vf->imgctx.export_images[0];
+    break;
+  case MP_IMGTYPE_STATIC:
+    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h);
+    mpi=vf->imgctx.static_images[0];
+    break;
+  case MP_IMGTYPE_TEMP:
+    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);
+    mpi=vf->imgctx.temp_images[0];
+    break;
+  case MP_IMGTYPE_IPB:
+    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:
+      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);
+      mpi=vf->imgctx.temp_images[0];
+      break;
+    }
+  case MP_IMGTYPE_IP:
+    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h);
+    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];
+    vf->imgctx.static_idx^=1;
+    break;
+  }
+  if(mpi){
+    mpi->type=mp_imgtype;
+    mpi->w=w; mpi->h=h;
+    // keep buffer allocation status & color flags only:
+//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);
+    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;
+    // accept restrictions & draw_slice flags only:
+    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK);
+    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;
+    if(mpi->width!=w2 || mpi->height!=h){
+//	printf("vf.c: MPI parameters changed!  %dx%d -> %dx%d   \n", mpi->width,mpi->height,w2,h);
+	if(mpi->flags&MP_IMGFLAG_ALLOCATED){
+	    if(mpi->width<w2 || mpi->height<h){
+		// need to re-allocate buffer memory:
+		free(mpi->planes[0]);
+		mpi->flags&=~MP_IMGFLAG_ALLOCATED;
+		printf("vf.c: have to REALLOCATE buffer memory :(\n");
+	    }
+//	} else {
+	} {
+	    mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;
+	    mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;
+	}
+    }
+    if(!mpi->bpp) mp_image_setfmt(mpi,outfmt);
+    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){
+
+	// check libvo first!
+	if(vf->get_image) vf->get_image(vf,mpi);
+	
+        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){
+          // non-direct and not yet allocated image. allocate it!
+	  
+	  // check if codec prefer aligned stride:  
+	  if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){
+	      int align=(mpi->flags&MP_IMGFLAG_PLANAR &&
+	                 mpi->flags&MP_IMGFLAG_YUV) ?
+			 (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME
+	      w2=((w+align)&(~align));
+	      if(mpi->width!=w2){
+	          // we have to change width... check if we CAN co it:
+		  int flags=vf->query_format(vf,outfmt); // should not fail
+		  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,"??? vf_get_image{vf->query_format(outfmt)} failed!\n");
+//		  printf("query -> 0x%X    \n",flags);
+		  if(flags&VFCAP_ACCEPT_STRIDE){
+	              mpi->width=w2;
+		      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;
+		  }
+	      }
+	  }
+	  
+	  // IF09 - allocate space for 4. plane delta info - unused
+	  if (mpi->imgfmt == IMGFMT_IF09)
+	  {
+	     mpi->planes[0]=memalign(64, mpi->bpp*mpi->width*(mpi->height+2)/8+
+	    				mpi->chroma_width*mpi->chroma_height);
+	     /* export delta table */
+	     mpi->planes[3]=mpi->planes[0]+(mpi->width*mpi->height)+2*(mpi->chroma_width*mpi->chroma_height);
+	  }
+	  else
+	     mpi->planes[0]=memalign(64, mpi->bpp*mpi->width*(mpi->height+2)/8);
+	  if(mpi->flags&MP_IMGFLAG_PLANAR){
+	      // YV12/I420/YVU9/IF09. feel free to add other planar formats here...
+	      //if(!mpi->stride[0]) 
+	      mpi->stride[0]=mpi->width;
+	      //if(!mpi->stride[1]) 
+	      mpi->stride[1]=mpi->stride[2]=mpi->chroma_width;
+	      if(mpi->flags&MP_IMGFLAG_SWAPPED){
+	          // I420/IYUV  (Y,U,V)
+	          mpi->planes[1]=mpi->planes[0]+mpi->width*mpi->height;
+	          mpi->planes[2]=mpi->planes[1]+mpi->chroma_width*mpi->chroma_height;
+	      } else {
+	          // YV12,YVU9,IF09  (Y,V,U)
+	          mpi->planes[2]=mpi->planes[0]+mpi->width*mpi->height;
+	          mpi->planes[1]=mpi->planes[2]+mpi->chroma_width*mpi->chroma_height;
+	      }
+	  } else {
+	      //if(!mpi->stride[0]) 
+	      mpi->stride[0]=mpi->width*mpi->bpp/8;
+	  }
+//	  printf("clearing img!\n");
+	  vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);
+	  mpi->flags|=MP_IMGFLAG_ALLOCATED;
+        }
+    }
+    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)
+	if(vf->start_slice) vf->start_slice(vf,mpi);
+    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){
+	    mp_msg(MSGT_DECVIDEO,MSGL_V,"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\n",
+		  vf->info->name,
+		  (mpi->type==MP_IMGTYPE_EXPORT)?"Exporting":
+	          ((mpi->flags&MP_IMGFLAG_DIRECT)?"Direct Rendering":"Allocating"),
+	          (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?" (slices)":"",
+	          mpi->width,mpi->height,mpi->bpp,
+		  (mpi->flags&MP_IMGFLAG_YUV)?"YUV":((mpi->flags&MP_IMGFLAG_SWAPPED)?"BGR":"RGB"),
+		  (mpi->flags&MP_IMGFLAG_PLANAR)?"planar":"packed",
+	          mpi->bpp*mpi->width*mpi->height/8);
+	    mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %x,%x,%x strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n",
+		mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],
+		mpi->stride[0], mpi->stride[1], mpi->stride[2],
+		mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);
+	    mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;
+    }
+
+  }
+//    printf("\rVF_MPI: %p %p %p %d %d %d    \n",
+//	mpi->planes[0],mpi->planes[1],mpi->planes[2],
+//	mpi->stride[0],mpi->stride[1],mpi->stride[2]);
+  return mpi;
+}
+
+//============================================================================
+
+// By default vf doesn't accept MPEGPES
+static int vf_default_query_format(struct vf_instance_s* vf, unsigned int fmt){
+  if(fmt == IMGFMT_MPEGPES) return 0;
+  return vf_next_query_format(vf,fmt);
+}
+
+vf_instance_t* vf_open_plugin(vf_info_t** filter_list, vf_instance_t* next, char *name, char **args){
+    vf_instance_t* vf;
+    int i;
+    for(i=0;;i++){
+	if(!filter_list[i]){
+	    mp_msg(MSGT_VFILTER,MSGL_ERR,MSGTR_CouldNotFindVideoFilter,name);
+	    return NULL; // no such filter!
+	}
+	if(!strcmp(filter_list[i]->name,name)) break;
+    }
+    vf=malloc(sizeof(vf_instance_t));
+    memset(vf,0,sizeof(vf_instance_t));
+    vf->info=filter_list[i];
+    vf->next=next;
+    vf->config=vf_next_config;
+    vf->control=vf_next_control;
+    vf->query_format=vf_default_query_format;
+    vf->put_image=vf_next_put_image;
+    vf->default_caps=VFCAP_ACCEPT_STRIDE;
+    vf->default_reqs=0;
+    if(vf->info->opts) { // vf_vo get some special argument
+      m_struct_t* st = vf->info->opts;
+      void* vf_priv = m_struct_alloc(st);
+      int n;
+      for(n = 0 ; args && args[2*n] ; n++)
+	m_struct_set(st,vf_priv,args[2*n],args[2*n+1]);
+      vf->priv = vf_priv;
+      args = NULL;
+    } else // Otherwise we should have the '_oldargs_'
+      if(args && !strcmp(args[0],"_oldargs_"))
+	args = (char**)args[1];
+      else
+	args = NULL;
+    if(vf->info->open(vf,(char*)args)>0) return vf; // Success!
+    free(vf);
+    mp_msg(MSGT_VFILTER,MSGL_ERR,MSGTR_CouldNotOpenVideoFilter,name);
+    return NULL;
+}
+
+vf_instance_t* vf_open_filter(vf_instance_t* next, char *name, char **args){
+  if(args && strcmp(args[0],"_oldargs_")) {
+    int i,l = 0;
+    for(i = 0 ; args && args[2*i] ; i++)
+      l += 1 + strlen(args[2*i]) + 1 + strlen(args[2*i+1]);
+    l += strlen(name);
+    {
+      char str[l+1];
+      char* p = str;
+      p += sprintf(str,"%s",name);
+      for(i = 0 ; args && args[2*i] ; i++)
+	p += sprintf(p," %s=%s",args[2*i],args[2*i+1]);
+      mp_msg(MSGT_VFILTER,MSGL_INFO,MSGTR_OpeningVideoFilter "[%s]\n",str);
+    }
+  } else if(strcmp(name,"vo")) {
+    if(args && strcmp(args[0],"_oldargs_") == 0)
+      mp_msg(MSGT_VFILTER,MSGL_INFO,MSGTR_OpeningVideoFilter
+	     "[%s=%s]\n", name,args[1]);
+    else
+      mp_msg(MSGT_VFILTER,MSGL_INFO,MSGTR_OpeningVideoFilter
+	     "[%s]\n", name);
+  }
+  return vf_open_plugin(filter_list,next,name,args);
+}
+
+//============================================================================
+
+unsigned int vf_match_csp(vf_instance_t** vfp,unsigned int* list,unsigned int preferred){
+    vf_instance_t* vf=*vfp;
+    unsigned int* p;
+    unsigned int best=0;
+    int ret;
+    if((p=list)) while(*p){
+	ret=vf->query_format(vf,*p);
+	mp_msg(MSGT_VFILTER,MSGL_V,"[%s] query(%s) -> %d\n",vf->info->name,vo_format_name(*p),ret&3);
+	if(ret&2){ best=*p; break;} // no conversion -> bingo!
+	if(ret&1 && !best) best=*p; // best with conversion
+	++p;
+    }
+    if(best) return best; // bingo, they have common csp!
+    // ok, then try with scale:
+    if(vf->info == &vf_info_scale) return 0; // avoid infinite recursion!
+    vf=vf_open_filter(vf,"scale",NULL);
+    if(!vf) return 0; // failed to init "scale"
+    // try the preferred csp first:
+    if(preferred && vf->query_format(vf,preferred)) best=preferred; else
+    // try the list again, now with "scaler" :
+    if((p=list)) while(*p){
+	ret=vf->query_format(vf,*p);
+	mp_msg(MSGT_VFILTER,MSGL_V,"[%s] query(%s) -> %d\n",vf->info->name,vo_format_name(*p),ret&3);
+	if(ret&2){ best=*p; break;} // no conversion -> bingo!
+	if(ret&1 && !best) best=*p; // best with conversion
+	++p;
+    }
+    if(best) *vfp=vf; // else uninit vf  !FIXME!
+    return best;
+}
+
+void vf_clone_mpi_attributes(mp_image_t* dst, mp_image_t* src){
+    dst->pict_type= src->pict_type;
+    dst->fields = src->fields;
+    dst->qscale_type= src->qscale_type;
+    if(dst->width == src->width && dst->height == src->height){
+	dst->qstride= src->qstride;
+	dst->qscale= src->qscale;
+    }
+}
+
+int vf_next_config(struct vf_instance_s* vf,
+        int width, int height, int d_width, int d_height,
+	unsigned int voflags, unsigned int outfmt){
+    int miss;
+    int flags=vf->next->query_format(vf->next,outfmt);
+    if(!flags){
+	// hmm. colorspace mismatch!!!
+	// let's insert the 'scale' filter, it does the job for us:
+	vf_instance_t* vf2;
+	if(vf->next->info==&vf_info_scale) return 0; // scale->scale
+	vf2=vf_open_filter(vf->next,"scale",NULL);
+	if(!vf2) return 0; // shouldn't happen!
+	vf->next=vf2;
+	flags=vf->next->query_format(vf->next,outfmt);
+	if(!flags){
+	    mp_msg(MSGT_VFILTER,MSGL_ERR,MSGTR_CannotFindColorspace);
+	    return 0; // FAIL
+	}
+    }
+    mp_msg(MSGT_VFILTER,MSGL_V,"REQ: flags=0x%X  req=0x%X  \n",flags,vf->default_reqs);
+    miss=vf->default_reqs - (flags&vf->default_reqs);
+    if(miss&VFCAP_ACCEPT_STRIDE){
+	// vf requires stride support but vf->next doesn't support it!
+	// let's insert the 'expand' filter, it does the job for us:
+	vf_instance_t* vf2=vf_open_filter(vf->next,"expand",NULL);
+	if(!vf2) return 0; // shouldn't happen!
+	vf->next=vf2;
+    }
+    return vf->next->config(vf->next,width,height,d_width,d_height,voflags,outfmt);
+}
+
+int vf_next_control(struct vf_instance_s* vf, int request, void* data){
+    return vf->next->control(vf->next,request,data);
+}
+
+int vf_next_query_format(struct vf_instance_s* vf, unsigned int fmt){
+    int flags=vf->next->query_format(vf->next,fmt);
+    if(flags) flags|=vf->default_caps;
+    return flags;
+}
+
+int vf_next_put_image(struct vf_instance_s* vf,mp_image_t *mpi){
+    return vf->next->put_image(vf->next,mpi);
+}
+
+void vf_next_draw_slice(struct vf_instance_s* vf,unsigned char** src, int * stride,int w, int h, int x, int y){
+    if (vf->next->draw_slice) {
+	vf->next->draw_slice(vf->next,src,stride,w,h,x,y);
+	return;
+    }
+    if (!vf->dmpi) {
+	mp_msg(MSGT_VFILTER,MSGL_ERR,"draw_slice: dmpi not stored by vf_%s\n", vf->info->name);
+	return;
+    }
+    if (!(vf->dmpi->flags & MP_IMGFLAG_PLANAR)) {
+	memcpy_pic(vf->dmpi->planes[0]+y*vf->dmpi->stride[0]+vf->dmpi->bpp/8*x,
+	    src[0], vf->dmpi->bpp/8*w, h, vf->dmpi->stride[0], stride[0]);
+	return;
+    }
+    memcpy_pic(vf->dmpi->planes[0]+y*vf->dmpi->stride[0]+x, src[0],
+	w, h, vf->dmpi->stride[0], stride[0]);
+    memcpy_pic(vf->dmpi->planes[1]+(y>>vf->dmpi->chroma_y_shift)*vf->dmpi->stride[1]+(x>>vf->dmpi->chroma_x_shift),
+	src[1], w>>vf->dmpi->chroma_x_shift, h>>vf->dmpi->chroma_y_shift, vf->dmpi->stride[1], stride[1]);
+    memcpy_pic(vf->dmpi->planes[2]+(y>>vf->dmpi->chroma_y_shift)*vf->dmpi->stride[2]+(x>>vf->dmpi->chroma_x_shift),
+	src[2], w>>vf->dmpi->chroma_x_shift, h>>vf->dmpi->chroma_y_shift, vf->dmpi->stride[2], stride[2]);
+}
+
+//============================================================================
+
+vf_instance_t* append_filters(vf_instance_t* last){
+  vf_instance_t* vf;
+  int i; 
+
+  // -vf take precedence over -vop
+  if(vf_settings) {
+    // We want to add them in the 'right order'
+    for(i = 0 ; vf_settings[i].name ; i++)
+      /* NOP */;
+    for(i-- ; i >= 0 ; i--) {
+      //printf("Open filter %s\n",vf_settings[i].name);
+      vf = vf_open_filter(last,vf_settings[i].name,vf_settings[i].attribs);
+      if(vf) last=vf;
+    }
+  } else if(vo_plugin_args) {
+    for(i = 0 ; vo_plugin_args[i].name ; i++) {
+      vf = vf_open_filter(last,vo_plugin_args[i].name,
+			  vo_plugin_args[i].attribs);
+      if(vf) last=vf;
+    }
+  }
+  return last;
+}
+
+//============================================================================
+
+void vf_uninit_filter(vf_instance_t* vf){
+    if(vf->uninit) vf->uninit(vf);
+    free_mp_image(vf->imgctx.static_images[0]);
+    free_mp_image(vf->imgctx.static_images[1]);
+    free_mp_image(vf->imgctx.temp_images[0]);
+    free_mp_image(vf->imgctx.export_images[0]);
+    free(vf);
+}
+
+void vf_uninit_filter_chain(vf_instance_t* vf){
+    while(vf){
+	vf_instance_t* next=vf->next;
+	vf_uninit_filter(vf);
+	vf=next;
+    }
+}
+
+void vf_list_plugins(){
+    int i=0;
+    while(filter_list[i]){
+        mp_msg(MSGT_VFILTER,MSGL_INFO,"\t%-10s: %s\n",filter_list[i]->name,filter_list[i]->info);
+        i++;
+    }
+}
diff -urN MPlayer-1.0pre5.orig/libmpdemux/asfheader.c MPlayer-1.0pre5/libmpdemux/asfheader.c
--- MPlayer-1.0pre5.orig/libmpdemux/asfheader.c	2004-04-17 17:31:38 +0700
+++ MPlayer-1.0pre5/libmpdemux/asfheader.c	2004-08-08 10:36:04 +0700
@@ -158,7 +158,11 @@
 	mp_msg(MSGT_HEADER,MSGL_V,"stream concealment: %s\n",asf_chunk_type(streamh.concealment));
 	mp_msg(MSGT_HEADER,MSGL_V,"type: %d bytes,  stream: %d bytes  ID: %d\n",(int)streamh.type_size,(int)streamh.stream_size,(int)streamh.stream_no);
 	mp_msg(MSGT_HEADER,MSGL_V,"unk1: %lX  unk2: %X\n",(unsigned long)streamh.unk1,(unsigned int)streamh.unk2);
+#ifdef _LARGEFILE_SOURCE 
+	mp_msg(MSGT_HEADER,MSGL_V,"FILEPOS=0x%llX\n",stream_tell(demuxer->stream));
+#else
 	mp_msg(MSGT_HEADER,MSGL_V,"FILEPOS=0x%X\n",stream_tell(demuxer->stream));
+#endif
       }
       if(streamh.type_size>2048 || streamh.stream_size>2048){
           mp_msg(MSGT_HEADER,MSGL_FATAL,"FATAL: header size bigger than 2048 bytes (%d,%d)!\n"
diff -urN MPlayer-1.0pre5.orig/libmpdemux/aviheader.c MPlayer-1.0pre5/libmpdemux/aviheader.c
--- MPlayer-1.0pre5.orig/libmpdemux/aviheader.c	2004-07-01 05:50:56 +0700
+++ MPlayer-1.0pre5/libmpdemux/aviheader.c	2004-08-08 10:36:04 +0700
@@ -364,8 +364,13 @@
       off_t base = 0;
       uint32_t last_off = 0;
       priv->idx_size=size2>>4;
-      mp_msg(MSGT_HEADER,MSGL_V,"Reading INDEX block, %d chunks for %ld frames (fpos=%p)\n",
+#ifdef _LARGEFILE_SOURCE 
+      mp_msg(MSGT_HEADER,MSGL_V,"Reading INDEX block, %d chunks for %d frames (fpos=%#llx)\n",
         priv->idx_size,avih.dwTotalFrames, stream_tell(demuxer->stream));
+#else
+      mp_msg(MSGT_HEADER,MSGL_V,"Reading INDEX block, %d chunks for %d frames (fpos=%#lx)\n",
+        priv->idx_size,avih.dwTotalFrames, stream_tell(demuxer->stream));
+#endif
       priv->idx=malloc(priv->idx_size<<4);
 //      printf("\nindex to %p !!!!! (priv=%p)\n",priv->idx,priv);
       stream_read(demuxer->stream,(char*)priv->idx,priv->idx_size<<4);
@@ -425,7 +430,7 @@
   }
   mp_msg(MSGT_HEADER,MSGL_DBG2,"list_end=0x%X  pos=0x%X  chunksize=0x%X  next=0x%X\n",
       (int)list_end, (int)stream_tell(demuxer->stream),
-      chunksize, (int)chunksize+stream_tell(demuxer->stream));
+      chunksize, (int)chunksize+(int)stream_tell(demuxer->stream));
   if(list_end>0 &&
      chunksize+stream_tell(demuxer->stream) == list_end) list_end=0;
   if(list_end>0 && chunksize+stream_tell(demuxer->stream)>list_end){
diff -urN MPlayer-1.0pre5.orig/libmpdemux/aviheader.c.orig MPlayer-1.0pre5/libmpdemux/aviheader.c.orig
--- MPlayer-1.0pre5.orig/libmpdemux/aviheader.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpdemux/aviheader.c.orig	2004-07-01 05:50:56 +0700
@@ -0,0 +1,720 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "config.h"
+#include "mp_msg.h"
+
+#include "stream.h"
+#include "demuxer.h"
+#include "stheader.h"
+
+#include "bswap.h"
+#include "aviheader.h"
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+
+static MainAVIHeader avih;
+
+extern void print_avih(MainAVIHeader *h);
+extern void print_avih_flags(MainAVIHeader *h);
+extern void print_strh(AVIStreamHeader *h);
+extern void print_wave_header(WAVEFORMATEX *h);
+extern void print_video_header(BITMAPINFOHEADER *h);
+extern void print_index(AVIINDEXENTRY *idx,int idx_size);
+extern void print_avistdindex_chunk(avistdindex_chunk *h);
+extern void print_avisuperindex_chunk(avisuperindex_chunk *h);
+
+static int odml_get_vstream_id(int id, unsigned char res[])
+{
+    unsigned char *p = (unsigned char *)&id;
+    id = le2me_32(id);
+
+    if (p[2] == 'd') {
+	if (res) {
+	    res[0] = p[0];
+	    res[1] = p[1];
+	}
+	return 1;
+    }
+    return 0;
+}
+
+/*
+ * Simple quicksort for AVIINDEXENTRYs
+ */
+static void avi_idx_quicksort(AVIINDEXENTRY *idx, int from, int to)
+{
+    AVIINDEXENTRY temp;
+    int lo = to;
+    int hi = from;
+    off_t pivot_ofs = AVI_IDX_OFFSET(&idx[(from + to) / 2]);
+    do {
+	while(pivot_ofs < AVI_IDX_OFFSET(&idx[lo])) lo--;
+	while(pivot_ofs > AVI_IDX_OFFSET(&idx[hi])) hi++;
+	if(hi <= lo) {
+	    if (hi != lo) {
+		memcpy(&temp, &idx[lo], sizeof(temp));
+		memcpy(&idx[lo], &idx[hi], sizeof(temp));
+		memcpy(&idx[hi], &temp, sizeof(temp));
+	    }
+	    lo--; hi++;
+	}
+    } while (lo >= hi);
+    if (from < lo) avi_idx_quicksort(idx, from, lo);
+    if (to > hi) avi_idx_quicksort(idx, hi, to);
+}
+
+void read_avi_header(demuxer_t *demuxer,int index_mode){
+sh_audio_t *sh_audio=NULL;
+sh_video_t *sh_video=NULL;
+int stream_id=-1;
+int idxfix_videostream=0;
+int idxfix_divx=0;
+avi_priv_t* priv=demuxer->priv;
+off_t list_end=0;
+
+//---- AVI header:
+priv->idx_size=0;
+priv->audio_streams=0;
+while(1){
+  int id=stream_read_dword_le(demuxer->stream);
+  unsigned chunksize,size2;
+  static int last_fccType=0;
+  char* hdr=NULL;
+  //
+  if(stream_eof(demuxer->stream)) break;
+  // Imply -forceidx if -saveidx is specified
+  if (index_file_save)
+    index_mode = 2;
+  //
+  if(id==mmioFOURCC('L','I','S','T')){
+    unsigned len=stream_read_dword_le(demuxer->stream);   // list size
+    id=stream_read_dword_le(demuxer->stream);             // list type
+    mp_msg(MSGT_HEADER,MSGL_DBG2,"LIST %.4s  len=%u\n",(char *) &id,len);
+    if(len >= 4) {
+	len -= 4;
+	list_end=stream_tell(demuxer->stream)+((len+1)&(~1));
+    } else {
+	mp_msg(MSGT_HEADER,MSGL_WARN,"** empty list?!\n");
+	list_end = 0;
+    }
+    mp_msg(MSGT_HEADER,MSGL_V,"list_end=0x%X\n",(int)list_end);
+    if(id==listtypeAVIMOVIE){
+      // found MOVI header
+      if(!demuxer->movi_start) demuxer->movi_start=stream_tell(demuxer->stream);
+      demuxer->movi_end=stream_tell(demuxer->stream)+len;
+      mp_msg(MSGT_HEADER,MSGL_V,"Found movie at 0x%X - 0x%X\n",(int)demuxer->movi_start,(int)demuxer->movi_end);
+      if(demuxer->stream->end_pos>demuxer->movi_end) demuxer->movi_end=demuxer->stream->end_pos;
+      if(index_mode==-2 || index_mode==2 || index_mode==0)
+        break; // reading from non-seekable source (stdin) or forced index or no index forced
+      if(list_end>0) stream_seek(demuxer->stream,list_end); // skip movi
+      list_end=0;
+    }
+    continue;
+  }
+  size2=stream_read_dword_le(demuxer->stream);
+  mp_msg(MSGT_HEADER,MSGL_DBG2,"CHUNK %.4s  len=%u\n",(char *) &id,size2);
+  chunksize=(size2+1)&(~1);
+  switch(id){
+
+    // Indicates where the subject of the file is archived
+    case mmioFOURCC('I','A','R','L'): hdr="Archival Location";break;
+    // Lists the artist of the original subject of the file;
+    // for example, "Michaelangelo."
+    case mmioFOURCC('I','A','R','T'): hdr="Artist";break;
+    // Lists the name of the person or organization that commissioned
+    // the subject of the file; for example "Pope Julian II."
+    case mmioFOURCC('I','C','M','S'): hdr="Commissioned";break;
+    // Provides general comments about the file or the subject
+    // of the file. If the comment is several sentences long, end each
+    // sentence with a period. Do not include new-line characters.
+    case mmioFOURCC('I','C','M','T'): hdr="Comments";break;
+    // Records the copyright information for the file; for example,
+    // "Copyright Encyclopedia International 1991." If there are multiple
+    // copyrights, separate them by semicolon followed by a space.
+    case mmioFOURCC('I','C','O','P'): hdr="Copyright";break;
+    // Describes whether an image has been cropped and, if so, how it
+    // was cropped; for example, "lower-right corner."
+    case mmioFOURCC('I','C','R','D'): hdr="Creation Date";break;
+    // Describes whether an image has been cropped and, if so, how it
+    // was cropped; for example, "lower-right corner."
+    case mmioFOURCC('I','C','R','P'): hdr="Cropped";break;
+    // Specifies the size of the original subject of the file; for
+    // example, "8.5 in h, 11 in w."
+    case mmioFOURCC('I','D','I','M'): hdr="Dimensions";break;
+    // Stores dots per inch setting of the digitizer used to
+    // produce the file, such as "300."
+    case mmioFOURCC('I','D','P','I'): hdr="Dots Per Inch";break;
+    // Stores the of the engineer who worked on the file. If there are
+    // multiple engineers, separate the names by a semicolon and a blank;
+    // for example, "Smith, John; Adams, Joe."
+    case mmioFOURCC('I','E','N','G'): hdr="Engineer";break;
+    // Describes the original work, such as "landscape,", "portrait,"
+    // "still liefe," etc.
+    case mmioFOURCC('I','G','N','R'): hdr="Genre";break;
+    // Provides a list of keywords that refer to the file or subject of the
+    // file. Separate multiple keywords with a semicolon and a blank;
+    // for example, "Seattle, aerial view; scenery."
+    case mmioFOURCC('I','K','E','Y'): hdr="Keywords";break;
+    // ILGT - Describes the changes in the lightness settings on the digitizer
+    // required to produce the file. Note that the format of this information
+    // depends on the hardware used.
+    case mmioFOURCC('I','L','G','T'): hdr="Lightness";break;
+    // IMED - Decribes the original subject of the file, such as
+    // "computer image," "drawing," "lithograph," and so on.
+    case mmioFOURCC('I','M','E','D'): hdr="Medium";break;
+    // INAM - Stores the title of the subject of the file, such as
+    // "Seattle from Above."
+    case mmioFOURCC('I','N','A','M'): hdr="Name";break;
+    // IPLT - Specifies the number of colors requested when digitizing
+    // an image, such as "256."
+    case mmioFOURCC('I','P','L','T'): hdr="Palette Setting";break;
+    // IPRD - Specifies the name of title the file was originally intended
+    // for, such as "Encyclopedia of Pacific Northwest Geography."
+    case mmioFOURCC('I','P','R','D'): hdr="Product";break;
+    // ISBJ - Decsribes the contents of the file, such as
+    // "Aerial view of Seattle."
+    case mmioFOURCC('I','S','B','J'): hdr="Subject";break;
+    // ISFT - Identifies the name of the software packages used to create the
+    // file, such as "Microsoft WaveEdit"
+    case mmioFOURCC('I','S','F','T'): hdr="Software";break;
+    // ISHP - Identifies the change in sharpness for the digitizer
+    // required to produce the file (the format depends on the hardware used).
+    case mmioFOURCC('I','S','H','P'): hdr="Sharpness";break;
+    // ISRC - Identifies the name of the person or organization who
+    // suplied the original subject of the file; for example, "Try Research."
+    case mmioFOURCC('I','S','R','C'): hdr="Source";break;
+    // ISRF - Identifies the original form of the material that was digitized,
+    // such as "slide," "paper," "map," and so on. This is not necessarily
+    // the same as IMED
+    case mmioFOURCC('I','S','R','F'): hdr="Source Form";break;
+    // ITCH - Identifies the technician who digitized the subject file;
+    // for example, "Smith, John."
+    case mmioFOURCC('I','T','C','H'): hdr="Technician";break;
+    case mmioFOURCC('I','S','M','P'): hdr="Time Code";break;
+    case mmioFOURCC('I','D','I','T'): hdr="Digitization Time";break;
+
+    case ckidAVIMAINHDR:          // read 'avih'
+      stream_read(demuxer->stream,(char*) &avih,MIN(size2,sizeof(avih)));
+      le2me_MainAVIHeader(&avih); // swap to machine endian
+      chunksize-=MIN(size2,sizeof(avih));
+      if(verbose>0) print_avih(&avih); // else print_avih_flags(&avih);
+      break;
+    case ckidSTREAMHEADER: {      // read 'strh'
+      AVIStreamHeader h;
+      stream_read(demuxer->stream,(char*) &h,MIN(size2,sizeof(h)));
+      le2me_AVIStreamHeader(&h);  // swap to machine endian
+      chunksize-=MIN(size2,sizeof(h));
+      ++stream_id;
+      if(h.fccType==streamtypeVIDEO){
+        sh_video=new_sh_video(demuxer,stream_id);
+        memcpy(&sh_video->video,&h,sizeof(h));
+      } else
+      if(h.fccType==streamtypeAUDIO){
+        sh_audio=new_sh_audio(demuxer,stream_id);
+        memcpy(&sh_audio->audio,&h,sizeof(h));
+      }
+      last_fccType=h.fccType;
+      if(verbose>=1) print_strh(&h);
+      break; }
+    case mmioFOURCC('i', 'n', 'd', 'x'): {
+      uint32_t i;
+      unsigned msize = 0;
+      avisuperindex_chunk *s;
+      priv->suidx_size++;
+      priv->suidx = realloc(priv->suidx, priv->suidx_size * sizeof (avisuperindex_chunk));
+      s = &priv->suidx[priv->suidx_size-1];
+
+      chunksize-=24;
+      memcpy(s->fcc, "indx", 4);
+      s->dwSize = size2;
+      s->wLongsPerEntry = stream_read_word_le(demuxer->stream);
+      s->bIndexSubType = stream_read_char(demuxer->stream);
+      s->bIndexType = stream_read_char(demuxer->stream);
+      s->nEntriesInUse = stream_read_dword_le(demuxer->stream);
+      *(uint32_t *)s->dwChunkId = stream_read_dword_le(demuxer->stream);
+      stream_read(demuxer->stream, (char *)s->dwReserved, 3*4);
+      memset(s->dwReserved, 0, 3*4);
+	  
+      print_avisuperindex_chunk(s);
+
+      msize = sizeof (uint32_t) * s->wLongsPerEntry * s->nEntriesInUse;
+      s->aIndex = malloc(msize);
+      memset (s->aIndex, 0, msize);
+      s->stdidx = malloc (s->nEntriesInUse * sizeof (avistdindex_chunk));
+      memset (s->stdidx, 0, s->nEntriesInUse * sizeof (avistdindex_chunk));
+
+      // now the real index of indices
+      for (i=0; i<s->nEntriesInUse; i++) {
+	  chunksize-=16;
+	  s->aIndex[i].qwOffset = stream_read_dword_le(demuxer->stream) & 0xffffffff;
+	  s->aIndex[i].qwOffset |= ((uint64_t)stream_read_dword_le(demuxer->stream) & 0xffffffff)<<32;
+	  s->aIndex[i].dwSize = stream_read_dword_le(demuxer->stream);
+	  s->aIndex[i].dwDuration = stream_read_dword_le(demuxer->stream);
+	  mp_msg (MSGT_HEADER, MSGL_V, "ODML (%.4s): [%d] 0x%016llx 0x%04lx %ld\n", 
+		  (s->dwChunkId), i,
+		  (uint64_t)s->aIndex[i].qwOffset, s->aIndex[i].dwSize, s->aIndex[i].dwDuration);
+      }
+
+      break; }
+    case ckidSTREAMFORMAT: {      // read 'strf'
+      if(last_fccType==streamtypeVIDEO){
+        sh_video->bih=calloc((chunksize<sizeof(BITMAPINFOHEADER))?sizeof(BITMAPINFOHEADER):chunksize,1);
+//        sh_video->bih=malloc(chunksize); memset(sh_video->bih,0,chunksize);
+        mp_msg(MSGT_HEADER,MSGL_V,"found 'bih', %u bytes of %d\n",chunksize,sizeof(BITMAPINFOHEADER));
+        stream_read(demuxer->stream,(char*) sh_video->bih,chunksize);
+	le2me_BITMAPINFOHEADER(sh_video->bih);  // swap to machine endian
+	// fixup MS-RLE header (seems to be broken for <256 color files)
+	if(sh_video->bih->biCompression<=1 && sh_video->bih->biSize==40)
+	    sh_video->bih->biSize=chunksize;
+        if(verbose>=1) print_video_header(sh_video->bih);
+        chunksize=0;
+//        sh_video->fps=(float)sh_video->video.dwRate/(float)sh_video->video.dwScale;
+//        sh_video->frametime=(float)sh_video->video.dwScale/(float)sh_video->video.dwRate;
+//        if(demuxer->video->id==-1) demuxer->video->id=stream_id;
+        // IdxFix:
+        idxfix_videostream=stream_id;
+        switch(sh_video->bih->biCompression){
+	case mmioFOURCC('M', 'P', 'G', '4'):
+	case mmioFOURCC('m', 'p', 'g', '4'):
+	case mmioFOURCC('D', 'I', 'V', '1'):
+          idxfix_divx=3; // we can fix keyframes only for divx coded files!
+	  mp_msg(MSGT_HEADER,MSGL_V,"Regenerating keyframe table for M$ mpg4v1 video\n");
+	  break;
+        case mmioFOURCC('D', 'I', 'V', '3'):
+	case mmioFOURCC('d', 'i', 'v', '3'):
+	case mmioFOURCC('D', 'I', 'V', '4'):
+        case mmioFOURCC('d', 'i', 'v', '4'):
+	case mmioFOURCC('D', 'I', 'V', '5'):
+	case mmioFOURCC('d', 'i', 'v', '5'):
+	case mmioFOURCC('D', 'I', 'V', '6'):
+        case mmioFOURCC('d', 'i', 'v', '6'):
+	case mmioFOURCC('M', 'P', '4', '3'):
+	case mmioFOURCC('m', 'p', '4', '3'):
+	case mmioFOURCC('M', 'P', '4', '2'):
+	case mmioFOURCC('m', 'p', '4', '2'):
+	case mmioFOURCC('D', 'I', 'V', '2'):
+        case mmioFOURCC('A', 'P', '4', '1'):
+          idxfix_divx=1; // we can fix keyframes only for divx coded files!
+	  mp_msg(MSGT_HEADER,MSGL_V,"Regenerating keyframe table for DIVX 3 video\n");
+	  break;
+        case mmioFOURCC('D', 'I', 'V', 'X'):
+        case mmioFOURCC('d', 'i', 'v', 'x'):
+        case mmioFOURCC('D', 'X', '5', '0'):
+          idxfix_divx=2; // we can fix keyframes only for divx coded files!
+	  mp_msg(MSGT_HEADER,MSGL_V,"Regenerating keyframe table for DIVX 4 video\n");
+	  break;
+        }
+      } else
+      if(last_fccType==streamtypeAUDIO){
+	unsigned wf_size = chunksize<sizeof(WAVEFORMATEX)?sizeof(WAVEFORMATEX):chunksize;
+        sh_audio->wf=calloc(wf_size,1);
+//        sh_audio->wf=malloc(chunksize); memset(sh_audio->wf,0,chunksize);
+        mp_msg(MSGT_HEADER,MSGL_V,"found 'wf', %d bytes of %d\n",chunksize,sizeof(WAVEFORMATEX));
+        stream_read(demuxer->stream,(char*) sh_audio->wf,chunksize);
+	le2me_WAVEFORMATEX(sh_audio->wf);
+	if (sh_audio->wf->cbSize != 0 &&
+	    wf_size < sizeof(WAVEFORMATEX)+sh_audio->wf->cbSize) {
+	    sh_audio->wf=realloc(sh_audio->wf, sizeof(WAVEFORMATEX)+sh_audio->wf->cbSize);
+	}
+        chunksize=0;
+        if(verbose>=1) print_wave_header(sh_audio->wf);
+	++priv->audio_streams;
+//        if(demuxer->audio->id==-1) demuxer->audio->id=stream_id;
+      }
+      break;
+    }
+    case mmioFOURCC('v', 'p', 'r', 'p'): {
+	VideoPropHeader *vprp = malloc(chunksize);
+	unsigned int i;
+	stream_read(demuxer->stream, (void*)vprp, chunksize);
+	le2me_VideoPropHeader(vprp);
+	chunksize -= sizeof(*vprp)-sizeof(vprp->FieldInfo);
+	chunksize /= sizeof(VIDEO_FIELD_DESC);
+	if (vprp->nbFieldPerFrame > chunksize) {
+	    vprp->nbFieldPerFrame = chunksize;
+	}
+	chunksize = 0;
+	for (i=0; i<vprp->nbFieldPerFrame; i++) {
+		le2me_VIDEO_FIELD_DESC(&vprp->FieldInfo[i]);
+	}
+	if (sh_video) {
+		sh_video->aspect = GET_AVI_ASPECT(vprp->dwFrameAspectRatio);
+	}
+	if(verbose>=1) print_vprp(vprp);
+	break;
+    }
+    case mmioFOURCC('d', 'm', 'l', 'h'): {
+	// dmlh 00 00 00 04 frms
+	unsigned int total_frames = stream_read_dword_le(demuxer->stream);
+	mp_msg(MSGT_HEADER,MSGL_V,"AVI: dmlh found (size=%d) (total_frames=%d)\n", chunksize, total_frames);
+	stream_skip(demuxer->stream, chunksize-4);
+	chunksize = 0;
+    }
+    break;
+    case ckidAVINEWINDEX:
+    if(demuxer->movi_end>stream_tell(demuxer->stream))
+	demuxer->movi_end=stream_tell(demuxer->stream); // fixup movi-end
+    if(index_mode && !priv->isodml){
+      int i;
+      off_t base = 0;
+      uint32_t last_off = 0;
+      priv->idx_size=size2>>4;
+      mp_msg(MSGT_HEADER,MSGL_V,"Reading INDEX block, %d chunks for %ld frames (fpos=%p)\n",
+        priv->idx_size,avih.dwTotalFrames, stream_tell(demuxer->stream));
+      priv->idx=malloc(priv->idx_size<<4);
+//      printf("\nindex to %p !!!!! (priv=%p)\n",priv->idx,priv);
+      stream_read(demuxer->stream,(char*)priv->idx,priv->idx_size<<4);
+      for (i = 0; i < priv->idx_size; i++) {	// swap index to machine endian
+	AVIINDEXENTRY *entry=(AVIINDEXENTRY*)priv->idx + i;
+	le2me_AVIINDEXENTRY(entry);
+	/*
+	 * We (ab)use the upper word for bits 32-47 of the offset, so
+	 * we'll clear them here.
+	 * FIXME: AFAIK no codec uses them, but if one does it will break
+	 */
+	entry->dwFlags&=0xffff;
+      }
+      chunksize-=priv->idx_size<<4;
+      if(verbose>=2) print_index(priv->idx,priv->idx_size);
+    }
+    break;
+    /* added May 2002 */
+    case mmioFOURCC('R','I','F','F'): {
+	char riff_type[4];
+
+	mp_msg(MSGT_HEADER, MSGL_V, "additional RIFF header...\n");
+	stream_read(demuxer->stream, riff_type, sizeof riff_type);
+	if (strncmp(riff_type, "AVIX", sizeof riff_type))
+	    mp_msg(MSGT_HEADER, MSGL_WARN,
+		   "** warning: this is no extended AVI header..\n");
+	else {
+		/*
+		 * We got an extended AVI header, so we need to switch to
+		 * ODML to get seeking to work, provided we got indx chunks
+		 * in the header (suidx_size > 0).
+		 */
+		if (priv->suidx_size > 0)
+			priv->isodml = 1;
+	}
+	chunksize = 0;
+	list_end = 0; /* a new list will follow */
+	break; }
+    case ckidAVIPADDING:
+	stream_skip(demuxer->stream, chunksize);
+	chunksize = 0;
+	break;
+  }
+  if(hdr){
+    mp_msg(MSGT_HEADER,MSGL_V,"hdr=%s  size=%u\n",hdr,size2);
+    if(size2==3)
+      chunksize=1; // empty
+    else {
+      char buf[256];
+      int len=(size2<250)?size2:250;
+      stream_read(demuxer->stream,buf,len);
+      chunksize-=len;
+      buf[len]=0;
+      mp_msg(MSGT_HEADER,MSGL_V,"%-10s: %s\n",hdr,buf);
+      demux_info_add(demuxer, hdr, buf);
+    }
+  }
+  mp_msg(MSGT_HEADER,MSGL_DBG2,"list_end=0x%X  pos=0x%X  chunksize=0x%X  next=0x%X\n",
+      (int)list_end, (int)stream_tell(demuxer->stream),
+      chunksize, (int)chunksize+stream_tell(demuxer->stream));
+  if(list_end>0 &&
+     chunksize+stream_tell(demuxer->stream) == list_end) list_end=0;
+  if(list_end>0 && chunksize+stream_tell(demuxer->stream)>list_end){
+      mp_msg(MSGT_HEADER,MSGL_V,"Broken chunk?  chunksize=%d  (id=%.4s)\n",chunksize,(char *) &id);
+      stream_seek(demuxer->stream,list_end);
+      list_end=0;
+  } else
+  if(chunksize>0) stream_skip(demuxer->stream,chunksize); else
+  if((int)chunksize<0) mp_msg(MSGT_HEADER,MSGL_WARN,"chunksize=%u  (id=%.4s)\n",chunksize,(char *) &id);
+  
+}
+
+if (priv->suidx_size > 0 && priv->idx_size == 0) {
+    /*
+     * No NEWAVIINDEX, but we got an OpenDML index.
+     */
+    priv->isodml = 1;
+}
+
+if (priv->isodml && (index_mode==-1 || index_mode==0)) {
+    int i, j, k;
+    int safety=1000;
+
+    avisuperindex_chunk *cx;
+    AVIINDEXENTRY *idx;
+
+
+    if (priv->idx_size) free(priv->idx);
+    priv->idx_size = 0;
+    priv->idx_offset = 0;
+    priv->idx = NULL;
+
+    mp_msg(MSGT_HEADER, MSGL_INFO, 
+	    "AVI: ODML: Building odml index (%d superindexchunks)\n", priv->suidx_size);
+
+    // read the standard indices
+    for (cx = &priv->suidx[0], i=0; i<priv->suidx_size; cx++, i++) {
+	stream_reset(demuxer->stream);
+	for (j=0; j<cx->nEntriesInUse; j++) {
+	    int ret1, ret2;
+	    memset(&cx->stdidx[j], 0, 32);
+	    ret1 = stream_seek(demuxer->stream, (off_t)cx->aIndex[j].qwOffset);
+	    ret2 = stream_read(demuxer->stream, (char *)&cx->stdidx[j], 32);
+	    if (ret1 != 1 || ret2 != 32 || cx->stdidx[j].nEntriesInUse==0) {
+		// this is a broken file (probably incomplete) let the standard
+		// gen_index routine handle this
+		priv->isodml = 0;
+		priv->idx_size = 0;
+		mp_msg(MSGT_HEADER, MSGL_WARN,
+			"AVI: ODML: Broken (incomplete?) file detected. Will use traditional index\n");
+		goto freeout;
+	    }
+
+	    le2me_AVISTDIDXCHUNK(&cx->stdidx[j]);
+	    print_avistdindex_chunk(&cx->stdidx[j]);
+	    priv->idx_size += cx->stdidx[j].nEntriesInUse;
+	    cx->stdidx[j].aIndex = malloc(cx->stdidx[j].nEntriesInUse*sizeof(avistdindex_entry));
+	    stream_read(demuxer->stream, (char *)cx->stdidx[j].aIndex, 
+		    cx->stdidx[j].nEntriesInUse*sizeof(avistdindex_entry));
+	    for (k=0;k<cx->stdidx[j].nEntriesInUse; k++)
+		le2me_AVISTDIDXENTRY(&cx->stdidx[j].aIndex[k]);
+
+	    cx->stdidx[j].dwReserved3 = 0;
+
+	}
+    }
+
+    /*
+     * We convert the index by translating all entries into AVIINDEXENTRYs
+     * and sorting them by offset.  The result should be the same index
+     * we would get with -forceidx.
+     */
+
+    idx = priv->idx = malloc(priv->idx_size * sizeof (AVIINDEXENTRY));
+
+    for (cx = priv->suidx; cx != &priv->suidx[priv->suidx_size]; cx++) {
+	avistdindex_chunk *sic;
+	for (sic = cx->stdidx; sic != &cx->stdidx[cx->nEntriesInUse]; sic++) {
+	    avistdindex_entry *sie;
+	    for (sie = sic->aIndex; sie != &sic->aIndex[sic->nEntriesInUse]; sie++) {
+		uint64_t off = sic->qwBaseOffset + sie->dwOffset - 8;
+		memcpy(&idx->ckid, sic->dwChunkId, 4);
+		idx->dwChunkOffset = off;
+		idx->dwFlags = (off >> 32) << 16;
+		idx->dwChunkLength = sie->dwSize & 0x7fffffff;
+		idx->dwFlags |= (sie->dwSize&0x80000000)?0x0:AVIIF_KEYFRAME; // bit 31 denotes !keyframe
+		idx++;
+	    }
+	}
+    }
+    avi_idx_quicksort(priv->idx, 0, priv->idx_size-1);
+
+    /*
+       Hack to work around a "wrong" index in some divx odml files
+       (processor_burning.avi as an example)
+       They have ##dc on non keyframes but the ix00 tells us they are ##db.
+       Read the fcc of a non-keyframe vid frame and check it.
+     */
+
+    {
+	uint32_t id;
+	uint32_t db = 0;
+	stream_reset (demuxer->stream);
+
+	// find out the video stream id. I have seen files with 01db.
+	for (idx = &((AVIINDEXENTRY *)priv->idx)[0], i=0; i<priv->idx_size; i++, idx++){
+	    unsigned char res[2];
+	    if (odml_get_vstream_id(idx->ckid, res)) {
+		db = mmioFOURCC(res[0], res[1], 'd', 'b');
+		break;
+	    }
+	}
+
+	// find first non keyframe
+	for (idx = &((AVIINDEXENTRY *)priv->idx)[0], i=0; i<priv->idx_size; i++, idx++){
+	    if (!(idx->dwFlags & AVIIF_KEYFRAME) && idx->ckid == db) break;
+	}
+	if (i<priv->idx_size && db) {
+	    stream_seek(demuxer->stream, AVI_IDX_OFFSET(idx));
+	    id = stream_read_dword_le(demuxer->stream);
+	    if (id && id != db) // index fcc and real fcc differ? fix it.
+		for (idx = &((AVIINDEXENTRY *)priv->idx)[0], i=0; i<priv->idx_size; i++, idx++){
+		    if (!(idx->dwFlags & AVIIF_KEYFRAME) && idx->ckid == db)
+			idx->ckid = id;
+	    }
+	}
+    }
+
+    if (verbose>=2) print_index(priv->idx, priv->idx_size);
+
+    demuxer->movi_end=demuxer->stream->end_pos;
+
+freeout:
+
+    // free unneeded stuff
+    cx = &priv->suidx[0];
+    do {
+	for (j=0;j<cx->nEntriesInUse;j++)
+	    if (cx->stdidx[j].nEntriesInUse) free(cx->stdidx[j].aIndex);
+	free(cx->stdidx);
+
+    } while (cx++ != &priv->suidx[priv->suidx_size-1]);
+    free(priv->suidx);
+
+}
+
+/* Read a saved index file */
+if (index_file_load) {
+  FILE *fp;
+  char magic[7];
+  unsigned int i;
+
+  if ((fp = fopen(index_file_load, "r")) == NULL) {
+    mp_msg(MSGT_HEADER,MSGL_ERR, "Can't read index file %s: %s\n", index_file_load, strerror(errno));
+    goto gen_index;
+  }
+  fread(&magic, 6, 1, fp);
+  if (strncmp(magic, "MPIDX1", 6)) {
+    mp_msg(MSGT_HEADER,MSGL_ERR, "%s is not a valid MPlayer index file\n", index_file_load);
+    goto gen_index;
+  }
+  fread(&priv->idx_size, sizeof(priv->idx_size), 1, fp);
+  priv->idx=malloc(priv->idx_size*sizeof(AVIINDEXENTRY));
+  if (!priv->idx) {
+    mp_msg(MSGT_HEADER,MSGL_ERR, "Could not allocate memory for index data from %s\n", index_file_load);
+    priv->idx_size = 0;
+    goto gen_index;
+  }
+
+  for (i=0; i<priv->idx_size;i++) {
+    AVIINDEXENTRY *idx;
+    idx=&((AVIINDEXENTRY *)priv->idx)[i];
+    fread(idx, sizeof(AVIINDEXENTRY), 1, fp);
+    if (feof(fp)) {
+      mp_msg(MSGT_HEADER,MSGL_ERR, "Premature end of index file %s\n", index_file_load);
+      free(priv->idx);
+      priv->idx_size = 0;
+      goto gen_index;
+    }
+  }
+  fclose(fp);
+  mp_msg(MSGT_HEADER,MSGL_INFO, "Loaded index file: %s\n", index_file_load);
+}
+gen_index:
+if(index_mode>=2 || (priv->idx_size==0 && index_mode==1)){
+  // build index for file:
+  stream_reset(demuxer->stream);
+  stream_seek(demuxer->stream,demuxer->movi_start);
+  
+  priv->idx_pos=0;
+  priv->idx_size=0;
+  priv->idx=NULL;
+
+  while(1){
+    int id;
+    unsigned len;
+    off_t skip;
+    AVIINDEXENTRY* idx;
+    unsigned int c;
+    demuxer->filepos=stream_tell(demuxer->stream);
+    if(demuxer->filepos>=demuxer->movi_end && demuxer->movi_start<demuxer->movi_end) break;
+    id=stream_read_dword_le(demuxer->stream);
+    len=stream_read_dword_le(demuxer->stream);
+    if(id==mmioFOURCC('L','I','S','T') || id==mmioFOURCC('R', 'I', 'F', 'F')){
+      id=stream_read_dword_le(demuxer->stream); // list or RIFF type
+      continue;
+    }
+    if(stream_eof(demuxer->stream)) break;
+    if(!id || avi_stream_id(id)==100) goto skip_chunk; // bad ID (or padding?)
+
+    if(priv->idx_pos>=priv->idx_size){
+//      priv->idx_size+=32;
+      priv->idx_size+=1024; // +16kB
+      priv->idx=realloc(priv->idx,priv->idx_size*sizeof(AVIINDEXENTRY));
+      if(!priv->idx){priv->idx_pos=0; break;} // error!
+    }
+    idx=&((AVIINDEXENTRY *)priv->idx)[priv->idx_pos++];
+    idx->ckid=id;
+    idx->dwFlags=AVIIF_KEYFRAME; // FIXME
+    idx->dwFlags|=(demuxer->filepos>>16)&0xffff0000U;
+    idx->dwChunkOffset=(unsigned long)demuxer->filepos;
+    idx->dwChunkLength=len;
+    
+    c=stream_read_dword(demuxer->stream);
+
+    // Fix keyframes for DivX files:
+    if(idxfix_divx)
+      if(avi_stream_id(id)==idxfix_videostream){
+        switch(idxfix_divx){
+    	    case 3: c=stream_read_dword(demuxer->stream)<<5; //skip 32+5 bits for m$mpeg4v1
+    	    case 1: if(c&0x40000000) idx->dwFlags&=~AVIIF_KEYFRAME;break; // divx 3
+	    case 2: if(c==0x1B6) idx->dwFlags&=~AVIIF_KEYFRAME;break; // divx 4
+	}
+      }
+
+    // update status line:
+    { static off_t lastpos;
+      off_t pos;
+      off_t len=demuxer->movi_end-demuxer->movi_start;
+      if(len){
+          pos=100*(demuxer->filepos-demuxer->movi_start)/len; // %
+      } else {
+          pos=(demuxer->filepos-demuxer->movi_start)>>20; // MB
+      }
+      if(pos!=lastpos){
+          lastpos=pos;
+	  mp_msg(MSGT_HEADER,MSGL_STATUS,"Generating Index: %3lu %s     \r",
+		 (unsigned long)pos, len?"%":"MB");
+      }
+    }
+    mp_dbg(MSGT_HEADER,MSGL_DBG2,"%08X %08X %.4s %08X %X\n",(unsigned int)demuxer->filepos,id,(char *) &id,(int)c,(unsigned int) idx->dwFlags);
+#if 0
+    { unsigned char tmp[64];
+      int i;
+      stream_read(demuxer->stream,tmp,64);
+      printf("%.4s",&id);
+      for(i=0;i<64;i++) printf(" %02X",tmp[i]);
+      printf("\n");
+    }
+#endif
+skip_chunk:
+    skip=(len+1)&(~1UL); // total bytes in this chunk
+    stream_seek(demuxer->stream,8+demuxer->filepos+skip);
+  }
+  priv->idx_size=priv->idx_pos;
+  mp_msg(MSGT_HEADER,MSGL_INFO,"AVI: Generated index table for %d chunks!\n",priv->idx_size);
+  if(verbose>=2) print_index(priv->idx,priv->idx_size);
+
+  /* Write generated index to a file */
+  if (index_file_save) {
+    FILE *fp;
+    unsigned int i;
+
+    if ((fp=fopen(index_file_save, "w")) == NULL) {
+      mp_msg(MSGT_HEADER,MSGL_ERR, "Couldn't write index file %s: %s\n", index_file_save, strerror(errno));
+      return;
+    }
+    fwrite("MPIDX1", 6, 1, fp);
+    fwrite(&priv->idx_size, sizeof(priv->idx_size), 1, fp);
+    for (i=0; i<priv->idx_size; i++) {
+      AVIINDEXENTRY *idx = &((AVIINDEXENTRY *)priv->idx)[i];
+      fwrite(idx, sizeof(AVIINDEXENTRY), 1, fp);
+    }
+    fclose(fp);
+    mp_msg(MSGT_HEADER,MSGL_INFO, "Saved index file: %s\n", index_file_save);
+  }
+}
+}
+
+#undef MIN
+
+
diff -urN MPlayer-1.0pre5.orig/libmpdemux/cache2.c MPlayer-1.0pre5/libmpdemux/cache2.c
--- MPlayer-1.0pre5.orig/libmpdemux/cache2.c	2003-06-09 19:15:45 +0700
+++ MPlayer-1.0pre5/libmpdemux/cache2.c	2004-08-08 10:36:04 +0700
@@ -119,7 +119,11 @@
   
   if(read<s->min_filepos || read>s->max_filepos){
       // seek...
+#ifdef _LARGEFILE_SOURCE
+      mp_msg(MSGT_CACHE,MSGL_DBG2,"Out of boundaries... seeking to 0x%llX  \n",read);
+#else
       mp_msg(MSGT_CACHE,MSGL_DBG2,"Out of boundaries... seeking to 0x%X  \n",read);
+#endif
       // streaming: drop cache contents only if seeking backward or too much fwd:
       if(s->stream->type!=STREAMTYPE_STREAM ||
           read<s->min_filepos || read>=s->max_filepos+s->buffer_size)
@@ -263,13 +267,25 @@
     stream->cache_pid = CreateThread(NULL,0,ThreadProc,s,0,&threadId);
 #endif
     // wait until cache is filled at least prefill_init %
+#ifdef _LARGEFILE_SOURCE
+    mp_msg(MSGT_CACHE,MSGL_V,"CACHE_PRE_INIT: %lld [%lld] %lld  pre:%d  eof:%d  \n",
+	s->min_filepos,s->read_filepos,s->max_filepos,min,s->eof);
+#else
     mp_msg(MSGT_CACHE,MSGL_V,"CACHE_PRE_INIT: %d [%d] %d  pre:%d  eof:%d  \n",
 	s->min_filepos,s->read_filepos,s->max_filepos,min,s->eof);
+#endif
     while(s->read_filepos<s->min_filepos || s->max_filepos-s->read_filepos<min){
+#ifdef _LARGEFILE_SOURCE
+	mp_msg(MSGT_CACHE,MSGL_STATUS,"\rCache fill: %5.2f%% (%lld bytes)    ",
+	    100.0*(float)(s->max_filepos-s->read_filepos)/(float)(s->buffer_size),
+	    s->max_filepos-s->read_filepos
+	);
+#else
 	mp_msg(MSGT_CACHE,MSGL_STATUS,"\rCache fill: %5.2f%% (%d bytes)    ",
 	    100.0*(float)(s->max_filepos-s->read_filepos)/(float)(s->buffer_size),
 	    s->max_filepos-s->read_filepos
 	);
+#endif
 	if(s->eof) break; // file is smaller than prefill size
 	if(mp_input_check_interrupt(PREFILL_SLEEP_TIME))
 	  return 0;
@@ -321,7 +337,11 @@
   s=stream->cache_data;
 //  s->seek_lock=1;
   
+#ifdef _LARGEFILE_SOURCE 
+  mp_msg(MSGT_CACHE,MSGL_DBG2,"CACHE2_SEEK: 0x%llX <= 0x%llX (0x%llX) <= 0x%llX  \n",s->min_filepos,pos,s->read_filepos,s->max_filepos);
+#else
   mp_msg(MSGT_CACHE,MSGL_DBG2,"CACHE2_SEEK: 0x%X <= 0x%X (0x%X) <= 0x%X  \n",s->min_filepos,(int)pos,s->read_filepos,s->max_filepos);
+#endif
 
   newpos=pos/s->sector_size; newpos*=s->sector_size; // align
   stream->pos=s->read_filepos=newpos;
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_asf.c MPlayer-1.0pre5/libmpdemux/demux_asf.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_asf.c	2003-09-07 08:41:09 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_asf.c	2004-08-08 10:36:04 +0700
@@ -340,7 +340,11 @@
             return 1; // success
     }
     
+#ifdef _LARGEFILE_SOURCE 
+    mp_msg(MSGT_DEMUX,MSGL_V,"%08llX:  UNKNOWN TYPE  %02X %02X %02X %02X %02X...\n",demux->filepos,asf_packet[0],asf_packet[1],asf_packet[2],asf_packet[3],asf_packet[4]);
+#else
     mp_msg(MSGT_DEMUX,MSGL_V,"%08X:  UNKNOWN TYPE  %02X %02X %02X %02X %02X...\n",demux->filepos,asf_packet[0],asf_packet[1],asf_packet[2],asf_packet[3],asf_packet[4]);
+#endif
     return 0;
 }
 
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_audio.c MPlayer-1.0pre5/libmpdemux/demux_audio.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_audio.c	2004-04-16 03:48:27 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_audio.c	2004-08-08 10:36:04 +0700
@@ -226,7 +226,11 @@
   if(stream_tell(s) != demuxer->movi_start)
     stream_seek(s,demuxer->movi_start);
 
+#ifdef _LARGEFILE_SOURCE 
+  mp_msg(MSGT_DEMUX,MSGL_V,"demux_audio: audio data 0x%llX - 0x%llX  \n",demuxer->movi_start,demuxer->movi_end);
+#else
   mp_msg(MSGT_DEMUX,MSGL_V,"demux_audio: audio data 0x%X - 0x%X  \n",demuxer->movi_start,demuxer->movi_end);
+#endif
 
   return 1;
 }
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_avi.c MPlayer-1.0pre5/libmpdemux/demux_avi.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_avi.c	2004-03-17 20:50:36 +0600
+++ MPlayer-1.0pre5/libmpdemux/demux_avi.c	2004-08-08 10:36:04 +0700
@@ -215,7 +215,11 @@
 
     pos = (off_t)priv->idx_offset+AVI_IDX_OFFSET(idx);
     if((pos<demux->movi_start || pos>=demux->movi_end) && (demux->movi_end>demux->movi_start) && (demux->stream->flags & STREAM_SEEK)){
+#ifdef _LARGEFILE_SOURCE 
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkOffset out of range!   idx=0x%llX  \n",pos);
+#else
       mp_msg(MSGT_DEMUX,MSGL_V,"ChunkOffset out of range!   idx=0x%X  \n",pos);
+#endif
       continue;
     }
 #if 0
@@ -239,7 +243,7 @@
 //    if((len&(~1))!=(idx->dwChunkLength&(~1))){
 //    if((len)!=(idx->dwChunkLength)){
     if((len!=idx->dwChunkLength)&&((len+1)!=idx->dwChunkLength)){
-      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkSize mismatch! raw=%d idx=%ld  \n",len,idx->dwChunkLength);
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkSize mismatch! raw=%d idx=%d  \n",len,idx->dwChunkLength);
       if(len>0x200000 && idx->dwChunkLength>0x200000) continue; // both values bad :(
       len=choose_chunk_len(idx->dwChunkLength,len);
     }
@@ -327,7 +331,11 @@
 
     pos = priv->idx_offset+AVI_IDX_OFFSET(idx);
     if((pos<demux->movi_start || pos>=demux->movi_end) && (demux->movi_end>demux->movi_start)){
+#ifdef _LARGEFILE_SOURCE 
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkOffset out of range!  current=0x%llX  idx=0x%llX  \n",demux->filepos,pos);
+#else
       mp_msg(MSGT_DEMUX,MSGL_V,"ChunkOffset out of range!  current=0x%X  idx=0x%X  \n",demux->filepos,pos);
+#endif
       continue;
     }
 #if 0
@@ -350,7 +358,7 @@
     }
     len=stream_read_dword_le(demux->stream);
     if((len!=idx->dwChunkLength)&&((len+1)!=idx->dwChunkLength)){
-      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkSize mismatch! raw=%d idx=%ld  \n",len,idx->dwChunkLength);
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkSize mismatch! raw=%d idx=%d  \n",len,idx->dwChunkLength);
       if(len>0x200000 && idx->dwChunkLength>0x200000) continue; // both values bad :(
       len=choose_chunk_len(idx->dwChunkLength,len);
     }
@@ -572,7 +580,7 @@
 	asamples+=(len+priv->audio_block_size-1)/priv->audio_block_size;
       }
     }
-    mp_msg(MSGT_DEMUX,MSGL_V,"AVI video size=%lu (%lu) audio size=%lu (%lu)\n",vsize,vsamples,asize,asamples);
+    mp_msg(MSGT_DEMUX,MSGL_V,"AVI video size=%u (%u) audio size=%u (%u)\n",vsize,vsamples,asize,asamples);
     priv->numberofframes=vsamples;
     sh_video->i_bps=((float)vsize/(float)vsamples)*(float)sh_video->video.dwRate/(float)sh_video->video.dwScale;
     if(sh_audio) sh_audio->i_bps=((float)asize/(float)asamples)*(float)sh_audio->audio.dwRate/(float)sh_audio->audio.dwScale;
@@ -599,11 +607,11 @@
       }
     }
     vsize=demuxer->movi_end-demuxer->movi_start-asize-8*priv->numberofframes;
-    mp_msg(MSGT_DEMUX,MSGL_V,"AVI video size=%lu (%lu)  audio size=%lu\n",vsize,priv->numberofframes,asize);
+    mp_msg(MSGT_DEMUX,MSGL_V,"AVI video size=%u (%u)  audio size=%u\n",vsize,priv->numberofframes,asize);
     sh_video->i_bps=(float)vsize/(sh_video->frametime*priv->numberofframes);
   }
 
-  mp_msg(MSGT_DEMUX,MSGL_INFO,"VIDEO:  [%.4s]  %ldx%ld  %dbpp  %5.3f fps  %5.1f kbps (%4.1f kbyte/s)\n",
+  mp_msg(MSGT_DEMUX,MSGL_INFO,"VIDEO:  [%.4s]  %dx%d  %dbpp  %5.3f fps  %5.1f kbps (%4.1f kbyte/s)\n",
     (char *)&sh_video->bih->biCompression,
     sh_video->bih->biWidth,
     sh_video->bih->biHeight,
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_avi.c.orig MPlayer-1.0pre5/libmpdemux/demux_avi.c.orig
--- MPlayer-1.0pre5.orig/libmpdemux/demux_avi.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_avi.c.orig	2004-03-17 20:50:36 +0600
@@ -0,0 +1,860 @@
+//  AVI file parser for DEMUXER v2.9  by A'rpi/ESP-team
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "mp_msg.h"
+#include "help_mp.h"
+
+#include "stream.h"
+#include "demuxer.h"
+#include "stheader.h"
+
+#include "aviheader.h"
+
+// PTS:  0=interleaved  1=BPS-based
+int pts_from_bps=1;
+
+// Select ds from ID
+demux_stream_t* demux_avi_select_stream(demuxer_t *demux,unsigned int id){
+  int stream_id=avi_stream_id(id);
+
+//  printf("demux_avi_select_stream(%d)  {a:%d/v:%d}\n",stream_id,
+//       demux->audio->id,demux->video->id);
+
+  if(demux->video->id==-1)
+    if(demux->v_streams[stream_id])
+        demux->video->id=stream_id;
+
+  if(demux->audio->id==-1)
+    if(demux->a_streams[stream_id])
+        demux->audio->id=stream_id;
+
+  if(stream_id==demux->audio->id){
+      if(!demux->audio->sh){
+        sh_audio_t* sh;
+	avi_priv_t *priv=demux->priv;
+        sh=demux->audio->sh=demux->a_streams[stream_id];
+        mp_msg(MSGT_DEMUX,MSGL_V,"Auto-selected AVI audio ID = %d\n",demux->audio->id);
+	if(sh->wf){
+	  priv->audio_block_size=sh->wf->nBlockAlign;
+	  if(!priv->audio_block_size){
+	    // for PCM audio we can calculate the blocksize:
+	    if(sh->format==1)
+		priv->audio_block_size=sh->wf->nChannels*(sh->wf->wBitsPerSample/8);
+	    else
+		priv->audio_block_size=1; // hope the best...
+	  } else {
+	    // workaround old mencoder's bug:
+	    if(sh->audio.dwSampleSize==1 && sh->audio.dwScale==1 &&
+	       (sh->wf->nBlockAlign==1152 || sh->wf->nBlockAlign==576)){
+		mp_msg(MSGT_DEMUX,MSGL_WARN,"AVI: Workarounding CBR-MP3 nBlockAlign header bug!\n");
+		priv->audio_block_size=1;
+	    }
+	  }
+	} else {
+	  priv->audio_block_size=sh->audio.dwSampleSize;
+	}
+//	printf("&&&&& setting blocksize to %d &&&&&\n",priv->audio_block_size);
+      }
+      return demux->audio;
+  }
+  if(stream_id==demux->video->id){
+      if(!demux->video->sh){
+        demux->video->sh=demux->v_streams[stream_id];
+        mp_msg(MSGT_DEMUX,MSGL_V,"Auto-selected AVI video ID = %d\n",demux->video->id);
+      }
+      return demux->video;
+  }
+  if(id!=mmioFOURCC('J','U','N','K')){
+     // unknown
+     mp_msg(MSGT_DEMUX,MSGL_DBG2,"Unknown chunk: %.4s (%X)\n",(char *) &id,id);
+     //abort();
+  }
+  return NULL;
+}
+
+static int valid_fourcc(unsigned int id){
+    unsigned char* fcc=(unsigned char*)(&id);
+#define FCC_CHR_CHECK(x) (x<48 || x>=96)
+    if(FCC_CHR_CHECK(fcc[0])) return 0;
+    if(FCC_CHR_CHECK(fcc[1])) return 0;
+    if(FCC_CHR_CHECK(fcc[2])) return 0;
+    if(FCC_CHR_CHECK(fcc[3])) return 0;
+    return 1;
+#undef FCC_CHR_CHECK
+}
+
+static int choose_chunk_len(unsigned int len1,unsigned int len2){
+    // len1 has a bit more priority than len2. len1!=len2
+    // Note: this is a first-idea-logic, may be wrong. comments welcomed.
+
+    // prefer small frames rather than 0
+    if(!len1) return (len2>0x80000) ? len1 : len2;
+    if(!len2) return (len1>0x100000) ? len2 : len1;
+
+    // choose the smaller value:
+    return (len1<len2)? len1 : len2;
+}
+
+static int demux_avi_read_packet(demuxer_t *demux,demux_stream_t *ds,unsigned int id,unsigned int len,int idxpos,int flags){
+  avi_priv_t *priv=demux->priv;
+  int skip;
+  float pts=0;
+  
+  mp_dbg(MSGT_DEMUX,MSGL_DBG3,"demux_avi.read_packet: %X\n",id);
+
+  if(ds==demux->audio){
+      if(priv->pts_corrected==0){
+//          printf("\rYYY-A  A: %5.3f  V: %5.3f  \n",priv->avi_audio_pts,priv->avi_video_pts);
+          if(priv->pts_has_video){
+	      // we have video pts now
+	      float delay=0;
+	      if(((sh_audio_t*)(ds->sh))->wf->nAvgBytesPerSec)
+	          delay=(float)priv->pts_corr_bytes/((sh_audio_t*)(ds->sh))->wf->nAvgBytesPerSec;
+	      mp_msg(MSGT_DEMUX,MSGL_V,"XXX initial  v_pts=%5.3f  a_pos=%d (%5.3f) \n",priv->avi_audio_pts,priv->pts_corr_bytes,delay);
+	      //priv->pts_correction=-priv->avi_audio_pts+delay;
+	      priv->pts_correction=delay-priv->avi_audio_pts;
+	      priv->avi_audio_pts+=priv->pts_correction;
+	      priv->pts_corrected=1;
+	  } else
+	      priv->pts_corr_bytes+=len;
+      }
+      if(pts_from_bps){
+	  pts = priv->audio_block_no *
+	    (float)((sh_audio_t*)demux->audio->sh)->audio.dwScale /
+	    (float)((sh_audio_t*)demux->audio->sh)->audio.dwRate;
+      } else
+          pts=priv->avi_audio_pts; //+priv->pts_correction;
+      priv->avi_audio_pts=0;
+      // update blockcount:
+      priv->audio_block_no+=priv->audio_block_size ?
+	((len+priv->audio_block_size-1)/priv->audio_block_size) : 1;
+//      printf("\raudio_block_no=%d      \n",priv->audio_block_no);
+  } else 
+  if(ds==demux->video){
+     // video
+     if(priv->skip_video_frames>0){
+       // drop frame (seeking)
+       --priv->skip_video_frames;
+       ds=NULL;
+     }
+
+     pts = priv->avi_video_pts = priv->video_pack_no *
+         (float)((sh_video_t*)demux->video->sh)->video.dwScale /
+	 (float)((sh_video_t*)demux->video->sh)->video.dwRate;
+//          printf("\rYYY-V  A: %5.3f  V: %5.3f  \n",priv->avi_audio_pts,priv->avi_video_pts);
+
+     priv->avi_audio_pts=priv->avi_video_pts+priv->pts_correction;
+     priv->pts_has_video=1;
+
+     if(ds) ++priv->video_pack_no;
+
+     //printf("read  pack_no: %d  pts %5.3f  \n",demux->video->pack_no+demux->video->packs,pts);
+  }
+  
+  skip=(len+1)&(~1); // total bytes in this chunk
+  
+  if(ds){
+    mp_dbg(MSGT_DEMUX,MSGL_DBG2,"DEMUX_AVI: Read %d data bytes from packet %04X\n",len,id);
+//    printf("READ[%c] %5.3f  (%d)   \n",ds==demux->video?'V':'A',pts,len);
+    ds_read_packet(ds,demux->stream,len,pts,idxpos,flags);
+    skip-=len;
+  }
+  if(skip){
+    mp_dbg(MSGT_DEMUX,MSGL_DBG2,"DEMUX_AVI: Skipping %d bytes from packet %04X\n",skip,id);
+    stream_skip(demux->stream,skip);
+  }
+  return ds?1:0;
+}
+
+// return value:
+//     0 = EOF or no stream found
+//     1 = successfully read a packet
+int demux_avi_fill_buffer(demuxer_t *demux){
+avi_priv_t *priv=demux->priv;
+unsigned int id=0;
+unsigned int len;
+//int max_packs=128;
+int ret=0;
+demux_stream_t *ds;
+
+do{
+  int flags=1;
+  AVIINDEXENTRY *idx=NULL;
+#if 0
+  demux->filepos=stream_tell(demux->stream);
+  if(demux->filepos>=demux->movi_end){
+          demux->stream->eof=1;
+          return 0;
+  }
+  if(stream_eof(demux->stream)) return 0;
+#endif
+  if(priv->idx_size>0 && priv->idx_pos<priv->idx_size){
+    off_t pos;
+    
+    //if(priv->idx_pos<0) printf("Fatal! idx_pos=%d\n",priv->idx_pos);
+    
+    idx=&((AVIINDEXENTRY *)priv->idx)[priv->idx_pos++];
+    
+    //printf("[%d]",priv->idx_pos);fflush(stdout);
+    
+    //stream_seek(demux->stream,idx.dwChunkOffset);
+    //printf("IDX  pos=%X  idx.pos=%X  idx.size=%X  idx.flags=%X\n",demux->filepos,
+    //  pos-4,idx->dwChunkLength,idx->dwFlags);
+    if(idx->dwFlags&AVIIF_LIST){
+      // LIST
+      continue;
+    }
+    if(!demux_avi_select_stream(demux,idx->ckid)){
+      mp_dbg(MSGT_DEMUX,MSGL_DBG3,"Skip chunk %.4s (0x%X)  \n",(char *)&idx->ckid,(unsigned int)idx->ckid);
+      continue; // skip this chunk
+    }
+
+    pos = (off_t)priv->idx_offset+AVI_IDX_OFFSET(idx);
+    if((pos<demux->movi_start || pos>=demux->movi_end) && (demux->movi_end>demux->movi_start) && (demux->stream->flags & STREAM_SEEK)){
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkOffset out of range!   idx=0x%X  \n",pos);
+      continue;
+    }
+#if 0
+    if(pos!=demux->filepos){
+      mp_msg(MSGT_DEMUX,MSGL_V,"Warning! pos=0x%X  idx.pos=0x%X  diff=%d   \n",demux->filepos,pos,pos-demux->filepos);
+    }
+#endif
+    stream_seek(demux->stream,pos);
+    demux->filepos=stream_tell(demux->stream);
+    id=stream_read_dword_le(demux->stream);
+    if(stream_eof(demux->stream)) return 0; // EOF!
+    
+    if(id!=idx->ckid){
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkID mismatch! raw=%.4s idx=%.4s  \n",(char *)&id,(char *)&idx->ckid);
+      if(valid_fourcc(idx->ckid))
+          id=idx->ckid;	// use index if valid
+      else
+          if(!valid_fourcc(id)) continue; // drop chunk if both id and idx bad
+    }
+    len=stream_read_dword_le(demux->stream);
+//    if((len&(~1))!=(idx->dwChunkLength&(~1))){
+//    if((len)!=(idx->dwChunkLength)){
+    if((len!=idx->dwChunkLength)&&((len+1)!=idx->dwChunkLength)){
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkSize mismatch! raw=%d idx=%ld  \n",len,idx->dwChunkLength);
+      if(len>0x200000 && idx->dwChunkLength>0x200000) continue; // both values bad :(
+      len=choose_chunk_len(idx->dwChunkLength,len);
+    }
+    if(!(idx->dwFlags&AVIIF_KEYFRAME)) flags=0;
+  } else {
+    demux->filepos=stream_tell(demux->stream);
+    if(demux->filepos>=demux->movi_end && demux->movi_end>demux->movi_start && (demux->stream->flags & STREAM_SEEK)){
+          demux->stream->eof=1;
+          return 0;
+    }
+    id=stream_read_dword_le(demux->stream);
+    len=stream_read_dword_le(demux->stream);
+    if(stream_eof(demux->stream)) return 0; // EOF!
+    
+    if(id==mmioFOURCC('L','I','S','T') || id==mmioFOURCC('R', 'I', 'F', 'F')){
+      id=stream_read_dword_le(demux->stream); // list or RIFF type
+      continue;
+    }
+  }
+
+  ds=demux_avi_select_stream(demux,id);
+  if(ds)
+    if(ds->packs+1>=MAX_PACKS || ds->bytes+len>=MAX_PACK_BYTES){
+	// this packet will cause a buffer overflow, switch to -ni mode!!!
+	mp_msg(MSGT_DEMUX,MSGL_WARN,MSGTR_SwitchToNi);
+	if(priv->idx_size>0){
+	    // has index
+	    demux->type=DEMUXER_TYPE_AVI_NI;
+	    --priv->idx_pos; // hack
+	} else {
+	    // no index
+	    demux->type=DEMUXER_TYPE_AVI_NINI;
+	    priv->idx_pos=demux->filepos; // hack
+	}
+	priv->idx_pos_v=priv->idx_pos_a=priv->idx_pos;
+	// quit now, we can't even (no enough buffer memory) read this packet :(
+	return -1;
+    }
+  
+  ret=demux_avi_read_packet(demux,ds,id,len,priv->idx_pos-1,flags);
+//      if(!ret && priv->skip_video_frames<=0)
+//        if(--max_packs==0){
+//          demux->stream->eof=1;
+//          mp_msg(MSGT_DEMUX,MSGL_ERR,MSGTR_DoesntContainSelectedStream);
+//          return 0;
+//        }
+} while(ret!=1);
+  return 1;
+}
+
+
+// return value:
+//     0 = EOF or no stream found
+//     1 = successfully read a packet
+int demux_avi_fill_buffer_ni(demuxer_t *demux,demux_stream_t* ds){
+avi_priv_t *priv=demux->priv;
+unsigned int id=0;
+unsigned int len;
+//int max_packs=128;
+int ret=0;
+
+do{
+  int flags=1;
+  AVIINDEXENTRY *idx=NULL;
+  int idx_pos=0;
+  demux->filepos=stream_tell(demux->stream);
+  
+  if(ds==demux->video) idx_pos=priv->idx_pos_v++; else
+  if(ds==demux->audio) idx_pos=priv->idx_pos_a++; else
+                       idx_pos=priv->idx_pos++;
+  
+  if(priv->idx_size>0 && idx_pos<priv->idx_size){
+    off_t pos;
+    idx=&((AVIINDEXENTRY *)priv->idx)[idx_pos];
+//    idx=&priv->idx[idx_pos];
+    
+    if(idx->dwFlags&AVIIF_LIST){
+      // LIST
+      continue;
+    }
+    if(ds && demux_avi_select_stream(demux,idx->ckid)!=ds){
+      mp_dbg(MSGT_DEMUX,MSGL_DBG3,"Skip chunk %.4s (0x%X)  \n",(char *)&idx->ckid,(unsigned int)idx->ckid);
+      continue; // skip this chunk
+    }
+
+    pos = priv->idx_offset+AVI_IDX_OFFSET(idx);
+    if((pos<demux->movi_start || pos>=demux->movi_end) && (demux->movi_end>demux->movi_start)){
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkOffset out of range!  current=0x%X  idx=0x%X  \n",demux->filepos,pos);
+      continue;
+    }
+#if 0
+    if(pos!=demux->filepos){
+      mp_msg(MSGT_DEMUX,MSGL_V,"Warning! pos=0x%X  idx.pos=0x%X  diff=%d   \n",demux->filepos,pos,pos-demux->filepos);
+    }
+#endif
+    stream_seek(demux->stream,pos);
+
+    id=stream_read_dword_le(demux->stream);
+
+    if(stream_eof(demux->stream)) return 0;
+
+    if(id!=idx->ckid){
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkID mismatch! raw=%.4s idx=%.4s  \n",(char *)&id,(char *)&idx->ckid);
+      if(valid_fourcc(idx->ckid))
+          id=idx->ckid;	// use index if valid
+      else
+          if(!valid_fourcc(id)) continue; // drop chunk if both id and idx bad
+    }
+    len=stream_read_dword_le(demux->stream);
+    if((len!=idx->dwChunkLength)&&((len+1)!=idx->dwChunkLength)){
+      mp_msg(MSGT_DEMUX,MSGL_V,"ChunkSize mismatch! raw=%d idx=%ld  \n",len,idx->dwChunkLength);
+      if(len>0x200000 && idx->dwChunkLength>0x200000) continue; // both values bad :(
+      len=choose_chunk_len(idx->dwChunkLength,len);
+    }
+    if(!(idx->dwFlags&AVIIF_KEYFRAME)) flags=0;
+  } else return 0;
+  ret=demux_avi_read_packet(demux,demux_avi_select_stream(demux,id),id,len,idx_pos,flags);
+//      if(!ret && priv->skip_video_frames<=0)
+//        if(--max_packs==0){
+//          demux->stream->eof=1;
+//          mp_msg(MSGT_DEMUX,MSGL_ERR,MSGTR_DoesntContainSelectedStream);
+//          return 0;
+//        }
+} while(ret!=1);
+  return 1;
+}
+
+
+// return value:
+//     0 = EOF or no stream found
+//     1 = successfully read a packet
+int demux_avi_fill_buffer_nini(demuxer_t *demux,demux_stream_t* ds){
+avi_priv_t *priv=demux->priv;
+unsigned int id=0;
+unsigned int len;
+int ret=0;
+off_t *fpos=NULL;
+
+  if(ds==demux->video) fpos=&priv->idx_pos_v; else
+  if(ds==demux->audio) fpos=&priv->idx_pos_a; else
+  return 0;
+
+  stream_seek(demux->stream,fpos[0]);
+
+do{
+
+  demux->filepos=stream_tell(demux->stream);
+  if(demux->filepos>=demux->movi_end && (demux->movi_end>demux->movi_start)){
+          //demux->stream->eof=1;
+	  ds->eof=1;
+          return 0;
+  }
+
+  id=stream_read_dword_le(demux->stream);
+  len=stream_read_dword_le(demux->stream);
+
+  if(stream_eof(demux->stream)) return 0;
+  
+  if(id==mmioFOURCC('L','I','S','T')){
+      id=stream_read_dword_le(demux->stream);      // list type
+      continue;
+  }
+  
+  if(id==mmioFOURCC('R','I','F','F')){
+      mp_msg(MSGT_DEMUX,MSGL_V,"additional RIFF header...\n");
+      id=stream_read_dword_le(demux->stream);      // "AVIX"
+      continue;
+  }
+  
+  if(ds==demux_avi_select_stream(demux,id)){
+    // read it!
+    ret=demux_avi_read_packet(demux,ds,id,len,priv->idx_pos-1,0);
+  } else {
+    // skip it!
+    int skip=(len+1)&(~1); // total bytes in this chunk
+    stream_skip(demux->stream,skip);
+  }
+  
+} while(ret!=1);
+  fpos[0]=stream_tell(demux->stream);
+  return 1;
+}
+
+// AVI demuxer parameters:
+int index_mode=-1;  // -1=untouched  0=don't use index  1=use (geneate) index
+char *index_file_save = NULL, *index_file_load = NULL;
+int force_ni=0;     // force non-interleaved AVI parsing
+
+void read_avi_header(demuxer_t *demuxer,int index_mode);
+
+demuxer_t* demux_open_avi(demuxer_t* demuxer){
+    demux_stream_t *d_audio=demuxer->audio;
+    demux_stream_t *d_video=demuxer->video;
+    sh_audio_t *sh_audio=NULL;
+    sh_video_t *sh_video=NULL;
+    avi_priv_t* priv=malloc(sizeof(avi_priv_t));
+
+  // priv struct:
+  priv->avi_audio_pts=priv->avi_video_pts=0.0f;
+  priv->pts_correction=0.0f;
+  priv->skip_video_frames=0;
+  priv->pts_corr_bytes=0;
+  priv->pts_has_video=priv->pts_corrected=0;
+  priv->video_pack_no=0;
+  priv->audio_block_no=0;
+  priv->audio_block_size=0;
+  priv->isodml = 0;
+  priv->suidx_size = 0;
+  priv->suidx = NULL;
+
+  demuxer->priv=(void*)priv;
+
+  //---- AVI header:
+  read_avi_header(demuxer,(demuxer->stream->flags & STREAM_SEEK_BW)?index_mode:-2);
+  
+  if(demuxer->audio->id>=0 && !demuxer->a_streams[demuxer->audio->id]){
+      mp_msg(MSGT_DEMUX,MSGL_WARN,"AVI: invalid audio stream ID: %d - ignoring (nosound)\n",demuxer->audio->id);
+      demuxer->audio->id=-2; // disabled
+  }
+  if(demuxer->video->id>=0 && !demuxer->v_streams[demuxer->video->id]){
+      mp_msg(MSGT_DEMUX,MSGL_WARN,"AVI: invalid video stream ID: %d - ignoring (using default)\n",demuxer->video->id);
+      demuxer->video->id=-1; // autodetect
+  }
+  
+  stream_reset(demuxer->stream);
+  stream_seek(demuxer->stream,demuxer->movi_start);
+  priv->idx_pos=0;
+  priv->idx_pos_a=0;
+  priv->idx_pos_v=0;
+  if(priv->idx_size>1){
+    // decide index format:
+#if 1
+    if((AVI_IDX_OFFSET(&((AVIINDEXENTRY *)priv->idx)[0])<demuxer->movi_start ||
+        AVI_IDX_OFFSET(&((AVIINDEXENTRY *)priv->idx)[1])<demuxer->movi_start )&& !priv->isodml)
+      priv->idx_offset=demuxer->movi_start-4;
+    else
+      priv->idx_offset=0;
+#else
+    if(AVI_IDX_OFFSET(&((AVIINDEXENTRY *)priv->idx)[0])<demuxer->movi_start)
+      priv->idx_offset=demuxer->movi_start-4;
+    else
+      priv->idx_offset=0;
+#endif
+    mp_msg(MSGT_DEMUX,MSGL_V,"AVI index offset: 0x%X (movi=0x%X idx0=0x%X idx1=0x%X)\n",
+	    (int)priv->idx_offset,(int)demuxer->movi_start,
+	    (int)((AVIINDEXENTRY *)priv->idx)[0].dwChunkOffset,
+	    (int)((AVIINDEXENTRY *)priv->idx)[1].dwChunkOffset);
+  }
+//  demuxer->endpos=avi_header.movi_end;
+  
+  if(priv->idx_size>0){
+      // check that file is non-interleaved:
+      int i;
+      off_t a_pos=-1;
+      off_t v_pos=-1;
+      for(i=0;i<priv->idx_size;i++){
+        AVIINDEXENTRY* idx=&((AVIINDEXENTRY *)priv->idx)[i];
+        demux_stream_t* ds=demux_avi_select_stream(demuxer,idx->ckid);
+        off_t pos = priv->idx_offset + AVI_IDX_OFFSET(idx);
+        if(a_pos==-1 && ds==demuxer->audio){
+          a_pos=pos;
+          if(v_pos!=-1) break;
+        }
+        if(v_pos==-1 && ds==demuxer->video){
+          v_pos=pos;
+          if(a_pos!=-1) break;
+        }
+      }
+      if(v_pos==-1){
+        mp_msg(MSGT_DEMUX,MSGL_ERR,"AVI_NI: " MSGTR_MissingVideoStream);
+	return NULL;
+      }
+      if(a_pos==-1){
+        mp_msg(MSGT_DEMUX,MSGL_INFO,"AVI_NI: " MSGTR_MissingAudioStream);
+        sh_audio=NULL;
+      } else {
+        if(force_ni || abs(a_pos-v_pos)>0x100000){  // distance > 1MB
+          mp_msg(MSGT_DEMUX,MSGL_INFO,MSGTR_NI_Message,force_ni?MSGTR_NI_Forced:MSGTR_NI_Detected);
+          demuxer->type=DEMUXER_TYPE_AVI_NI; // HACK!!!!
+	  pts_from_bps=1; // force BPS sync!
+        }
+      }
+  } else {
+      // no index
+      if(force_ni){
+          mp_msg(MSGT_DEMUX,MSGL_INFO,MSGTR_UsingNINI);
+          demuxer->type=DEMUXER_TYPE_AVI_NINI; // HACK!!!!
+	  priv->idx_pos_a=
+	  priv->idx_pos_v=demuxer->movi_start;
+	  pts_from_bps=1; // force BPS sync!
+      }
+      demuxer->seekable=0;
+  }
+  if(!ds_fill_buffer(d_video)){
+    mp_msg(MSGT_DEMUX,MSGL_ERR,"AVI: " MSGTR_MissingVideoStreamBug);
+    return NULL;
+  }
+  sh_video=d_video->sh;sh_video->ds=d_video;
+  if(d_audio->id!=-2){
+    mp_msg(MSGT_DEMUX,MSGL_V,"AVI: Searching for audio stream (id:%d)\n",d_audio->id);
+    if(!priv->audio_streams || !ds_fill_buffer(d_audio)){
+      mp_msg(MSGT_DEMUX,MSGL_INFO,"AVI: " MSGTR_MissingAudioStream);
+      sh_audio=NULL;
+    } else {
+      sh_audio=d_audio->sh;sh_audio->ds=d_audio;
+      sh_audio->format=sh_audio->wf->wFormatTag;
+    }
+  }
+  // calc. FPS:
+  sh_video->fps=(float)sh_video->video.dwRate/(float)sh_video->video.dwScale;
+  sh_video->frametime=(float)sh_video->video.dwScale/(float)sh_video->video.dwRate;
+
+  // calculating audio/video bitrate:
+  if(priv->idx_size>0){
+    // we have index, let's count 'em!
+    size_t vsize=0;
+    size_t asize=0;
+    size_t vsamples=0;
+    size_t asamples=0;
+    int i;
+    for(i=0;i<priv->idx_size;i++){ 
+      int id=avi_stream_id(((AVIINDEXENTRY *)priv->idx)[i].ckid);
+      int len=((AVIINDEXENTRY *)priv->idx)[i].dwChunkLength;
+      if(sh_video->ds->id == id) {
+        vsize+=len;
+        ++vsamples;
+      }
+      else if(sh_audio && sh_audio->ds->id == id) {
+        asize+=len;
+	asamples+=(len+priv->audio_block_size-1)/priv->audio_block_size;
+      }
+    }
+    mp_msg(MSGT_DEMUX,MSGL_V,"AVI video size=%lu (%lu) audio size=%lu (%lu)\n",vsize,vsamples,asize,asamples);
+    priv->numberofframes=vsamples;
+    sh_video->i_bps=((float)vsize/(float)vsamples)*(float)sh_video->video.dwRate/(float)sh_video->video.dwScale;
+    if(sh_audio) sh_audio->i_bps=((float)asize/(float)asamples)*(float)sh_audio->audio.dwRate/(float)sh_audio->audio.dwScale;
+  } else {
+    // guessing, results may be inaccurate:
+    size_t vsize;
+    size_t asize=0;
+
+    if((priv->numberofframes=sh_video->video.dwLength)<=1)
+      // bad video header, try to get number of frames from audio
+      if(sh_audio && sh_audio->wf->nAvgBytesPerSec) priv->numberofframes=sh_video->fps*sh_audio->audio.dwLength/sh_audio->audio.dwRate*sh_audio->audio.dwScale;
+    if(priv->numberofframes<=1){
+      mp_msg(MSGT_SEEK,MSGL_WARN,MSGTR_CouldntDetFNo);
+      priv->numberofframes=0;
+    }          
+
+    if(sh_audio){
+      if(sh_audio->wf->nAvgBytesPerSec && sh_audio->audio.dwSampleSize!=1){
+        asize=(float)sh_audio->wf->nAvgBytesPerSec*sh_audio->audio.dwLength*sh_audio->audio.dwScale/sh_audio->audio.dwRate;
+        sh_audio->i_bps=sh_audio->wf->nAvgBytesPerSec;
+      } else {
+        asize=sh_audio->audio.dwLength;
+        sh_audio->i_bps=(float)asize/(sh_video->frametime*priv->numberofframes);
+      }
+    }
+    vsize=demuxer->movi_end-demuxer->movi_start-asize-8*priv->numberofframes;
+    mp_msg(MSGT_DEMUX,MSGL_V,"AVI video size=%lu (%lu)  audio size=%lu\n",vsize,priv->numberofframes,asize);
+    sh_video->i_bps=(float)vsize/(sh_video->frametime*priv->numberofframes);
+  }
+
+  mp_msg(MSGT_DEMUX,MSGL_INFO,"VIDEO:  [%.4s]  %ldx%ld  %dbpp  %5.3f fps  %5.1f kbps (%4.1f kbyte/s)\n",
+    (char *)&sh_video->bih->biCompression,
+    sh_video->bih->biWidth,
+    sh_video->bih->biHeight,
+    sh_video->bih->biBitCount,
+    sh_video->fps,
+    sh_video->i_bps*0.008f,
+    sh_video->i_bps/1024.0f );
+
+  return demuxer;
+  
+}
+
+//extern float initial_pts_delay;
+extern void resync_audio_stream(sh_audio_t *sh_audio);
+
+void demux_seek_avi(demuxer_t *demuxer,float rel_seek_secs,int flags){
+    avi_priv_t *priv=demuxer->priv;
+    demux_stream_t *d_audio=demuxer->audio;
+    demux_stream_t *d_video=demuxer->video;
+    sh_audio_t *sh_audio=d_audio->sh;
+    sh_video_t *sh_video=d_video->sh;
+    float skip_audio_secs=0;
+
+  //FIXME: OFF_T - Didn't check AVI case yet (avi files can't be >2G anyway?)
+  //================= seek in AVI ==========================
+    int rel_seek_frames=rel_seek_secs*sh_video->fps;
+    int video_chunk_pos=d_video->pos;
+    int i;
+
+      if(flags&1){
+	// seek absolute
+	video_chunk_pos=0;
+      }
+      
+      if(flags&2){
+	rel_seek_frames=rel_seek_secs*priv->numberofframes;
+      }
+    
+      priv->skip_video_frames=0;
+      priv->avi_audio_pts=0;
+
+// ------------ STEP 1: find nearest video keyframe chunk ------------
+      // find nearest video keyframe chunk pos:
+      if(rel_seek_frames>0){
+        // seek forward
+        while(video_chunk_pos<priv->idx_size-1){
+          int id=((AVIINDEXENTRY *)priv->idx)[video_chunk_pos].ckid;
+          if(avi_stream_id(id)==d_video->id){  // video frame
+            if((--rel_seek_frames)<0 && ((AVIINDEXENTRY *)priv->idx)[video_chunk_pos].dwFlags&AVIIF_KEYFRAME) break;
+          }
+          ++video_chunk_pos;
+        }
+      } else {
+        // seek backward
+        while(video_chunk_pos>0){
+          int id=((AVIINDEXENTRY *)priv->idx)[video_chunk_pos].ckid;
+          if(avi_stream_id(id)==d_video->id){  // video frame
+            if((++rel_seek_frames)>0 && ((AVIINDEXENTRY *)priv->idx)[video_chunk_pos].dwFlags&AVIIF_KEYFRAME) break;
+          }
+          --video_chunk_pos;
+        }
+      }
+      priv->idx_pos_a=priv->idx_pos_v=priv->idx_pos=video_chunk_pos;
+
+      // re-calc video pts:
+      d_video->pack_no=0;
+      for(i=0;i<video_chunk_pos;i++){
+          int id=((AVIINDEXENTRY *)priv->idx)[i].ckid;
+          if(avi_stream_id(id)==d_video->id) ++d_video->pack_no;
+      }
+      priv->video_pack_no=
+      sh_video->num_frames=sh_video->num_frames_decoded=d_video->pack_no;
+      priv->avi_video_pts=d_video->pack_no*(float)sh_video->video.dwScale/(float)sh_video->video.dwRate;
+      d_video->pos=video_chunk_pos;
+      
+      mp_msg(MSGT_SEEK,MSGL_DBG2,"V_SEEK:  pack=%d  pts=%5.3f  chunk=%d  \n",d_video->pack_no,priv->avi_video_pts,video_chunk_pos);
+
+// ------------ STEP 2: seek audio, find the right chunk & pos ------------
+
+      d_audio->pack_no=0;
+//      d_audio->block_no=0;
+      priv->audio_block_no=0;
+      d_audio->dpos=0;
+
+      if(sh_audio){
+        int i;
+        int len=0;
+	int skip_audio_bytes=0;
+	int curr_audio_pos=-1;
+	int audio_chunk_pos=-1;
+	int chunk_max=(demuxer->type==DEMUXER_TYPE_AVI)?video_chunk_pos:priv->idx_size;
+	
+	if(sh_audio->audio.dwSampleSize){
+	    // constant rate audio stream
+#if 0
+	    int align;
+	    curr_audio_pos=(priv->avi_video_pts) * sh_audio->wf->nAvgBytesPerSec;
+	    if(curr_audio_pos<0)curr_audio_pos=0;
+	    align=sh_audio->audio.dwSampleSize;
+	    if(sh_audio->wf->nBlockAlign>align) align=sh_audio->wf->nBlockAlign;
+	    curr_audio_pos/=align;
+	    curr_audio_pos*=align;
+#else
+	    curr_audio_pos=(priv->avi_video_pts)*(float)sh_audio->audio.dwRate/(float)sh_audio->audio.dwScale;
+	    curr_audio_pos-=sh_audio->audio.dwStart;
+	    curr_audio_pos*=sh_audio->audio.dwSampleSize;
+#endif
+
+        // find audio chunk pos:
+          for(i=0;i<chunk_max;i++){
+            int id=((AVIINDEXENTRY *)priv->idx)[i].ckid;
+            if(avi_stream_id(id)==d_audio->id){
+                len=((AVIINDEXENTRY *)priv->idx)[i].dwChunkLength;
+                if(d_audio->dpos<=curr_audio_pos && curr_audio_pos<(d_audio->dpos+len)){
+                  break;
+                }
+                ++d_audio->pack_no;
+                priv->audio_block_no+=priv->audio_block_size ?
+		    ((len+priv->audio_block_size-1)/priv->audio_block_size) : 1;
+                d_audio->dpos+=len;
+            }
+          }
+	  audio_chunk_pos=i;
+	  skip_audio_bytes=curr_audio_pos-d_audio->dpos;
+
+          mp_msg(MSGT_SEEK,MSGL_V,"SEEK: i=%d (max:%d) dpos=%d (wanted:%d)  \n",
+	      i,chunk_max,(int)d_audio->dpos,curr_audio_pos);
+	      
+	} else {
+	    // VBR audio
+	    int chunks=(priv->avi_video_pts)*(float)sh_audio->audio.dwRate/(float)sh_audio->audio.dwScale;
+	    audio_chunk_pos=0;
+	    
+        // find audio chunk pos:
+          for(i=0;i<priv->idx_size && chunks>0;i++){
+            int id=((AVIINDEXENTRY *)priv->idx)[i].ckid;
+            if(avi_stream_id(id)==d_audio->id){
+                len=((AVIINDEXENTRY *)priv->idx)[i].dwChunkLength;
+		if(i>chunk_max){
+		  skip_audio_bytes+=len;
+		} else {
+		  ++d_audio->pack_no;
+                  priv->audio_block_no+=priv->audio_block_size ?
+		    ((len+priv->audio_block_size-1)/priv->audio_block_size) : 1;
+                  d_audio->dpos+=len;
+		  audio_chunk_pos=i;
+		}
+//		--chunks;
+		if(priv->audio_block_size)
+		    chunks-=(len+priv->audio_block_size-1)/priv->audio_block_size;
+            }
+          }
+	  //if(audio_chunk_pos>chunk_max) audio_chunk_pos=chunk_max;
+	  
+//	  printf("VBR seek: %5.3f -> chunk_no %d -> chunk_idx %d + skip %d  \n",
+//	      priv->avi_video_pts, audio_chunk_pos, );
+	
+	}
+	
+	// Now we have:
+	//      audio_chunk_pos = chunk no in index table (it's <=chunk_max)
+	//      skip_audio_bytes = bytes to be skipped after chunk seek
+	//      d-audio->pack_no = chunk_no in stream at audio_chunk_pos
+	//      d_audio->dpos = bytepos in stream at audio_chunk_pos
+	// let's seek!
+	
+          // update stream position:
+          d_audio->pos=audio_chunk_pos;
+//          d_audio->dpos=apos;
+//	  d_audio->pts=initial_pts_delay+(float)apos/(float)sh_audio->wf->nAvgBytesPerSec;
+	
+	if(demuxer->type==DEMUXER_TYPE_AVI){
+	  // interleaved stream:
+	  if(audio_chunk_pos<video_chunk_pos){
+            // calc priv->skip_video_frames & adjust video pts counter:
+	    for(i=audio_chunk_pos;i<video_chunk_pos;i++){
+              int id=((AVIINDEXENTRY *)priv->idx)[i].ckid;
+              if(avi_stream_id(id)==d_video->id) ++priv->skip_video_frames;
+            }
+            // requires for correct audio pts calculation (demuxer):
+            priv->avi_video_pts-=priv->skip_video_frames*(float)sh_video->video.dwScale/(float)sh_video->video.dwRate;
+	    priv->avi_audio_pts=priv->avi_video_pts;
+	    // set index position:
+	    priv->idx_pos_a=priv->idx_pos_v=priv->idx_pos=audio_chunk_pos;
+	  }
+	} else {
+	    // non-interleaved stream:
+	    priv->idx_pos_a=audio_chunk_pos;
+	    priv->idx_pos_v=video_chunk_pos;
+	    priv->idx_pos=(audio_chunk_pos<video_chunk_pos)?audio_chunk_pos:video_chunk_pos;
+	}
+	
+
+
+          mp_msg(MSGT_SEEK,MSGL_V,"SEEK: idx=%d  (a:%d v:%d)  v.skip=%d  a.skip=%d/%4.3f  \n",
+            (int)priv->idx_pos,audio_chunk_pos,video_chunk_pos,
+            (int)priv->skip_video_frames,skip_audio_bytes,skip_audio_secs);
+
+          if(skip_audio_bytes){
+            demux_read_data(d_audio,NULL,skip_audio_bytes);
+            //d_audio->pts=0; // PTS is outdated because of the raw data skipping
+          }
+	  resync_audio_stream(sh_audio);
+
+//          sh_audio->timer=-skip_audio_secs;
+
+      }
+	d_video->pts=priv->avi_video_pts; // OSD
+
+}
+
+
+void demux_close_avi(demuxer_t *demuxer) {
+  avi_priv_t* priv=demuxer->priv;
+
+  if(!priv)
+    return;
+
+  if(priv->idx_size > 0)
+    free(priv->idx);
+  free(priv);
+}
+
+
+int demux_avi_control(demuxer_t *demuxer,int cmd, void *arg){
+    avi_priv_t *priv=demuxer->priv;
+/*    demux_stream_t *d_audio=demuxer->audio;*/
+    demux_stream_t *d_video=demuxer->video;
+/*    sh_audio_t *sh_audio=d_audio->sh;*/
+    sh_video_t *sh_video=d_video->sh;
+
+
+
+    switch(cmd) {
+	case DEMUXER_CTRL_GET_TIME_LENGTH:
+    	    if (!priv->numberofframes) return DEMUXER_CTRL_DONTKNOW;
+	    *((unsigned long *)arg)=priv->numberofframes/sh_video->fps;
+	    if (sh_video->video.dwLength<=1) return DEMUXER_CTRL_GUESS;
+	    return DEMUXER_CTRL_OK;
+
+	case DEMUXER_CTRL_GET_PERCENT_POS:
+    	    if (!priv->numberofframes) {
+		if (demuxer->movi_end==demuxer->movi_start) return DEMUXER_CTRL_DONTKNOW;
+		*((int *)arg)=(int)((demuxer->filepos-demuxer->movi_start)/((demuxer->movi_end-demuxer->movi_start)/100));
+		return DEMUXER_CTRL_OK; 
+	    }
+	    *((int *)arg)=(int)(priv->video_pack_no*100/priv->numberofframes);
+	    if (sh_video->video.dwLength<=1) return DEMUXER_CTRL_GUESS;
+	    return DEMUXER_CTRL_OK;
+
+	default:
+	    return DEMUXER_CTRL_NOTIMPL;
+    }
+}
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_film.c MPlayer-1.0pre5/libmpdemux/demux_film.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_film.c	2002-04-24 22:36:06 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_film.c	2004-08-08 10:36:04 +0700
@@ -227,7 +227,7 @@
   header_size -= 16;
 
   mp_msg(MSGT_DEMUX, MSGL_HINT, "FILM version %.4s\n",
-    &film_data->film_version);
+    (char *)&film_data->film_version);
 
   // skip to where the next chunk should be
   stream_skip(demuxer->stream, 4);
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_mov.c MPlayer-1.0pre5/libmpdemux/demux_mov.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_mov.c	2004-06-28 02:53:30 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_mov.c	2004-08-08 10:36:04 +0700
@@ -364,7 +364,7 @@
      	      break;
 	    default:
 	      tmp = be2me_32(tmp);  
-	      mp_msg(MSGT_DEMUX,MSGL_WARN,"ISO: Unknown File Type Major Brand: %.4s\n",&tmp);
+	      mp_msg(MSGT_DEMUX,MSGL_WARN,"ISO: Unknown File Type Major Brand: %.4s\n",(char *)&tmp);
 	  }
 	  mp_msg(MSGT_DEMUX,MSGL_V,"ISO: File Type Minor Version: %d\n",
 	      stream_read_dword(demuxer->stream));
@@ -372,7 +372,7 @@
 	  // List all compatible brands
 	  for(i = 0; i < ((len-16)/4); i++) {
 	    tmp = be2me_32(stream_read_dword(demuxer->stream));
-	    mp_msg(MSGT_DEMUX,MSGL_V,"ISO: File Type Compatible Brand #%d: %.4s\n",i,&tmp);
+	    mp_msg(MSGT_DEMUX,MSGL_V,"ISO: File Type Compatible Brand #%d: %.4s\n",i,(char *)&tmp);
 	    skipped += 4;
 	  }
 #endif	  
@@ -382,8 +382,13 @@
 	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: Movie header found!\n");
 	  priv->moov_start=(off_t)stream_tell(demuxer->stream);
 	  priv->moov_end=(off_t)priv->moov_start+len-skipped;
+#ifdef _LARGEFILE_SOURCE 
+	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: Movie header: start: %llx end: %llx\n",
+	    priv->moov_start, priv->moov_end);
+#else
 	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: Movie header: start: %x end: %x\n",
 	    priv->moov_start, priv->moov_end);
+#endif
 	  skipped+=8;
 	  i = stream_read_dword(demuxer->stream)-8;
 	  if(stream_read_dword(demuxer->stream)==MOV_FOURCC('r','m','r','a')){
@@ -446,8 +451,13 @@
 	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: Movie DATA found!\n");
 	  priv->mdat_start=stream_tell(demuxer->stream);
 	  priv->mdat_end=priv->mdat_start+len-skipped;
+#ifdef _LARGEFILE_SOURCE 
+	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: Movie data: start: %llx end: %llx\n",
+	    priv->mdat_start, priv->mdat_end);
+#else
 	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: Movie data: start: %x end: %x\n",
 	    priv->mdat_start, priv->mdat_end);
+#endif
 	  flags|=2;
 	  if(flags==3){
 	    // if we're over the headers, then we can stop parsing here!
@@ -458,7 +468,11 @@
 	case MOV_FOURCC('f','r','e','e'):
 	case MOV_FOURCC('s','k','i','p'):
 	case MOV_FOURCC('j','u','n','k'):
+#ifdef _LARGEFILE_SOURCE 
+	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: free space (len: %lld)\n", len);
+#else
 	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: free space (len: %d)\n", len);
+#endif
 	  /* unused, if you edit a mov, you can use space provided by free atoms (redefining it) */
 	  break;
 	case MOV_FOURCC('p','n','o','t'):
@@ -468,7 +482,7 @@
 	default:
 	  if(no==0){ free(priv); return 0;} // first chunk is bad!
 	  id = be2me_32(id);
-	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",&id,(int)len);
+	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",(char *)&id,(int)len);
 	}
 skip_chunk:
 	if(!stream_skip(demuxer->stream,len-skipped)) break;
@@ -509,7 +523,7 @@
 	len-=8;
 	id=stream_read_dword(demuxer->stream);
 	//
-	mp_msg(MSGT_DEMUX,MSGL_DBG2,"lschunks %.4s  %d\n",&id,(int)len);
+	mp_msg(MSGT_DEMUX,MSGL_DBG2,"lschunks %.4s  %d\n",(char *)&id,(int)len);
 	//
 	if(trak){
 	  switch(id){
@@ -587,7 +601,7 @@
 		char* str=malloc(len+1);
 		stream_read(demuxer->stream,str,len);
 		str[len]=0;
-		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sHandler header: %.4s/%.4s (%.4s) %s\n",level,"",&type,&subtype,&manufact,str);
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sHandler header: %.4s/%.4s (%.4s) %s\n",level,"",(char *)&type,(char *)&subtype,(char *)&manufact,str);
 		free(str);
 		switch(bswap_32(type)){
 		case MOV_FOURCC('m','h','l','r'):
@@ -595,7 +609,7 @@
 		case MOV_FOURCC('d','h','l','r'):
 		    trak->data_handler=bswap_32(subtype); break;
 		default:
-		    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown handler class: 0x%X (%.4s)\n",bswap_32(type),&type);
+		    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown handler class: 0x%X (%.4s)\n",bswap_32(type),(char *)&type);
 		}
 		break;
 	    }
@@ -630,7 +644,11 @@
 		    off_t len=stream_read_dword(demuxer->stream);
 		    unsigned int fourcc=stream_read_dword_le(demuxer->stream);
 		    if(len<8) break; // error
-		    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*s desc #%d: %.4s  (%d bytes)\n",level,"",i,&fourcc,len-16);
+#ifdef _LARGEFILE_SOURCE 
+		    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*s desc #%d: %.4s  (%lld bytes)\n",level,"",i,(char *)&fourcc,len-16);
+#else
+		    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*s desc #%d: %.4s  (%d bytes)\n",level,"",i,(char *)&fourcc,len-16);
+#endif
 		    if(fourcc!=trak->fourcc && i)
 			mp_msg(MSGT_DEMUX,MSGL_WARN,MSGTR_MOVvariableFourCC);
 //		    if(!i)
@@ -669,7 +687,7 @@
 		int ver = (temp << 24);
 		int flags = (temp << 16)|(temp<<8)|temp;
 		int i;
-		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample->Chunk mapping table!  (%d blocks) (ver:%d,flags:%ld)\n",
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample->Chunk mapping table!  (%d blocks) (ver:%d,flags:%d)\n",
 		    level,"",len,ver,flags);
 		// read data:
 		trak->chunkmap_size=len;
@@ -689,7 +707,7 @@
 		int entries=stream_read_dword(demuxer->stream);
 		int i;
 		
-		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample size table! (entries=%d ss=%d) (ver:%d,flags:%ld)\n",
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample size table! (entries=%d ss=%d) (ver:%d,flags:%d)\n",
 		    level,"",entries,ss,ver,flags);
 		trak->samplesize=ss;
 		if (!ss) {
@@ -744,7 +762,7 @@
 		int ver = (temp << 24);
 		int flags = (temp << 16)|(temp<<8)|temp;
 		int i;
-		mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*sSyncing samples (keyframes) table! (%d entries) (ver:%d,flags:%ld)\n",
+		mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*sSyncing samples (keyframes) table! (%d entries) (ver:%d,flags:%d)\n",
 		    level, "",entries, ver, flags);
 		trak->keyframes_size=entries;
 		trak->keyframes=malloc(sizeof(unsigned int)*entries);
@@ -780,7 +798,7 @@
 		int flags = (temp << 16)|(temp<<8)|temp;
 		int i;
 	
-		mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*sEdit list table (%d entries) (ver:%d,flags:%ld)\n",
+		mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*sEdit list table (%d entries) (ver:%d,flags:%d)\n",
 		    level, "",entries, ver, flags);
 #if 1
 		trak->editlist_size=entries;
@@ -806,7 +824,7 @@
 	    }
 	    default:
 		id = be2me_32(id);
-		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",&id,(int)len);
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",(char *)&id,(int)len);
 		break;
 	  }//switch(id)
 	} else { /* not in track */
@@ -970,7 +988,7 @@
 			    atom_len);
 		    }
 		}  
-		mp_msg(MSGT_DEMUX, MSGL_INFO, "Fourcc: %.4s\n",&trak->fourcc);
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Fourcc: %.4s\n",(char *)&trak->fourcc);
 #if 0
 		{ FILE* f=fopen("stdata.dat","wb");
 		  fwrite(trak->stdata,trak->stdata_len,1,f);
@@ -1252,7 +1270,7 @@
 		mp_msg(MSGT_DEMUX, MSGL_INFO, "Display size: %d x %d\n",
 		    trak->tkdata[77]|(trak->tkdata[76]<<8),
 		    trak->tkdata[81]|(trak->tkdata[80]<<8));
-		mp_msg(MSGT_DEMUX, MSGL_INFO, "Fourcc: %.4s  Codec: '%.*s'\n",&trak->fourcc,trak->stdata[42]&31,trak->stdata+43);
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Fourcc: %.4s  Codec: '%.*s'\n",(char *)&trak->fourcc,trak->stdata[42]&31,trak->stdata+43);
 		
 //		if(demuxer->video->id==-1 || demuxer->video->id==priv->track_db){
 //		    // (auto)selected video track:
@@ -1333,7 +1351,7 @@
 	case MOV_FOURCC('d','c','o','m'): {
 //	    int temp=stream_read_dword(demuxer->stream);
 	    unsigned int algo=be2me_32(stream_read_dword(demuxer->stream));
-	    mp_msg(MSGT_DEMUX, MSGL_INFO, "Compressed header uses %.4s algo!\n",&algo);
+	    mp_msg(MSGT_DEMUX, MSGL_INFO, "Compressed header uses %.4s algo!\n",(char *)&algo);
 	    break;
 	}
 	case MOV_FOURCC('c','m','v','d'): {
@@ -1377,7 +1395,7 @@
 	      }
 #endif
 	      if(moov_sz != zstrm.total_out)
-	        mp_msg(MSGT_DEMUX, MSGL_WARN, "Warning! moov size differs cmov: %d  zlib: %d\n",moov_sz,zstrm.total_out);
+	        mp_msg(MSGT_DEMUX, MSGL_WARN, "Warning! moov size differs cmov: %d  zlib: %ld\n",moov_sz,zstrm.total_out);
 	      zret = inflateEnd(&zstrm);
 	      
 	      backup=demuxer->stream;
@@ -1405,7 +1423,11 @@
 		udta_len = stream_read_dword(demuxer->stream);
 		udta_id = stream_read_dword(demuxer->stream);
 		udta_size -= 8;
-		mp_msg(MSGT_DEMUX, MSGL_DBG2, "udta_id: %.4s (len: %d)\n", &udta_id, udta_len);
+#ifdef _LARGEFILE_SOURCE 
+		mp_msg(MSGT_DEMUX, MSGL_DBG2, "udta_id: %.4s (len: %lld)\n", (char *)&udta_id, udta_len);
+#else
+		mp_msg(MSGT_DEMUX, MSGL_DBG2, "udta_id: %.4s (len: %d)\n", (char *)&udta_id, udta_len);
+#endif
 		switch (udta_id)
 		{
 		    case MOV_FOURCC(0xa9,'c','p','y'):
@@ -1508,7 +1530,7 @@
 	} /* eof udta */
 	default:
 	  id = be2me_32(id);
-	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",&id,(int)len);
+	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",(char *)&id,(int)len);
 	} /* endof switch */
 	} /* endof else */
 
@@ -1530,8 +1552,13 @@
     stream_reset(demuxer->stream);
     if(!stream_seek(demuxer->stream,priv->moov_start))
     {
+#ifdef _LARGEFILE_SOURCE 
+	mp_msg(MSGT_DEMUX,MSGL_ERR,"MOV: Cannot seek to the beginning of the Movie header (0x%llx)\n",
+	    priv->moov_start);
+#else
 	mp_msg(MSGT_DEMUX,MSGL_ERR,"MOV: Cannot seek to the beginning of the Movie header (0x%x)\n",
 	    priv->moov_start);
+#endif
 	return 0;
     }
     lschunks(demuxer, 0, priv->moov_end, NULL);
@@ -1620,7 +1647,7 @@
 	                zret = inflateInit(&zstrm);
 			zret = inflate(&zstrm, Z_NO_FLUSH);
 			if(newlen != zstrm.total_out)
-	    		    mp_msg(MSGT_DEMUX, MSGL_WARN, "Warning! unzipped frame size differs hdr: %d  zlib: %d\n",newlen,zstrm.total_out);
+	    		    mp_msg(MSGT_DEMUX, MSGL_WARN, "Warning! unzipped frame size differs hdr: %d  zlib: %ld\n",newlen,zstrm.total_out);
 			
 			write(fd, buf2, newlen);
 		    } else {
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_mov.c.orig MPlayer-1.0pre5/libmpdemux/demux_mov.c.orig
--- MPlayer-1.0pre5.orig/libmpdemux/demux_mov.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_mov.c.orig	2004-06-28 02:53:30 +0700
@@ -0,0 +1,1806 @@
+//  QuickTime MOV file parser by A'rpi
+//  additional work by Atmos
+//  based on TOOLS/movinfo.c by A'rpi & Al3x
+//  compressed header support from moov.c of the openquicktime lib.
+//  References: http://openquicktime.sf.net/, http://www.heroinewarrior.com/
+//  http://www.geocities.com/SiliconValley/Lakes/2160/fformats/files/mov.pdf
+//  (above url no longer works, file mirrored somewhere? ::atmos)
+//  The QuickTime File Format PDF from Apple:
+//  http://developer.apple.com/techpubs/quicktime/qtdevdocs/PDF/QTFileFormat.pdf
+//  (Complete list of documentation at http://developer.apple.com/quicktime/)
+//  MP4-Lib sources from http://mpeg4ip.sf.net/ might be usefull fot .mp4
+//  aswell as .mov specific stuff.
+//  All sort of Stuff about MPEG4:
+//  http://www.cmlab.csie.ntu.edu.tw/~pkhsiao/thesis.html
+//  I really recommend N4270-1.doc and N4270-2.doc which are exact specs
+//  of the MP4-File Format and the MPEG4 Specific extensions. ::atmos
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "mp_msg.h"
+#include "help_mp.h"
+
+#include "stream.h"
+#include "demuxer.h"
+#include "stheader.h"
+
+#include "bswap.h"
+
+#include "qtpalette.h"
+#include "parse_mp4.h" // .MP4 specific stuff
+
+#ifdef MACOSX
+#include <QuickTime/QuickTime.h>
+#else
+#include "../loader/qtx/qtxsdk/components.h"
+#endif
+
+#ifdef HAVE_ZLIB
+#include <zlib.h>
+#endif
+
+#ifndef _FCNTL_H
+#include <fcntl.h>
+#endif
+
+#define BE_16(x) (((unsigned char *)(x))[0] <<  8 | \
+		  ((unsigned char *)(x))[1])
+#define BE_32(x) (((unsigned char *)(x))[0] << 24 | \
+		  ((unsigned char *)(x))[1] << 16 | \
+		  ((unsigned char *)(x))[2] <<  8 | \
+		  ((unsigned char *)(x))[3])
+
+#define char2short(x,y)	BE_16(&(x)[(y)])
+#define char2int(x,y) 	BE_32(&(x)[(y)])
+
+typedef struct {
+    unsigned int pts; // duration
+    unsigned int size;
+    off_t pos;
+} mov_sample_t;
+
+typedef struct {
+    unsigned int sample; // number of the first sample in the chunk
+    unsigned int size;   // number of samples in the chunk
+    int desc;            // for multiple codecs mode - not used
+    off_t pos;
+} mov_chunk_t;
+
+typedef struct {
+    unsigned int first;
+    unsigned int spc;
+    unsigned int sdid;
+} mov_chunkmap_t;
+
+typedef struct {
+    unsigned int num;
+    unsigned int dur;
+} mov_durmap_t;
+
+typedef struct {
+    unsigned int dur;
+    unsigned int pos;
+    int speed;
+    //
+    int frames;
+    int start_sample;
+    int start_frame;
+    int pts_offset;
+} mov_editlist_t;
+
+#define MOV_TRAK_UNKNOWN 0
+#define MOV_TRAK_VIDEO 1
+#define MOV_TRAK_AUDIO 2
+#define MOV_TRAK_FLASH 3
+#define MOV_TRAK_GENERIC 4
+#define MOV_TRAK_CODE 5
+
+typedef struct {
+    int id;
+    int type;
+    off_t pos;
+    //
+    unsigned int media_handler;
+    unsigned int data_handler;
+    //
+    int timescale;
+    unsigned int length;
+    int samplesize;  // 0 = variable
+    int duration;    // 0 = variable
+    int width,height; // for video
+    unsigned int fourcc;
+    //
+    int tkdata_len;  // track data 
+    unsigned char* tkdata;
+    int stdata_len;  // stream data
+    unsigned char* stdata;
+    //
+    unsigned char* stream_header;
+    int stream_header_len; // if >0, this header should be sent before the 1st frame
+    //
+    int samples_size;
+    mov_sample_t* samples;
+    int chunks_size;
+    mov_chunk_t* chunks;
+    int chunkmap_size;
+    mov_chunkmap_t* chunkmap;
+    int durmap_size;
+    mov_durmap_t* durmap;
+    int keyframes_size;
+    unsigned int* keyframes;
+    int editlist_size;
+    mov_editlist_t* editlist;
+    int editlist_pos;
+    //
+    void* desc; // image/sound/etc description (pointer to ImageDescription etc)
+} mov_track_t;
+
+void mov_build_index(mov_track_t* trak,int timescale){
+    int i,j,s;
+    int last=trak->chunks_size;
+    unsigned int pts=0;
+
+#if 0
+    if (trak->chunks_size <= 0)
+    {
+	mp_msg(MSGT_DEMUX, MSGL_WARN, "No chunk offset table, trying to build one!\n");
+	
+	trak->chunks_size = trak->samples_size; /* XXX: FIXME ! */
+	trak->chunks = realloc(trak->chunks, sizeof(mov_chunk_t)*trak->chunks_size);
+	
+	for (i=0; i < trak->chunks_size; i++)
+	    trak->chunks[i].pos = -1;
+    }
+#endif
+
+    mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV track #%d: %d chunks, %d samples\n",trak->id,trak->chunks_size,trak->samples_size);
+    mp_msg(MSGT_DEMUX, MSGL_V, "pts=%d  scale=%d  time=%5.3f\n",trak->length,trak->timescale,(float)trak->length/(float)trak->timescale);
+
+    // process chunkmap:
+    i=trak->chunkmap_size;
+    while(i>0){
+	--i;
+	for(j=trak->chunkmap[i].first;j<last;j++){
+	    trak->chunks[j].desc=trak->chunkmap[i].sdid;
+	    trak->chunks[j].size=trak->chunkmap[i].spc;
+	}
+	last=trak->chunkmap[i].first;
+    }
+
+#if 0
+    for (i=0; i < trak->chunks_size; i++)
+    {
+	/* fixup position */
+	if (trak->chunks[i].pos == -1)
+	    if (i > 0)
+		trak->chunks[i].pos = trak->chunks[i-1].pos + trak->chunks[i-1].size;
+	    else
+		trak->chunks[i].pos = 0; /* FIXME: set initial pos */
+#endif
+
+    // calc pts of chunks:
+    s=0;
+    for(j=0;j<trak->chunks_size;j++){
+        trak->chunks[j].sample=s;
+        s+=trak->chunks[j].size;
+    }
+
+    // workaround for fixed-size video frames (dv and uncompressed)
+    if(!trak->samples_size && trak->type!=MOV_TRAK_AUDIO){
+	trak->samples_size=s;
+	trak->samples=malloc(sizeof(mov_sample_t)*s);
+	for(i=0;i<s;i++)
+	    trak->samples[i].size=trak->samplesize;
+	trak->samplesize=0;
+    }
+
+    if(!trak->samples_size){
+	// constant sampesize
+	if(trak->durmap_size==1 || (trak->durmap_size==2 && trak->durmap[1].num==1)){
+	    trak->duration=trak->durmap[0].dur;
+	} else mp_msg(MSGT_DEMUX, MSGL_ERR, "*** constant samplesize & variable duration not yet supported! ***\nContact the author if you have such sample file!\n");
+	return;
+    }
+    
+    // calc pts:
+    s=0;
+    for(j=0;j<trak->durmap_size;j++){
+	for(i=0;i<trak->durmap[j].num;i++){
+	    trak->samples[s].pts=pts;
+	    ++s;
+	    pts+=trak->durmap[j].dur;
+	}
+    }
+    
+    // calc sample offsets
+    s=0;
+    for(j=0;j<trak->chunks_size;j++){
+	off_t pos=trak->chunks[j].pos;
+	for(i=0;i<trak->chunks[j].size;i++){
+	    trak->samples[s].pos=pos;
+	    mp_msg(MSGT_DEMUX, MSGL_DBG3, "Sample %5d: pts=%8d  off=0x%08X  size=%d\n",s,
+		trak->samples[s].pts,
+		(int)trak->samples[s].pos,
+		trak->samples[s].size);
+	    pos+=trak->samples[s].size;
+	    ++s;
+	}
+    }
+
+    // precalc editlist entries
+    if(trak->editlist_size>0){
+	int frame=0;
+	int e_pts=0;
+	for(i=0;i<trak->editlist_size;i++){
+	    mov_editlist_t* el=&trak->editlist[i];
+	    int sample=0;
+	    int pts=el->pos;
+	    el->start_frame=frame;
+	    if(pts<0){
+		// skip!
+		el->frames=0; continue;
+	    }
+	    // find start sample
+	    for(;sample<trak->samples_size;sample++){
+		if(pts<=trak->samples[sample].pts) break;
+	    }
+	    el->start_sample=sample;
+	    el->pts_offset=((long long)e_pts*(long long)trak->timescale)/(long long)timescale-trak->samples[sample].pts;
+	    pts+=((long long)el->dur*(long long)trak->timescale)/(long long)timescale;
+	    e_pts+=el->dur;
+	    // find end sample
+	    for(;sample<trak->samples_size;sample++){
+		if(pts<=trak->samples[sample].pts) break;
+	    }
+	    el->frames=sample-el->start_sample;
+	    frame+=el->frames;
+	    mp_msg(MSGT_DEMUX,MSGL_V,"EL#%d: pts=%d  1st_sample=%d  frames=%d (%5.3fs)  pts_offs=%d\n",i,
+		el->pos,el->start_sample, el->frames,
+		(float)(el->dur)/(float)timescale, el->pts_offset);
+	}
+    }
+
+}
+
+#define MOV_MAX_TRACKS 256
+
+typedef struct {
+    off_t moov_start;
+    off_t moov_end;
+    off_t mdat_start;
+    off_t mdat_end;
+    int track_db;
+    mov_track_t* tracks[MOV_MAX_TRACKS];
+    int timescale; // movie timescale
+    int duration;  // movie duration (in movie timescale units)
+} mov_priv_t;
+
+#define MOV_FOURCC(a,b,c,d) ((a<<24)|(b<<16)|(c<<8)|(d))
+
+int mov_check_file(demuxer_t* demuxer){
+    int flags=0;
+    int no=0;
+    mov_priv_t* priv=malloc(sizeof(mov_priv_t));
+    
+    mp_msg(MSGT_DEMUX,MSGL_V,"Checking for MOV\n");
+    
+    memset(priv,0,sizeof(mov_priv_t));
+    
+    while(1){
+	int i;
+	int skipped=8;
+	off_t len=stream_read_dword(demuxer->stream);
+	unsigned int id=stream_read_dword(demuxer->stream);
+	if(stream_eof(demuxer->stream)) break; // EOF
+	if (len == 1) /* real size is 64bits - cjb */
+	{
+#ifndef _LARGEFILE_SOURCE
+	    if (stream_read_dword(demuxer->stream) != 0)
+		mp_msg(MSGT_DEMUX, MSGL_WARN, "64bit file, but you've compiled MPlayer without LARGEFILE support!\n");
+	    len = stream_read_dword(demuxer->stream);
+#else
+	    len = stream_read_qword(demuxer->stream);
+#endif
+	    skipped += 8;
+	}
+#if 0
+	else if (len == 0) /* deleted chunk */
+	{
+	    /* XXX: CJB! is this right? - alex */
+	    goto skip_chunk;
+	}
+#endif
+	else if(len<8) break; // invalid chunk
+
+	switch(id){
+	case MOV_FOURCC('f','t','y','p'): {
+	  unsigned int tmp;
+	  // File Type Box (ftyp): 
+	  // char[4]  major_brand	   (eg. 'isom')
+	  // int      minor_version	   (eg. 0x00000000)
+	  // char[4]  compatible_brands[]  (eg. 'mp41')
+	  // compatible_brands list spans to the end of box
+#if 1
+	  tmp = stream_read_dword(demuxer->stream);
+	  switch(tmp) {
+	    case MOV_FOURCC('i','s','o','m'):
+	      mp_msg(MSGT_DEMUX,MSGL_V,"ISO: File Type Major Brand: ISO Base Media\n");
+     	      break;
+	    case MOV_FOURCC('m','p','4','1'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: ISO/IEC 14496-1 (MPEG-4 system) v1\n");
+     	      break;
+	    case MOV_FOURCC('m','p','4','2'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: ISO/IEC 14496-1 (MPEG-4 system) v2\n");
+     	      break;
+	    case MOV_FOURCC('M','4','A',' '):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: Apple iTunes AAC-LC Audio\n");
+     	      break;
+	    case MOV_FOURCC('M','4','P',' '):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: Apple iTunes AAC-LC Protected Audio\n");
+     	      break;
+	    case MOV_FOURCC('q','t',' ',' '):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: Original QuickTime\n");
+     	      break;
+	    case MOV_FOURCC('3','g','p','1'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: 3GPP Profile 1\n");
+     	      break;
+	    case MOV_FOURCC('3','g','p','2'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: 3GPP Profile 2\n");
+     	      break;
+	    case MOV_FOURCC('3','g','p','3'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: 3GPP Profile 3\n");
+     	      break;
+	    case MOV_FOURCC('3','g','p','4'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: 3GPP Profile 4\n");
+     	      break;
+	    case MOV_FOURCC('3','g','p','5'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: 3GPP Profile 5\n");
+     	      break;
+	    case MOV_FOURCC('m','m','p','4'):
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"ISO: File Type Major Brand: Mobile ISO/IEC 14496-1 (MPEG-4 system)\n");
+     	      break;
+	    default:
+	      tmp = be2me_32(tmp);  
+	      mp_msg(MSGT_DEMUX,MSGL_WARN,"ISO: Unknown File Type Major Brand: %.4s\n",&tmp);
+	  }
+	  mp_msg(MSGT_DEMUX,MSGL_V,"ISO: File Type Minor Version: %d\n",
+	      stream_read_dword(demuxer->stream));
+	  skipped += 8;
+	  // List all compatible brands
+	  for(i = 0; i < ((len-16)/4); i++) {
+	    tmp = be2me_32(stream_read_dword(demuxer->stream));
+	    mp_msg(MSGT_DEMUX,MSGL_V,"ISO: File Type Compatible Brand #%d: %.4s\n",i,&tmp);
+	    skipped += 4;
+	  }
+#endif	  
+	  } break;
+	case MOV_FOURCC('m','o','o','v'):
+//	case MOV_FOURCC('c','m','o','v'):
+	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: Movie header found!\n");
+	  priv->moov_start=(off_t)stream_tell(demuxer->stream);
+	  priv->moov_end=(off_t)priv->moov_start+len-skipped;
+	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: Movie header: start: %x end: %x\n",
+	    priv->moov_start, priv->moov_end);
+	  skipped+=8;
+	  i = stream_read_dword(demuxer->stream)-8;
+	  if(stream_read_dword(demuxer->stream)==MOV_FOURCC('r','m','r','a')){
+	      int ref=0;
+	      skipped+=i;
+	      mp_msg(MSGT_DEMUX,MSGL_INFO,"MOV: Reference Media file!!!\n");
+	      //set demuxer type to playlist ...
+	      demuxer->type=DEMUXER_TYPE_PLAYLIST;
+	      while(i>0){
+	          int len=stream_read_dword(demuxer->stream)-8;
+		  int fcc=stream_read_dword(demuxer->stream);
+		  if(len<0) break; // EOF!?
+		  i-=8;
+//		  printf("i=%d  len=%d\n",i,len);
+		  switch(fcc){
+		  case MOV_FOURCC('r','m','d','a'):
+		      continue;
+		  case MOV_FOURCC('r','d','r','f'): {
+		      int tmp=stream_read_dword(demuxer->stream);
+		      int type=stream_read_dword_le(demuxer->stream);
+	              int slen=stream_read_dword(demuxer->stream);
+		      //char* s=malloc(slen+1);
+		      //stream_read(demuxer->stream,s,slen);
+		      
+		      //FIXME: also store type & data_rate ?
+		      ds_read_packet(demuxer->video, 
+			demuxer->stream,
+			slen,
+			0,
+			stream_tell(demuxer->stream),
+			0 // no flags 
+		      );
+		      flags|=4;
+		      mp_msg(MSGT_DEMUX,MSGL_V,"Added reference to playlist\n");
+		      //s[slen]=0;
+		      //mp_msg(MSGT_DEMUX,MSGL_INFO,"REF: [%.4s] %s\n",&type,s);
+		      len-=12+slen;i-=12+slen; break;
+		    }
+		  case MOV_FOURCC('r','m','d','r'): {
+		      int flags=stream_read_dword(demuxer->stream);
+		      int rate=stream_read_dword(demuxer->stream);
+		      mp_msg(MSGT_DEMUX,MSGL_V,"  min. data rate: %d bits/sec\n",rate);
+		      len-=8; i-=8; break;
+		    }
+		  case MOV_FOURCC('r','m','q','u'): {
+		      int q=stream_read_dword(demuxer->stream);
+		      mp_msg(MSGT_DEMUX,MSGL_V,"  quality index: %d\n",q);
+		      len-=4; i-=4; break;
+		    }
+		  }
+		  i-=len;stream_skip(demuxer->stream,len);
+	      }
+	  }
+	  flags|=1;
+	  break;
+	case MOV_FOURCC('w','i','d','e'):
+	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: 'WIDE' chunk found!\n");
+	  if(flags&2) break;
+	case MOV_FOURCC('m','d','a','t'):
+	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: Movie DATA found!\n");
+	  priv->mdat_start=stream_tell(demuxer->stream);
+	  priv->mdat_end=priv->mdat_start+len-skipped;
+	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: Movie data: start: %x end: %x\n",
+	    priv->mdat_start, priv->mdat_end);
+	  flags|=2;
+	  if(flags==3){
+	    // if we're over the headers, then we can stop parsing here!
+	    demuxer->priv=priv;
+	    return 1;
+	  }
+	  break;
+	case MOV_FOURCC('f','r','e','e'):
+	case MOV_FOURCC('s','k','i','p'):
+	case MOV_FOURCC('j','u','n','k'):
+	  mp_msg(MSGT_DEMUX,MSGL_DBG2,"MOV: free space (len: %d)\n", len);
+	  /* unused, if you edit a mov, you can use space provided by free atoms (redefining it) */
+	  break;
+	case MOV_FOURCC('p','n','o','t'):
+	case MOV_FOURCC('P','I','C','T'):
+	  /* dunno what, but we shoudl ignore it */
+	  break;
+	default:
+	  if(no==0){ free(priv); return 0;} // first chunk is bad!
+	  id = be2me_32(id);
+	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",&id,(int)len);
+	}
+skip_chunk:
+	if(!stream_skip(demuxer->stream,len-skipped)) break;
+	++no;
+    }
+
+    if(flags==3){
+	demuxer->priv=priv;
+	return 1;
+    }
+    free(priv);
+
+    if ((flags==5) || (flags==7)) // reference & header sent
+        return 1;
+
+    if(flags==1)
+	mp_msg(MSGT_DEMUX,MSGL_WARN,"MOV: missing data (mdat) chunk! Maybe broken file...\n");
+    else if(flags==2)
+	mp_msg(MSGT_DEMUX,MSGL_WARN,"MOV: missing header (moov/cmov) chunk! Maybe broken file...\n");
+
+    return 0;
+}
+
+static void lschunks(demuxer_t* demuxer,int level,off_t endpos,mov_track_t* trak){
+    mov_priv_t* priv=demuxer->priv;
+//    printf("lschunks (level=%d,endpos=%x)\n", level, endpos);
+    while(1){
+	off_t pos;
+	off_t len;
+	unsigned int id;
+	//
+	pos=stream_tell(demuxer->stream);
+//	printf("stream_tell==%d\n",pos);
+	if(pos>=endpos) return; // END
+	len=stream_read_dword(demuxer->stream);
+//	printf("len==%d\n",len);
+	if(len<8) return; // error
+	len-=8;
+	id=stream_read_dword(demuxer->stream);
+	//
+	mp_msg(MSGT_DEMUX,MSGL_DBG2,"lschunks %.4s  %d\n",&id,(int)len);
+	//
+	if(trak){
+	  switch(id){
+	    case MOV_FOURCC('m','d','a','t'): {
+		mp_msg(MSGT_DEMUX,MSGL_WARN,"Hmm, strange MOV, parsing mdat in lschunks?\n");
+		return;
+	    }
+	    case MOV_FOURCC('f','r','e','e'):
+	    case MOV_FOURCC('u','d','t','a'):
+		/* here not supported :p */
+		break;
+	    case MOV_FOURCC('t','k','h','d'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sTrack header!\n",level,"");
+		// read codec data
+		trak->tkdata_len=len;
+		trak->tkdata=malloc(trak->tkdata_len);
+		stream_read(demuxer->stream,trak->tkdata,trak->tkdata_len);
+/*
+0  1 Version
+1  3 Flags
+4  4 Creation time
+8  4 Modification time
+12 4 Track ID
+16 4 Reserved
+20 4 Duration
+24 8 Reserved
+32 2 Layer
+34 2 Alternate group
+36 2 Volume
+38 2 Reserved
+40 36 Matrix structure
+76 4 Track width
+80 4 Track height
+*/
+		mp_msg(MSGT_DEMUX,MSGL_V,"tkhd len=%d ver=%d flags=0x%X id=%d dur=%d lay=%d vol=%d\n",
+		    trak->tkdata_len, trak->tkdata[0], trak->tkdata[1],
+		    char2int(trak->tkdata,12), // id
+		    char2int(trak->tkdata,20), // duration
+		    char2short(trak->tkdata,32), // layer
+		    char2short(trak->tkdata,36)); // volume
+		break;
+	    }
+	    case MOV_FOURCC('m','d','h','d'): {
+		unsigned int tmp;
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sMedia header!\n",level,"");
+#if 0
+		tmp=stream_read_dword(demuxer->stream);
+		printf("dword1: 0x%08X (%d)\n",tmp,tmp);
+		tmp=stream_read_dword(demuxer->stream);
+		printf("dword2: 0x%08X (%d)\n",tmp,tmp);
+		tmp=stream_read_dword(demuxer->stream);
+		printf("dword3: 0x%08X (%d)\n",tmp,tmp);
+		tmp=stream_read_dword(demuxer->stream);
+		printf("dword4: 0x%08X (%d)\n",tmp,tmp);
+		tmp=stream_read_dword(demuxer->stream);
+		printf("dword5: 0x%08X (%d)\n",tmp,tmp);
+		tmp=stream_read_dword(demuxer->stream);
+		printf("dword6: 0x%08X (%d)\n",tmp,tmp);
+#endif
+		stream_skip(demuxer->stream,12);
+		// read timescale
+		trak->timescale=stream_read_dword(demuxer->stream);
+		// read length
+		trak->length=stream_read_dword(demuxer->stream);
+		break;
+	    }
+	    case MOV_FOURCC('h','d','l','r'): {
+		unsigned int tmp=stream_read_dword(demuxer->stream);
+		unsigned int type=stream_read_dword_le(demuxer->stream);
+		unsigned int subtype=stream_read_dword_le(demuxer->stream);
+		unsigned int manufact=stream_read_dword_le(demuxer->stream);
+		unsigned int comp_flags=stream_read_dword(demuxer->stream);
+		unsigned int comp_mask=stream_read_dword(demuxer->stream);
+		int len=stream_read_char(demuxer->stream);
+		char* str=malloc(len+1);
+		stream_read(demuxer->stream,str,len);
+		str[len]=0;
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sHandler header: %.4s/%.4s (%.4s) %s\n",level,"",&type,&subtype,&manufact,str);
+		free(str);
+		switch(bswap_32(type)){
+		case MOV_FOURCC('m','h','l','r'):
+		    trak->media_handler=bswap_32(subtype); break;
+		case MOV_FOURCC('d','h','l','r'):
+		    trak->data_handler=bswap_32(subtype); break;
+		default:
+		    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown handler class: 0x%X (%.4s)\n",bswap_32(type),&type);
+		}
+		break;
+	    }
+	    case MOV_FOURCC('v','m','h','d'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sVideo header!\n",level,"");
+		trak->type=MOV_TRAK_VIDEO;
+		// read video data
+		break;
+	    }
+	    case MOV_FOURCC('s','m','h','d'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSound header!\n",level,"");
+		trak->type=MOV_TRAK_AUDIO;
+		// read audio data
+		break;
+	    }
+	    case MOV_FOURCC('g','m','h','d'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sGeneric header!\n",level,"");
+		trak->type=MOV_TRAK_GENERIC;
+		break;
+	    }
+	    case MOV_FOURCC('n','m','h','d'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sGeneric header!\n",level,"");
+		trak->type=MOV_TRAK_GENERIC;
+		break;
+	    }
+	    case MOV_FOURCC('s','t','s','d'): {
+		int i=stream_read_dword(demuxer->stream); // temp!
+		int count=stream_read_dword(demuxer->stream);
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sDescription list! (cnt:%d)\n",level,"",count);
+		for(i=0;i<count;i++){
+		    off_t pos=stream_tell(demuxer->stream);
+		    off_t len=stream_read_dword(demuxer->stream);
+		    unsigned int fourcc=stream_read_dword_le(demuxer->stream);
+		    if(len<8) break; // error
+		    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*s desc #%d: %.4s  (%d bytes)\n",level,"",i,&fourcc,len-16);
+		    if(fourcc!=trak->fourcc && i)
+			mp_msg(MSGT_DEMUX,MSGL_WARN,MSGTR_MOVvariableFourCC);
+//		    if(!i)
+		    {
+			trak->fourcc=fourcc;
+			// read type specific (audio/video/time/text etc) header
+			// NOTE: trak type is not yet known at this point :(((
+			trak->stdata_len=len-8;
+			trak->stdata=malloc(trak->stdata_len);
+			stream_read(demuxer->stream,trak->stdata,trak->stdata_len);
+		    }
+		    if(!stream_seek(demuxer->stream,pos+len)) break;
+		}
+		break;
+	    }
+	    case MOV_FOURCC('s','t','t','s'): {
+		int temp=stream_read_dword(demuxer->stream);
+		int len=stream_read_dword(demuxer->stream);
+		int i;
+		unsigned int pts=0;
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample duration table! (%d blocks)\n",level,"",len);
+		trak->durmap=malloc(sizeof(mov_durmap_t)*len);
+		memset(trak->durmap,0,sizeof(mov_durmap_t)*len);
+		trak->durmap_size=len;
+		for(i=0;i<len;i++){
+		    trak->durmap[i].num=stream_read_dword(demuxer->stream);
+		    trak->durmap[i].dur=stream_read_dword(demuxer->stream);
+		    pts+=trak->durmap[i].num*trak->durmap[i].dur;
+		}
+		if(trak->length!=pts) mp_msg(MSGT_DEMUX, MSGL_WARN, "Warning! pts=%d  length=%d\n",pts,trak->length);
+		break;
+	    }
+	    case MOV_FOURCC('s','t','s','c'): {
+		int temp=stream_read_dword(demuxer->stream);
+		int len=stream_read_dword(demuxer->stream);
+		int ver = (temp << 24);
+		int flags = (temp << 16)|(temp<<8)|temp;
+		int i;
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample->Chunk mapping table!  (%d blocks) (ver:%d,flags:%ld)\n",
+		    level,"",len,ver,flags);
+		// read data:
+		trak->chunkmap_size=len;
+		trak->chunkmap=malloc(sizeof(mov_chunkmap_t)*len);
+		for(i=0;i<len;i++){
+		    trak->chunkmap[i].first=stream_read_dword(demuxer->stream)-1;
+		    trak->chunkmap[i].spc=stream_read_dword(demuxer->stream);
+		    trak->chunkmap[i].sdid=stream_read_dword(demuxer->stream);
+		}
+		break;
+	    }
+	    case MOV_FOURCC('s','t','s','z'): {
+		int temp=stream_read_dword(demuxer->stream);
+		int ss=stream_read_dword(demuxer->stream);
+		int ver = (temp << 24);
+		int flags = (temp << 16)|(temp<<8)|temp;
+		int entries=stream_read_dword(demuxer->stream);
+		int i;
+		
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample size table! (entries=%d ss=%d) (ver:%d,flags:%ld)\n",
+		    level,"",entries,ss,ver,flags);
+		trak->samplesize=ss;
+		if (!ss) {
+		  // variable samplesize
+		  trak->samples=realloc(trak->samples,sizeof(mov_sample_t)*entries);
+		  trak->samples_size=entries;
+		  for(i=0;i<entries;i++)
+		    trak->samples[i].size=stream_read_dword(demuxer->stream);
+		}
+		break;
+	    }
+	    case MOV_FOURCC('s','t','c','o'): {
+		int temp=stream_read_dword(demuxer->stream);
+		int len=stream_read_dword(demuxer->stream);
+		int i;
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sChunk offset table! (%d chunks)\n",level,"",len);
+		// extend array if needed:
+		if(len>trak->chunks_size){
+		    trak->chunks=realloc(trak->chunks,sizeof(mov_chunk_t)*len);
+		    trak->chunks_size=len;
+		}
+		// read elements:
+		for(i=0;i<len;i++) trak->chunks[i].pos=stream_read_dword(demuxer->stream);
+		break;
+	    }
+	    case MOV_FOURCC('c','o','6','4'): {
+		int temp=stream_read_dword(demuxer->stream);
+		int len=stream_read_dword(demuxer->stream);
+		int i;
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*s64bit chunk offset table! (%d chunks)\n",level,"",len);
+		// extend array if needed:
+		if(len>trak->chunks_size){
+		    trak->chunks=realloc(trak->chunks,sizeof(mov_chunk_t)*len);
+		    trak->chunks_size=len;
+		}
+		// read elements:
+		for(i=0;i<len;i++)
+		{
+#ifndef	_LARGEFILE_SOURCE
+		    if (stream_read_dword(demuxer->stream) != 0)
+			mp_msg(MSGT_DEMUX, MSGL_WARN, "Chunk %d has got 64bit address, but you've MPlayer compiled without LARGEFILE support!\n", i);
+		    trak->chunks[i].pos = stream_read_dword(demuxer->stream);
+#else
+		    trak->chunks[i].pos = stream_read_qword(demuxer->stream);
+#endif
+		}
+		break;
+	    }
+	    case MOV_FOURCC('s','t','s','s'): {
+		int temp=stream_read_dword(demuxer->stream);
+		int entries=stream_read_dword(demuxer->stream);
+		int ver = (temp << 24);
+		int flags = (temp << 16)|(temp<<8)|temp;
+		int i;
+		mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*sSyncing samples (keyframes) table! (%d entries) (ver:%d,flags:%ld)\n",
+		    level, "",entries, ver, flags);
+		trak->keyframes_size=entries;
+		trak->keyframes=malloc(sizeof(unsigned int)*entries);
+		for (i=0;i<entries;i++)
+		    trak->keyframes[i]=stream_read_dword(demuxer->stream)-1;
+//		for (i=0;i<entries;i++) printf("%3d: %d\n",i,trak->keyframes[i]);
+		break;
+	    }
+	    case MOV_FOURCC('m','d','i','a'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sMedia stream!\n",level,"");
+		lschunks(demuxer,level+1,pos+len,trak);
+		break;
+	    }
+	    case MOV_FOURCC('m','i','n','f'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sMedia info!\n",level,"");
+		lschunks(demuxer,level+1,pos+len,trak);
+		break;
+	    }
+	    case MOV_FOURCC('s','t','b','l'): {
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: %*sSample info!\n",level,"");
+		lschunks(demuxer,level+1,pos+len,trak);
+		break;
+	    }
+	    case MOV_FOURCC('e','d','t','s'): {
+		mp_msg(MSGT_DEMUX, MSGL_V, "MOV: %*sEdit atom!\n", level, "");
+		lschunks(demuxer,level+1,pos+len,trak);
+		break;
+	    }
+	    case MOV_FOURCC('e','l','s','t'): {
+		int temp=stream_read_dword(demuxer->stream);
+		int entries=stream_read_dword(demuxer->stream);
+		int ver = (temp << 24);
+		int flags = (temp << 16)|(temp<<8)|temp;
+		int i;
+	
+		mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*sEdit list table (%d entries) (ver:%d,flags:%ld)\n",
+		    level, "",entries, ver, flags);
+#if 1
+		trak->editlist_size=entries;
+		trak->editlist=malloc(trak->editlist_size*sizeof(mov_editlist_t));
+		for (i=0;i<entries;i++)
+		{
+		    int dur=stream_read_dword(demuxer->stream);
+		    int mt=stream_read_dword(demuxer->stream);
+		    int mr=stream_read_dword(demuxer->stream); // 16.16fp
+		    trak->editlist[i].dur=dur;
+		    trak->editlist[i].pos=mt;
+		    trak->editlist[i].speed=mr;
+		    mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*s  entry#%d: duration: %d  start time: %d  speed: %3.1fx\n",level,"",
+			i,
+			dur,mt,(float)mr/65536.0f);
+		}
+#endif
+		break;
+	    }
+	    case MOV_FOURCC('c','o','d','e'):
+	    {
+	    /* XXX: Implement atom 'code' for FLASH support */
+	    }
+	    default:
+		id = be2me_32(id);
+		mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",&id,(int)len);
+		break;
+	  }//switch(id)
+	} else { /* not in track */
+	  switch(id) {
+	    case MOV_FOURCC('m','v','h','d'): {
+		stream_skip(demuxer->stream,12);
+		priv->timescale=stream_read_dword(demuxer->stream);
+		priv->duration=stream_read_dword(demuxer->stream);
+		mp_msg(MSGT_DEMUX, MSGL_V,"MOV: %*sMovie header (%d bytes): tscale=%d  dur=%d\n",level,"",(int)len,
+		    (int)priv->timescale,(int)priv->duration);
+		break;
+	    }
+	    case MOV_FOURCC('t','r','a','k'): {
+//	    if(trak) printf("MOV: Warning! trak in trak?\n");
+	    if(priv->track_db>=MOV_MAX_TRACKS){
+		mp_msg(MSGT_DEMUX,MSGL_WARN,MSGTR_MOVtooManyTrk);
+		return;
+	    }
+	    if(!priv->track_db) mp_msg(MSGT_DEMUX, MSGL_INFO, "--------------\n");
+	    trak=malloc(sizeof(mov_track_t));
+	    memset(trak,0,sizeof(mov_track_t));
+	    mp_msg(MSGT_DEMUX,MSGL_V,"MOV: Track #%d:\n",priv->track_db);
+	    trak->id=priv->track_db;
+	    priv->tracks[priv->track_db]=trak;
+	    lschunks(demuxer,level+1,pos+len,trak);
+	    mov_build_index(trak,priv->timescale);
+	    switch(trak->type){
+	    case MOV_TRAK_AUDIO: {
+#if 0				   
+		struct {
+		   int16_t version;		// 0 or 1 (version 1 is qt3.0+)
+		   int16_t revision;		// 0
+		   int32_t vendor_id;		// 0
+		   int16_t channels;		// 1 or 2  (Mono/Stereo)
+		   int16_t samplesize;		// 8 or 16 (8Bit/16Bit)	
+		   int16_t compression_id;	// if version 0 then 0
+		  				// if version 1 and vbr then -2 else 0
+		   int16_t packet_size;		// 0
+		   uint16_t sample_rate;	// samplerate (Hz)
+		   // qt3.0+ (version == 1)
+		   uint32_t samples_per_packet;	// 0 or num uncompressed samples in a packet
+		   				// if 0 below three values are also 0
+		   uint32_t bytes_per_packet;	// 0 or num compressed bytes for one channel
+		   uint32_t bytes_per_frame;	// 0 or num compressed bytes for all channels
+		   				// (channels * bytes_per_packet)
+		   uint32_t bytes_per_sample;	// 0 or size of uncompressed sample
+		   // if samples_per_packet and bytes_per_packet are constant (CBR)
+		   // then bytes_per_frame and bytes_per_sample must be 0 (else is VBR)
+		   // ---
+		   // optional additional atom-based fields
+		   // ([int32_t size,int32_t type,some data ],repeat)
+		} my_stdata;		  
+#endif		
+		sh_audio_t* sh=new_sh_audio(demuxer,priv->track_db);
+		sh->format=trak->fourcc;
+
+// assumptions for below table: short is 16bit, int is 32bit, intfp is 16bit
+// XXX: 32bit fixed point numbers (intfp) are only 2 Byte!		
+// short values are usually one byte leftpadded by zero		
+//   int values are usually two byte leftpadded by zero		
+//  stdata[]:
+//	8   short	version
+//	10  short	revision
+//	12  int		vendor_id
+//	16  short	channels
+//	18  short	samplesize
+//	20  short	compression_id
+//	22  short	packet_size (==0)
+//	24  intfp	sample_rate
+//     (26  short)	unknown (==0)
+//    ---- qt3.0+ (version>=1)
+//	28  int		samples_per_packet
+//	32  int		bytes_per_packet
+//	36  int		bytes_per_frame
+//	40  int		bytes_per_sample
+// there may be additional atoms following at 28 (version 0)
+// or 44 (version 1), eg. esds atom of .MP4 files		
+// esds atom:
+//      28  int		atom size (bytes of int size, int type and data)
+//      32  char[4]	atom type (fourc charater code -> esds)		
+//      36  char[]  	atom data (len=size-8)
+
+		sh->samplesize=char2short(trak->stdata,18)/8;
+		sh->channels=char2short(trak->stdata,16);
+		/*printf("MOV: timescale: %d samplerate: %d durmap: %d (%d) -> %d (%d)\n",
+		    trak->timescale, char2short(trak->stdata,24), trak->durmap[0].dur,
+		    trak->durmap[0].num, trak->timescale/trak->durmap[0].dur,
+		    char2short(trak->stdata,24)/trak->durmap[0].dur);*/
+		sh->samplerate=char2short(trak->stdata,24);
+		if((sh->samplerate < 7000) && trak->durmap) {
+		  switch(char2short(trak->stdata,24)/trak->durmap[0].dur) {
+		    // TODO: add more cases.
+		    case 31:
+		      sh->samplerate = 32000; break;
+		    case 43:
+		      sh->samplerate = 44100; break;
+		    case 47:
+		      sh->samplerate = 48000; break;
+		    default:
+		      mp_msg(MSGT_DEMUX, MSGL_WARN,
+			  "MOV: unable to determine audio samplerate, "
+			  "assuming 44.1kHz (got %d)\n",
+			  char2short(trak->stdata,24)/trak->durmap[0].dur);
+		      sh->samplerate = 44100;
+		  }  
+		}  
+
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Audio bits: %d  chans: %d  rate: %d\n",
+		    trak->stdata[19],trak->stdata[17],sh->samplerate);
+
+		if(trak->stdata_len >= 44 && trak->stdata[9]>=1){
+		  mp_msg(MSGT_DEMUX,MSGL_V,"Audio header: samp/pack=%d bytes/pack=%d bytes/frame=%d bytes/samp=%d  \n",
+		    char2int(trak->stdata,28),
+		    char2int(trak->stdata,32),
+		    char2int(trak->stdata,36),
+		    char2int(trak->stdata,40));
+		  if(trak->stdata_len>=44+8){
+		    int len=char2int(trak->stdata,44);
+		    int fcc=char2int(trak->stdata,48);
+		    // we have extra audio headers!!!
+		    printf("Audio extra header: len=%d  fcc=0x%X\n",len,fcc);
+		    sh->codecdata_len = len-8;
+		    sh->codecdata = trak->stdata+44+8;
+		  }
+		}
+
+		if((trak->stdata[9]==0 || trak->stdata[9]==1) && trak->stdata_len >= 36) { // version 0 with extra atoms
+        int adjust = (trak->stdata[9]==1)?48:0;
+		    int atom_len = char2int(trak->stdata,28+adjust);
+		    switch(char2int(trak->stdata,32+adjust)) { // atom type
+		      case MOV_FOURCC('e','s','d','s'): {
+			mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found MPEG4 audio Elementary Stream Descriptor atom (%d)!\n", atom_len);
+			if(atom_len > 8) {
+			  esds_t esds; 				  
+			  if(!mp4_parse_esds(&trak->stdata[36+adjust], atom_len-8, &esds)) {
+			    
+			    sh->i_bps = esds.avgBitrate/8; 
+
+//			    printf("######## audio format = %d ########\n",esds.objectTypeId);
+			    if(esds.objectTypeId==107)
+				sh->format=0x55; // .mp3
+
+			    // dump away the codec specific configuration for the AAC decoder
+			    if(esds.decoderConfigLen){
+			    sh->codecdata_len = esds.decoderConfigLen;
+			    sh->codecdata = (unsigned char *)malloc(sh->codecdata_len);
+			    memcpy(sh->codecdata, esds.decoderConfig, sh->codecdata_len);
+			    }
+			  }
+			  mp4_free_esds(&esds); // freeup esds mem
+#if 0
+	  		  { FILE* f=fopen("esds.dat","wb");
+			  fwrite(&trak->stdata[36],atom_len-8,1,f);
+			  fclose(f); }
+#endif			  
+			}
+		      } break;
+		      default:
+			mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found unknown audio atom %c%c%c%c (%d)!\n",
+			    trak->stdata[32+adjust],trak->stdata[33+adjust],trak->stdata[34+adjust],trak->stdata[35+adjust],
+			    atom_len);
+		    }
+		}  
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Fourcc: %.4s\n",&trak->fourcc);
+#if 0
+		{ FILE* f=fopen("stdata.dat","wb");
+		  fwrite(trak->stdata,trak->stdata_len,1,f);
+		  fclose(f); }
+		{ FILE* f=fopen("tkdata.dat","wb");
+		  fwrite(trak->tkdata,trak->tkdata_len,1,f);
+		  fclose(f); }
+#endif
+		// Emulate WAVEFORMATEX struct:
+		sh->wf=malloc(sizeof(WAVEFORMATEX));
+		memset(sh->wf,0,sizeof(WAVEFORMATEX));
+		sh->wf->nChannels=(trak->stdata[16]<<8)+trak->stdata[17];
+		sh->wf->wBitsPerSample=(trak->stdata[18]<<8)+trak->stdata[19];
+		// sh->wf->nSamplesPerSec=trak->timescale;
+		sh->wf->nSamplesPerSec=(trak->stdata[24]<<8)+trak->stdata[25];
+		if(trak->stdata_len >= 44 && trak->stdata[9]>=1 && char2int(trak->stdata,28)>0){
+		//Audio header: samp/pack=4096 bytes/pack=743 bytes/frame=1486 bytes/samp=2
+		  sh->wf->nAvgBytesPerSec=(sh->wf->nChannels*sh->wf->nSamplesPerSec*
+		      char2int(trak->stdata,32)+char2int(trak->stdata,28)/2)
+		      /char2int(trak->stdata,28);
+		  sh->wf->nBlockAlign=char2int(trak->stdata,36);
+		} else {
+		  sh->wf->nAvgBytesPerSec=sh->wf->nChannels*sh->wf->wBitsPerSample*sh->wf->nSamplesPerSec/8;
+		  // workaround for ms11 ima4
+		  if (sh->format == 0x1100736d && trak->stdata_len >= 36)
+		      sh->wf->nBlockAlign=char2int(trak->stdata,36);
+		}
+		// Selection:
+//		if(demuxer->audio->id==-1 || demuxer->audio->id==priv->track_db){
+//		    // (auto)selected audio track:
+//		    demuxer->audio->id=priv->track_db;
+//		    demuxer->audio->sh=sh; sh->ds=demuxer->audio;
+//		}
+		break;
+	    }
+	    case MOV_TRAK_VIDEO: {
+		int i, entry;
+		int flag, start, count_flag, end, palette_count, gray;
+		int hdr_ptr = 76;  // the byte just after depth
+		unsigned char *palette_map;
+		sh_video_t* sh=new_sh_video(demuxer,priv->track_db);
+		int depth = trak->stdata[75]|(trak->stdata[74]<<8);
+		sh->format=trak->fourcc;
+
+//  stdata[]:
+//	8   short	version
+//	10  short	revision
+//	12  int		vendor_id
+//	16  int		temporal_quality
+//	20  int		spatial_quality
+//	24  short	width
+//	26  short	height
+//	28  int		h_dpi
+//	32  int		v_dpi
+//	36  int		0
+//	40  short	frames_per_sample
+//	42  char[4]	compressor_name
+//	74  short	depth
+//	76  short	color_table_id
+// additional atoms may follow,
+// eg esds atom from .MP4 files
+//      78  int		atom size
+//      82  char[4]	atom type
+//	86  ...		atom data
+
+	{	ImageDescription* id=malloc(8+trak->stdata_len);
+		trak->desc=id;
+		id->idSize=8+trak->stdata_len;
+//		id->cType=bswap_32(trak->fourcc);
+		id->cType=le2me_32(trak->fourcc);
+		id->version=char2short(trak->stdata,8);
+		id->revisionLevel=char2short(trak->stdata,10);
+		id->vendor=char2int(trak->stdata,12);
+		id->temporalQuality=char2int(trak->stdata,16);
+		id->spatialQuality=char2int(trak->stdata,20);
+		id->width=char2short(trak->stdata,24);
+		id->height=char2short(trak->stdata,26);
+		id->hRes=char2int(trak->stdata,28);
+		id->vRes=char2int(trak->stdata,32);
+		id->dataSize=char2int(trak->stdata,36);
+		id->frameCount=char2short(trak->stdata,40);
+		memcpy(&id->name,trak->stdata+42,32);
+		id->depth=char2short(trak->stdata,74);
+		id->clutID=char2short(trak->stdata,76);
+		if(trak->stdata_len>78)	memcpy(((char*)&id->clutID)+2,trak->stdata+78,trak->stdata_len-78);
+		sh->ImageDesc=id;
+#if 0
+		{   FILE *f=fopen("ImageDescription","wb");
+		    fwrite(id,id->idSize,1,f);
+		    fclose(f);
+		}
+#endif
+	}
+
+		if(trak->stdata_len >= 86) { // extra atoms found
+		  int pos=78;
+		  int atom_len;
+		  while(pos+8<=trak->stdata_len &&
+		    (pos+(atom_len=char2int(trak->stdata,pos)))<=trak->stdata_len){
+		   switch(char2int(trak->stdata,pos+4)) { // switch atom type
+		    case MOV_FOURCC('g','a','m','a'):
+		      // intfp with gamma value at which movie was captured
+		      // can be used to gamma correct movie display
+		      mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found unsupported Gamma-Correction movie atom (%d)!\n",
+			  atom_len);
+		      break;
+		    case MOV_FOURCC('f','i','e','l'):
+		      // 2 char-values (8bit int) that specify field handling
+		      // see the Apple's QuickTime Fileformat PDF for more info
+		      mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found unsupported Field-Handling movie atom (%d)!\n",
+			  atom_len);
+		      break;
+		    case MOV_FOURCC('m','j','q','t'):
+		      // Motion-JPEG default quantization table
+		      mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found unsupported MJPEG-Quantization movie atom (%d)!\n",
+			  atom_len);
+		      break;
+		    case MOV_FOURCC('m','j','h','t'):
+		      // Motion-JPEG default huffman table
+		      mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found unsupported MJPEG-Huffman movie atom (%d)!\n",
+			  atom_len);
+		      break;
+		    case MOV_FOURCC('e','s','d','s'):
+		      // MPEG4 Elementary Stream Descriptor header
+		      mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found MPEG4 movie Elementary Stream Descriptor atom (%d)!\n", atom_len);
+		      // add code here to save esds header of length atom_len-8
+		      // beginning at stdata[86] to some variable to pass it
+		      // on to the decoder ::atmos
+		      if(atom_len > 8) {
+      			esds_t esds; 				  
+			if(!mp4_parse_esds(trak->stdata+pos+8, atom_len-8, &esds)) {
+    
+			  // dump away the codec specific configuration for the AAC decoder
+			  trak->stream_header_len = esds.decoderConfigLen;
+			  trak->stream_header = (unsigned char *)malloc(trak->stream_header_len);
+			  memcpy(trak->stream_header, esds.decoderConfig, trak->stream_header_len);
+			}
+			mp4_free_esds(&esds); // freeup esds mem
+		      }	      
+		      break;
+		    case 0:
+		      break;
+		    default:
+	      	      mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Found unknown movie atom %c%c%c%c (%d)!\n",
+	      		  trak->stdata[pos+4],trak->stdata[pos+5],trak->stdata[pos+6],trak->stdata[pos+7],
+	      		  atom_len);
+		   }
+		   if(atom_len<8) break;
+		   pos+=atom_len;
+//		   printf("pos=%d max=%d\n",pos,trak->stdata_len);
+		  }
+		}
+		sh->fps=trak->timescale/
+		    ((trak->durmap_size>=1)?(float)trak->durmap[0].dur:1);
+		sh->frametime=1.0f/sh->fps;
+
+		sh->disp_w=trak->stdata[25]|(trak->stdata[24]<<8);
+		sh->disp_h=trak->stdata[27]|(trak->stdata[26]<<8);
+		// if image size is zero, fallback to display size
+		if(!sh->disp_w && !sh->disp_h) {
+		  sh->disp_w=trak->tkdata[77]|(trak->tkdata[76]<<8);
+		  sh->disp_h=trak->tkdata[81]|(trak->tkdata[80]<<8);
+		} else if(sh->disp_w!=(trak->tkdata[77]|(trak->tkdata[76]<<8))){
+		  // codec and display width differ... use display one for aspect
+		  sh->aspect=trak->tkdata[77]|(trak->tkdata[76]<<8);
+		  sh->aspect/=trak->tkdata[81]|(trak->tkdata[80]<<8);
+		}
+		
+		if(depth>32+8) printf("*** depth = 0x%X\n",depth);
+
+		// palettized?
+		gray = 0;
+		if (depth > 32) { depth&=31; gray = 1; } // depth > 32 means grayscale
+		if ((depth == 2) || (depth == 4) || (depth == 8))
+		  palette_count = (1 << depth);
+		else
+		  palette_count = 0;
+
+		// emulate BITMAPINFOHEADER:
+		if (palette_count)
+		{
+		  sh->bih=malloc(sizeof(BITMAPINFOHEADER) + palette_count * 4);
+		  memset(sh->bih,0,sizeof(BITMAPINFOHEADER) + palette_count * 4);
+		  sh->bih->biSize=40 + palette_count * 4;
+		  // fetch the relevant fields
+		  flag = BE_16(&trak->stdata[hdr_ptr]);
+		  hdr_ptr += 2;
+		  start = BE_32(&trak->stdata[hdr_ptr]);
+		  hdr_ptr += 4;
+		  count_flag = BE_16(&trak->stdata[hdr_ptr]);
+		  hdr_ptr += 2;
+		  end = BE_16(&trak->stdata[hdr_ptr]);
+		  hdr_ptr += 2;
+		  palette_map = (unsigned char *)sh->bih + 40;
+		  mp_msg(MSGT_DEMUX, MSGL_INFO, "Allocated %d entries for palette\n",
+		    palette_count);
+		  mp_msg(MSGT_DEMUX, MSGL_DBG2, "QT palette: start: %x, end: %x, count flag: %d, flags: %x\n",
+		    start, end, count_flag, flag);
+
+		  /* XXX: problems with sample (statunit6.mov) with flag&0x4 set! - alex*/
+
+		  // load default palette
+		  if (flag & 0x08)
+		  {
+		    if (gray)
+		    {
+		      mp_msg(MSGT_DEMUX, MSGL_INFO, "Using default QT grayscale palette\n");
+		      if (palette_count == 16)
+		        memcpy(palette_map, qt_default_grayscale_palette_16, 16 * 4);
+		      else if (palette_count == 256) {
+		        memcpy(palette_map, qt_default_grayscale_palette_256, 256 * 4);
+		        if (trak->fourcc == mmioFOURCC('c','v','i','d')) {
+		          int i;
+		          // Hack for grayscale CVID, negative palette
+		          // If you have samples where this is not required contact me (rxt)
+		          mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: greyscale cvid with default palette,"
+		            " enabling negative palette hack.\n");
+		          for (i = 0; i < 256 * 4; i++)
+		            palette_map[i] = palette_map[i] ^ 0xff;
+		        }
+		      }
+		    }
+		    else
+		    {
+		      mp_msg(MSGT_DEMUX, MSGL_INFO, "Using default QT colour palette\n");
+		      if (palette_count == 4)
+		        memcpy(palette_map, qt_default_palette_4, 4 * 4);
+		      else if (palette_count == 16)
+		        memcpy(palette_map, qt_default_palette_16, 16 * 4);
+		      else if (palette_count == 256)
+		        memcpy(palette_map, qt_default_palette_256, 256 * 4);
+		    }
+		  }
+		  // load palette from file
+		  else
+		  {
+		    mp_msg(MSGT_DEMUX, MSGL_INFO, "Loading palette from file\n");
+		    for (i = start; i <= end; i++)
+		    {
+		      entry = BE_16(&trak->stdata[hdr_ptr]);
+		      hdr_ptr += 2;
+		      // apparently, if count_flag is set, entry is same as i
+		      if (count_flag & 0x8000)
+		        entry = i;
+		      // only care about top 8 bits of 16-bit R, G, or B value
+		      if (entry <= palette_count && entry >= 0)
+		      {
+		        palette_map[entry * 4 + 2] = trak->stdata[hdr_ptr + 0];
+		        palette_map[entry * 4 + 1] = trak->stdata[hdr_ptr + 2];
+		        palette_map[entry * 4 + 0] = trak->stdata[hdr_ptr + 4];
+		        mp_dbg(MSGT_DEMUX, MSGL_DBG2, "QT palette: added entry: %d of %d (colors: R:%x G:%x B:%x)\n",
+			    entry, palette_count,
+			    palette_map[entry * 4 + 2], 
+			    palette_map[entry * 4 + 1],
+			    palette_map[entry * 4 + 0]);
+		      }
+		      else
+		        mp_msg(MSGT_DEMUX, MSGL_V, "QT palette: skipped entry (out of count): %d of %d\n",
+			    entry, palette_count);
+		      hdr_ptr += 6;
+		    }
+		  }
+		}
+		else
+		{
+		  sh->bih=malloc(sizeof(BITMAPINFOHEADER));
+		  memset(sh->bih,0,sizeof(BITMAPINFOHEADER));
+		  sh->bih->biSize=40;
+		}
+		sh->bih->biWidth=sh->disp_w;
+		sh->bih->biHeight=sh->disp_h;
+		sh->bih->biPlanes=0;
+		sh->bih->biBitCount=depth;
+		sh->bih->biCompression=trak->fourcc;
+		sh->bih->biSizeImage=sh->bih->biWidth*sh->bih->biHeight;
+
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Image size: %d x %d (%d bpp)\n",sh->disp_w,sh->disp_h,sh->bih->biBitCount);
+		if(trak->tkdata_len>81)
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Display size: %d x %d\n",
+		    trak->tkdata[77]|(trak->tkdata[76]<<8),
+		    trak->tkdata[81]|(trak->tkdata[80]<<8));
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Fourcc: %.4s  Codec: '%.*s'\n",&trak->fourcc,trak->stdata[42]&31,trak->stdata+43);
+		
+//		if(demuxer->video->id==-1 || demuxer->video->id==priv->track_db){
+//		    // (auto)selected video track:
+//		    demuxer->video->id=priv->track_db;
+//		    demuxer->video->sh=sh; sh->ds=demuxer->video;
+//		}
+		break;
+	    }
+	    case MOV_TRAK_GENERIC:
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Generic track - not completely understood! (id: %d)\n",
+		    trak->id);
+		/* XXX: Also this contains the FLASH data */
+
+#if 0
+	    {
+		int pos = stream_tell(demuxer->stream);
+		int i;
+		int fd;
+		char name[20];
+	
+		for (i=0; i<trak->samples_size; i++)
+		{
+		    char buf[trak->samples[i].size];
+		    stream_seek(demuxer->stream, trak->samples[i].pos);
+		    snprintf((char *)&name[0], 20, "samp%d", i);
+		    fd = open((char *)&name[0], O_CREAT|O_WRONLY);
+		    stream_read(demuxer->stream, &buf[0], trak->samples[i].size);
+		    write(fd, &buf[0], trak->samples[i].size);
+		    close(fd);
+		 }
+		for (i=0; i<trak->chunks_size; i++)
+		{
+		    char buf[trak->length];
+		    stream_seek(demuxer->stream, trak->chunks[i].pos);
+		    snprintf((char *)&name[0], 20, "chunk%d", i);
+		    fd = open((char *)&name[0], O_CREAT|O_WRONLY);
+		    stream_read(demuxer->stream, &buf[0], trak->length);
+		    write(fd, &buf[0], trak->length);
+		    close(fd);
+		 }
+		 if (trak->samplesize > 0)
+		 {
+		    char *buf;
+		    
+		    buf = malloc(trak->samplesize);
+		    stream_seek(demuxer->stream, trak->chunks[0].pos);
+		    snprintf((char *)&name[0], 20, "trak%d", trak->id);
+		    fd = open((char *)&name[0], O_CREAT|O_WRONLY);
+		    stream_read(demuxer->stream, buf, trak->samplesize);
+		    write(fd, buf, trak->samplesize);
+		    close(fd);
+		 }
+		 stream_seek(demuxer->stream, pos);
+	    }		
+#endif
+		break;
+	    default:
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "Unknown track type found (type: %d)\n", trak->type);
+		break;
+	    }
+	    mp_msg(MSGT_DEMUX, MSGL_INFO, "--------------\n");
+	    priv->track_db++;
+	    trak=NULL;
+	    break;
+	}
+#ifndef HAVE_ZLIB
+	case MOV_FOURCC('c','m','o','v'): {
+	    mp_msg(MSGT_DEMUX,MSGL_ERR,MSGTR_MOVcomprhdr);
+	    return;
+	}
+#else
+	case MOV_FOURCC('m','o','o','v'):
+	case MOV_FOURCC('c','m','o','v'): {
+//	    mp_msg(MSGT_DEMUX,MSGL_ERR,MSGTR_MOVcomprhdr);
+	    lschunks(demuxer,level+1,pos+len,NULL);
+	    break;
+	}
+	case MOV_FOURCC('d','c','o','m'): {
+//	    int temp=stream_read_dword(demuxer->stream);
+	    unsigned int algo=be2me_32(stream_read_dword(demuxer->stream));
+	    mp_msg(MSGT_DEMUX, MSGL_INFO, "Compressed header uses %.4s algo!\n",&algo);
+	    break;
+	}
+	case MOV_FOURCC('c','m','v','d'): {
+//	    int temp=stream_read_dword(demuxer->stream);
+	    unsigned int moov_sz=stream_read_dword(demuxer->stream);
+	    unsigned int cmov_sz=len-4;
+	    unsigned char* cmov_buf=malloc(cmov_sz);
+	    unsigned char* moov_buf=malloc(moov_sz+16);
+	    int zret;
+	    z_stream zstrm;
+	    stream_t* backup;
+
+	    mp_msg(MSGT_DEMUX, MSGL_INFO, "Compressed header size: %d / %d\n",cmov_sz,moov_sz);
+
+	    stream_read(demuxer->stream,cmov_buf,cmov_sz);
+
+	      zstrm.zalloc          = (alloc_func)0;
+	      zstrm.zfree           = (free_func)0;
+	      zstrm.opaque          = (voidpf)0;
+	      zstrm.next_in         = cmov_buf;
+	      zstrm.avail_in        = cmov_sz;
+	      zstrm.next_out        = moov_buf;
+	      zstrm.avail_out       = moov_sz;
+	    
+	      zret = inflateInit(&zstrm);
+	      if (zret != Z_OK)
+		{ mp_msg(MSGT_DEMUX, MSGL_ERR, "QT cmov: inflateInit err %d\n",zret);
+		return;
+		}
+	      zret = inflate(&zstrm, Z_NO_FLUSH);
+	      if ((zret != Z_OK) && (zret != Z_STREAM_END))
+		{ mp_msg(MSGT_DEMUX, MSGL_ERR, "QT cmov inflate: ERR %d\n",zret);
+		return;
+		}
+#if 0
+	      else {
+		FILE *DecOut;
+		DecOut = fopen("Out.bin", "w");
+		fwrite(moov_buf, 1, moov_sz, DecOut);
+		fclose(DecOut);
+	      }
+#endif
+	      if(moov_sz != zstrm.total_out)
+	        mp_msg(MSGT_DEMUX, MSGL_WARN, "Warning! moov size differs cmov: %d  zlib: %d\n",moov_sz,zstrm.total_out);
+	      zret = inflateEnd(&zstrm);
+	      
+	      backup=demuxer->stream;
+	       demuxer->stream=new_memory_stream(moov_buf,moov_sz);
+	       stream_skip(demuxer->stream,8);
+	       lschunks(demuxer,level+1,moov_sz,NULL); // parse uncompr. 'moov'
+	       //free_stream(demuxer->stream);
+	      demuxer->stream=backup;
+	      free(cmov_buf);
+	      free(moov_buf);	    
+	      break;
+	}
+#endif
+	case MOV_FOURCC('u','d','t','a'):
+	{
+	    unsigned int udta_id;
+	    off_t udta_len;
+	    off_t udta_size = len;
+	
+	    mp_msg(MSGT_DEMUX, MSGL_DBG2, "mov: user data record found\n");
+	    mp_msg(MSGT_DEMUX, MSGL_V, "Quicktime Clip Info:\n");
+
+	    while((len > 8) && (udta_size > 8))
+	    {
+		udta_len = stream_read_dword(demuxer->stream);
+		udta_id = stream_read_dword(demuxer->stream);
+		udta_size -= 8;
+		mp_msg(MSGT_DEMUX, MSGL_DBG2, "udta_id: %.4s (len: %d)\n", &udta_id, udta_len);
+		switch (udta_id)
+		{
+		    case MOV_FOURCC(0xa9,'c','p','y'):
+		    case MOV_FOURCC(0xa9,'d','a','y'):
+		    case MOV_FOURCC(0xa9,'d','i','r'):
+		    /* 0xa9,'e','d','1' - '9' : edit timestamps */
+		    case MOV_FOURCC(0xa9,'f','m','t'):
+		    case MOV_FOURCC(0xa9,'i','n','f'):
+		    case MOV_FOURCC(0xa9,'p','r','d'):
+		    case MOV_FOURCC(0xa9,'p','r','f'):
+		    case MOV_FOURCC(0xa9,'r','e','q'):
+		    case MOV_FOURCC(0xa9,'s','r','c'):
+		    case MOV_FOURCC('n','a','m','e'):
+		    case MOV_FOURCC(0xa9,'n','a','m'):
+		    case MOV_FOURCC(0xa9,'A','R','T'):
+		    case MOV_FOURCC(0xa9,'c','m','t'):
+		    case MOV_FOURCC(0xa9,'a','u','t'):
+		    case MOV_FOURCC(0xa9,'s','w','r'):
+		    {
+			off_t text_len = stream_read_word(demuxer->stream);
+			char text[text_len+2+1];
+			stream_read(demuxer->stream, (char *)&text, text_len+2);
+			text[text_len+2] = 0x0;
+			switch(udta_id)
+			{
+			    case MOV_FOURCC(0xa9,'a','u','t'):
+				demux_info_add(demuxer, "author", &text[2]);
+				mp_msg(MSGT_DEMUX, MSGL_V, " Author: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'c','p','y'):
+				demux_info_add(demuxer, "copyright", &text[2]);
+				mp_msg(MSGT_DEMUX, MSGL_V, " Copyright: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'i','n','f'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Info: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC('n','a','m','e'):
+			    case MOV_FOURCC(0xa9,'n','a','m'):
+				demux_info_add(demuxer, "name", &text[2]);
+				mp_msg(MSGT_DEMUX, MSGL_V, " Name: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'A','R','T'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Artist: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'d','i','r'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Director: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'c','m','t'):
+				demux_info_add(demuxer, "comments", &text[2]);
+				mp_msg(MSGT_DEMUX, MSGL_V, " Comment: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'r','e','q'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Requirements: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'s','w','r'):
+				demux_info_add(demuxer, "encoder", &text[2]);
+				mp_msg(MSGT_DEMUX, MSGL_V, " Software: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'d','a','y'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Creation timestamp: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'f','m','t'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Format: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'p','r','d'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Producer: %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'p','r','f'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Performer(s): %s\n", &text[2]);
+				break;
+			    case MOV_FOURCC(0xa9,'s','r','c'):
+				mp_msg(MSGT_DEMUX, MSGL_V, " Source providers: %s\n", &text[2]);
+				break;
+			}
+			udta_size -= 4+text_len;
+			break;
+		    }
+		    /* some other shits:    WLOC - window location,
+					    LOOP - looping style,
+					    SelO - play only selected frames
+					    AllF - play all frames
+		    */
+		    case MOV_FOURCC('W','L','O','C'):
+		    case MOV_FOURCC('L','O','O','P'):
+		    case MOV_FOURCC('S','e','l','O'):
+		    case MOV_FOURCC('A','l','l','F'):
+		    default:
+		    {
+			if( udta_len>udta_size)
+				udta_len=udta_size;
+			{
+			char dump[udta_len-4];
+			stream_read(demuxer->stream, (char *)&dump, udta_len-4-4);
+			udta_size -= udta_len;
+			}
+		    }
+		}
+	    }
+	    break;
+	} /* eof udta */
+	default:
+	  id = be2me_32(id);
+	  mp_msg(MSGT_DEMUX,MSGL_V,"MOV: unknown chunk: %.4s %d\n",&id,(int)len);
+	} /* endof switch */
+	} /* endof else */
+
+	pos+=len+8;
+	if(pos>=endpos) break;
+	if(!stream_seek(demuxer->stream,pos)) break;
+    }
+}
+
+int mov_read_header(demuxer_t* demuxer){
+    mov_priv_t* priv=demuxer->priv;
+    int t_no;
+    int best_a_id=-1, best_a_len=0;
+    int best_v_id=-1, best_v_len=0;
+    
+    mp_msg(MSGT_DEMUX, MSGL_DBG3, "mov_read_header!\n");
+
+    // Parse header:    
+    stream_reset(demuxer->stream);
+    if(!stream_seek(demuxer->stream,priv->moov_start))
+    {
+	mp_msg(MSGT_DEMUX,MSGL_ERR,"MOV: Cannot seek to the beginning of the Movie header (0x%x)\n",
+	    priv->moov_start);
+	return 0;
+    }
+    lschunks(demuxer, 0, priv->moov_end, NULL);
+//    mp_msg(MSGT_DEMUX, MSGL_INFO, "--------------\n");
+
+    // find the best (longest) streams:
+    for(t_no=0;t_no<priv->track_db;t_no++){
+        mov_track_t* trak=priv->tracks[t_no];
+	int len=(trak->samplesize) ? trak->chunks_size : trak->samples_size;
+	if(demuxer->a_streams[t_no]){ // need audio
+	    if(len>best_a_len){	best_a_len=len; best_a_id=t_no; }
+	}
+	if(demuxer->v_streams[t_no]){ // need video
+	    if(len>best_v_len){	best_v_len=len; best_v_id=t_no; }
+	}
+    }
+    mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: longest streams: A: #%d (%d samples)  V: #%d (%d samples)\n",
+	best_a_id,best_a_len,best_v_id,best_v_len);
+    if(demuxer->audio->id==-1 && best_a_id>=0) demuxer->audio->id=best_a_id;
+    if(demuxer->video->id==-1 && best_v_id>=0) demuxer->video->id=best_v_id;
+    
+    // setup sh pointers:
+    if(demuxer->audio->id>=0){
+	sh_audio_t* sh=demuxer->a_streams[demuxer->audio->id];
+	if(sh){
+	    demuxer->audio->sh=sh; sh->ds=demuxer->audio;
+	} else {
+	    mp_msg(MSGT_DEMUX, MSGL_ERR, "MOV: selected audio stream (%d) does not exists\n",demuxer->audio->id);
+	    demuxer->audio->id=-2;
+	}
+    }
+    if(demuxer->video->id>=0){
+	sh_video_t* sh=demuxer->v_streams[demuxer->video->id];
+	if(sh){
+	    demuxer->video->sh=sh; sh->ds=demuxer->video;
+	} else {
+	    mp_msg(MSGT_DEMUX, MSGL_ERR, "MOV: selected video stream (%d) does not exists\n",demuxer->video->id);
+	    demuxer->video->id=-2;
+	}
+    }
+
+#if 1
+    if(verbose>2){
+	for(t_no=0;t_no<priv->track_db;t_no++){
+	    mov_track_t* trak=priv->tracks[t_no];
+	    if(trak->type==MOV_TRAK_GENERIC){
+		int i;
+		int fd;
+		char name[20];
+		mp_msg(MSGT_DEMUX, MSGL_INFO, "MOV: Track #%d: Extracting %d data chunks to files\n",t_no,trak->samples_size);
+		for (i=0; i<trak->samples_size; i++)
+		{
+		    int len=trak->samples[i].size;
+		    char buf[len];
+		    stream_seek(demuxer->stream, trak->samples[i].pos);
+		    snprintf(name, 20, "t%02d-s%03d.%s", t_no,i,
+			(trak->media_handler==MOV_FOURCC('f','l','s','h')) ?
+			    "swf":"dump");
+		    fd = open(name, O_CREAT|O_WRONLY);
+//		    { int j;
+//			for(j=0;j<trak->stdata_len-3; j++)
+//			    printf("stdata[%d]=0x%X ize=0x%X\n",j,char2int(trak->stdata,j),MOV_FOURCC('z','l','i','b'));
+//		    }
+		    if( //trak->media_handler==MOV_FOURCC('s','p','r','t') &&
+			trak->stdata_len>=16 &&
+			char2int(trak->stdata,12)==MOV_FOURCC('z','l','i','b') 
+		    ){
+			int newlen=stream_read_dword(demuxer->stream);
+#ifdef HAVE_ZLIB
+			// unzip:
+			z_stream zstrm;
+			int zret;
+			char buf2[newlen];
+
+			len-=4;
+			stream_read(demuxer->stream, buf, len);
+
+	                zstrm.zalloc          = (alloc_func)0;
+	                zstrm.zfree           = (free_func)0;
+	                zstrm.opaque          = (voidpf)0;
+	                zstrm.next_in         = buf;
+	                zstrm.avail_in        = len;
+	                zstrm.next_out        = buf2;
+	                zstrm.avail_out       = newlen;
+
+	                zret = inflateInit(&zstrm);
+			zret = inflate(&zstrm, Z_NO_FLUSH);
+			if(newlen != zstrm.total_out)
+	    		    mp_msg(MSGT_DEMUX, MSGL_WARN, "Warning! unzipped frame size differs hdr: %d  zlib: %d\n",newlen,zstrm.total_out);
+			
+			write(fd, buf2, newlen);
+		    } else {
+#else
+			len-=4;
+			printf("******* ZLIB COMPRESSED SAMPLE!!!!! (%d->%d bytes) *******\n",len,newlen);
+		    }
+		    {
+#endif
+			stream_read(demuxer->stream, buf, len);
+			write(fd, buf, len);
+		    }
+		    close(fd);
+		}
+	    }
+	}
+    }
+#endif
+
+    return 1;
+}
+
+// return value:
+//     0 = EOF or no stream found
+//     1 = successfully read a packet
+int demux_mov_fill_buffer(demuxer_t *demuxer,demux_stream_t* ds){
+    mov_priv_t* priv=demuxer->priv;
+    mov_track_t* trak=NULL;
+    float pts;
+    int x;
+    off_t pos;
+    
+    if(ds->id<0 || ds->id>=priv->track_db) return 0;
+    trak=priv->tracks[ds->id];
+
+if(trak->samplesize){
+    // read chunk:
+    if(trak->pos>=trak->chunks_size) return 0; // EOF
+    stream_seek(demuxer->stream,trak->chunks[trak->pos].pos);
+    pts=(float)(trak->chunks[trak->pos].sample*trak->duration)/(float)trak->timescale;
+    if(trak->samplesize!=1)
+    {
+	mp_msg(MSGT_DEMUX, MSGL_DBG2, "WARNING! Samplesize(%d) != 1\n",
+	    trak->samplesize);
+	x=trak->chunks[trak->pos].size*trak->samplesize;
+    }
+    else
+	x=trak->chunks[trak->pos].size;
+//    printf("X = %d\n", x);
+    /* the following stuff is audio related */
+    if (trak->type == MOV_TRAK_AUDIO){
+      if(trak->stdata_len>=44 && trak->stdata[9]>=1 && char2int(trak->stdata,28)>0){
+        // stsd version 1 - we have audio compression ratio info:
+	x/=char2int(trak->stdata,28); // samples/packet
+//	x*=char2int(trak->stdata,32); // bytes/packet
+	x*=char2int(trak->stdata,36); // bytes/frame
+      } else {
+	if(ds->ss_div && ds->ss_mul){
+	    // workaround for buggy files like 7up-high-traffic-areas.mov,
+	    // with missing stsd v1 header containing compression rate
+	    x/=ds->ss_div; x*=ds->ss_mul; // compression ratio fix  ! HACK !
+	} else {
+	    x*=(trak->stdata[16]<<8)+trak->stdata[17]; //channels
+	    x*=(trak->stdata[18]<<8)+trak->stdata[19]; //bits/sample
+	    x/=8;  // bits/sample
+	}
+      }
+      mp_msg(MSGT_DEMUX, MSGL_DBG2, "Audio sample %d bytes pts %5.3f\n",trak->chunks[trak->pos].size*trak->samplesize,pts);
+    } /* MOV_TRAK_AUDIO */
+    pos=trak->chunks[trak->pos].pos;
+} else {
+    int frame=trak->pos;
+    // editlist support:
+    if(trak->type == MOV_TRAK_VIDEO && trak->editlist_size>=1){
+	// find the right editlist entry:
+	if(frame<trak->editlist[trak->editlist_pos].start_frame)
+	    trak->editlist_pos=0;
+	while(trak->editlist_pos<trak->editlist_size-1 &&
+	    frame>=trak->editlist[trak->editlist_pos+1].start_frame)
+		++trak->editlist_pos;
+	if(frame>=trak->editlist[trak->editlist_pos].start_frame+
+	    trak->editlist[trak->editlist_pos].frames) return 0; // EOF
+	// calc real frame index:
+	frame-=trak->editlist[trak->editlist_pos].start_frame;
+	frame+=trak->editlist[trak->editlist_pos].start_sample;
+	// calc pts:
+	pts=(float)(trak->samples[frame].pts+
+	    trak->editlist[trak->editlist_pos].pts_offset)/(float)trak->timescale;
+    } else {
+	if(frame>=trak->samples_size) return 0; // EOF
+	pts=(float)trak->samples[frame].pts/(float)trak->timescale;
+    }
+    // read sample:
+    stream_seek(demuxer->stream,trak->samples[frame].pos);
+    x=trak->samples[frame].size;
+    pos=trak->samples[frame].pos;
+}
+if(trak->pos==0 && trak->stream_header_len>0){
+    // we have to append the stream header...
+    demux_packet_t* dp=new_demux_packet(x+trak->stream_header_len);
+    memcpy(dp->buffer,trak->stream_header,trak->stream_header_len);
+    stream_read(demuxer->stream,dp->buffer+trak->stream_header_len,x);
+    free(trak->stream_header);
+    trak->stream_header = NULL;
+    trak->stream_header_len = 0;
+    dp->pts=pts;
+    dp->flags=0;
+    dp->pos=pos; // FIXME?
+    ds_add_packet(ds,dp);
+} else
+    ds_read_packet(ds,demuxer->stream,x,pts,pos,0);
+    
+    ++trak->pos;
+
+    return 1;
+    
+}
+
+static float mov_seek_track(mov_track_t* trak,float pts,int flags){
+
+//    printf("MOV track seek called  %5.3f  \n",pts);
+    if(flags&2) pts*=trak->length; else pts*=(float)trak->timescale;
+
+if(trak->samplesize){
+    int sample=pts/trak->duration;
+//    printf("MOV track seek - chunk: %d  (pts: %5.3f  dur=%d)  \n",sample,pts,trak->duration);
+    if(!(flags&1)) sample+=trak->chunks[trak->pos].sample; // relative
+    trak->pos=0;
+    while(trak->pos<trak->chunks_size && trak->chunks[trak->pos].sample<sample) ++trak->pos;
+    pts=(float)(trak->chunks[trak->pos].sample*trak->duration)/(float)trak->timescale;
+} else {
+    unsigned int ipts;
+    if(!(flags&1)) pts+=trak->samples[trak->pos].pts;
+    if(pts<0) pts=0;
+    ipts=pts;
+    //printf("MOV track seek - sample: %d  \n",ipts);
+    for(trak->pos=0;trak->pos<trak->samples_size;++trak->pos){
+	if(trak->samples[trak->pos].pts>=ipts) break; // found it!
+    }
+    if(trak->keyframes_size){
+	// find nearest keyframe
+	int i;
+	for(i=0;i<trak->keyframes_size;i++){
+	    if(trak->keyframes[i]>=trak->pos) break;
+	}
+	if(i>0 && (trak->keyframes[i]-trak->pos) > (trak->pos-trak->keyframes[i-1]))
+	  --i;
+	trak->pos=trak->keyframes[i];
+//	printf("nearest keyframe: %d  \n",trak->pos);
+    }
+    pts=(float)trak->samples[trak->pos].pts/(float)trak->timescale;
+}
+
+//    printf("MOV track seek done:  %5.3f  \n",pts);
+
+return pts;
+}
+
+void demux_seek_mov(demuxer_t *demuxer,float pts,int flags){
+    mov_priv_t* priv=demuxer->priv;
+    demux_stream_t* ds;
+
+//    printf("MOV seek called  %5.3f  flag=%d  \n",pts,flags);
+    
+    ds=demuxer->video;
+    if(ds && ds->id>=0 && ds->id<priv->track_db){
+	mov_track_t* trak=priv->tracks[ds->id];
+	//if(flags&2) pts*=(float)trak->length/(float)trak->timescale;
+	//if(!(flags&1)) pts+=ds->pts;
+	pts=ds->pts=mov_seek_track(trak,pts,flags);
+	flags=1; // absolute seconds
+    }
+
+    ds=demuxer->audio;
+    if(ds && ds->id>=0 && ds->id<priv->track_db){
+	mov_track_t* trak=priv->tracks[ds->id];
+	//if(flags&2) pts*=(float)trak->length/(float)trak->timescale;
+	//if(!(flags&1)) pts+=ds->pts;
+	ds->pts=mov_seek_track(trak,pts,flags);
+    }
+
+}
+
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_mpg.c MPlayer-1.0pre5/libmpdemux/demux_mpg.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_mpg.c	2003-12-09 03:34:05 +0600
+++ MPlayer-1.0pre5/libmpdemux/demux_mpg.c	2004-08-08 10:36:04 +0700
@@ -291,7 +291,11 @@
   if(demux->synced==1){
     if(head==0x1BB || head==0x1BD || (head>=0x1C0 && head<=0x1EF)){
       demux->synced=2;
+#ifdef _LARGEFILE_SOURCE 
+      mp_msg(MSGT_DEMUX,MSGL_V,"system stream synced at 0x%llX (%lld)!\n",demux->filepos,demux->filepos);
+#else
       mp_msg(MSGT_DEMUX,MSGL_V,"system stream synced at 0x%X (%d)!\n",demux->filepos,demux->filepos);
+#endif
       num_elementary_packets100=0; // requires for re-sync!
       num_elementary_packets101=0; // requires for re-sync!
     } else demux->synced=0;
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_pva.c MPlayer-1.0pre5/libmpdemux/demux_pva.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_pva.c	2002-11-23 16:58:08 +0600
+++ MPlayer-1.0pre5/libmpdemux/demux_pva.c	2004-08-08 10:36:04 +0700
@@ -326,7 +326,11 @@
 	{
 		if(stream_read_word(d->stream) != (('A'<<8)|'V'))
 		{
+#ifdef _LARGEFILE_SOURCE 
+			mp_msg(MSGT_DEMUX,MSGL_V,"demux_pva: pva_get_payload() missed a SyncWord at %lld!! Trying to sync...\n",stream_tell(d->stream));
+#else
 			mp_msg(MSGT_DEMUX,MSGL_V,"demux_pva: pva_get_payload() missed a SyncWord at %ld!! Trying to sync...\n",stream_tell(d->stream));
+#endif
 			if(!pva_sync(d))
 			{
 				if (!d->stream->eof)
@@ -350,7 +354,11 @@
 	flags=stream_read_char(d->stream);
 	payload->is_packet_start=flags & 0x10;
 	pack_size=le2me_16(stream_read_word(d->stream));
+#ifdef _LARGEFILE_SOURCE 
+	mp_msg(MSGT_DEMUX,MSGL_DBG2,"demux_pva::pva_get_payload(): pack_size=%u field read at offset %llu\n",pack_size,stream_tell(d->stream)-2);
+#else
 	mp_msg(MSGT_DEMUX,MSGL_DBG2,"demux_pva::pva_get_payload(): pack_size=%u field read at offset %lu\n",pack_size,stream_tell(d->stream)-2);
+#endif
 	pva_payload_start=stream_tell(d->stream);
 	next_offset=pva_payload_start+pack_size;
 
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_real.c MPlayer-1.0pre5/libmpdemux/demux_real.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_real.c	2004-06-26 01:45:56 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_real.c	2004-08-08 10:36:04 +0700
@@ -1047,7 +1047,7 @@
 		tmp = stream_read_dword(demuxer->stream);
 		
 		mp_msg(MSGT_DEMUX,MSGL_DBG2,"demux_real: type_spec: len=%d  fpos=0x%X  first_dword=0x%X (%.4s)  \n",
-		    (int)codec_data_size,(int)codec_pos,tmp,&tmp);
+		    (int)codec_data_size,(int)codec_pos,tmp,(char *)&tmp);
 
 #if 1
 		// skip unknown shit - FIXME: find a better/cleaner way!
@@ -1503,7 +1503,7 @@
     if(demuxer->video->sh){
 	sh_video_t *sh=demuxer->video->sh;
 	mp_msg(MSGT_DEMUX,MSGL_INFO,"VIDEO:  %.4s [%08X,%08X]  %dx%d  (aspect %4.2f)  %4.2f fps\n",
-	    &sh->format,((unsigned int*)(sh->bih+1))[1],((unsigned int*)(sh->bih+1))[0],
+	    (char *)&sh->format,((unsigned int*)(sh->bih+1))[1],((unsigned int*)(sh->bih+1))[0],
 	    sh->disp_w,sh->disp_h,sh->aspect,sh->fps);
     }
 
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_real.c.orig MPlayer-1.0pre5/libmpdemux/demux_real.c.orig
--- MPlayer-1.0pre5.orig/libmpdemux/demux_real.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_real.c.orig	2004-06-26 01:45:56 +0700
@@ -0,0 +1,1642 @@
+/*
+    Real parser & demuxer
+    
+    (C) Alex Beregszaszi
+    
+    Based on FFmpeg's libav/rm.c.
+
+Audio codecs: (supported by RealPlayer8 for Linux)
+    DNET - RealAudio 3.0, really it's AC3 in swapped-byteorder
+    SIPR - SiproLab's audio codec, ACELP decoder working with MPlayer,
+	   needs fine-tuning too :)
+    ATRC - RealAudio 8 (ATRAC3) - www.minidisc.org/atrac3_article.pdf,
+           ACM decoder uploaded, needs some fine-tuning to work
+	   -> RealAudio 8
+    COOK/COKR - Real Cooker -> RealAudio G2
+
+Video codecs: (supported by RealPlayer8 for Linux)
+    RV10 - H.263 based, working with libavcodec's decoder
+    RV20-RV40 - using RealPlayer's codec plugins
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "mp_msg.h"
+#include "help_mp.h"
+
+#include "stream.h"
+#include "demuxer.h"
+#include "stheader.h"
+#include "bswap.h"
+
+//#define mp_dbg(mod,lev, args... ) mp_msg_c((mod<<8)|lev, ## args )
+
+#define MKTAG(a, b, c, d) (a | (b << 8) | (c << 16) | (d << 24))
+
+#define MAX_STREAMS 32
+
+typedef struct {
+    int		timestamp;
+    int		offset;
+//    int		packetno;
+//    int		len; /* only filled by our index generator */
+//    int		flags; /* only filled by our index generator */
+} real_index_table_t;
+
+typedef struct {
+    /* for seeking */
+    int		index_chunk_offset;
+    real_index_table_t *index_table[MAX_STREAMS];
+	
+//    int		*index_table[MAX_STREAMS];
+    int		index_table_size[MAX_STREAMS];
+    int		index_malloc_size[MAX_STREAMS];
+    int		data_chunk_offset;
+    int		num_of_packets;
+    int		current_packet;
+	
+// need for seek
+    int		audio_need_keyframe;
+    int		video_after_seek;
+
+    int		current_apacket;
+    int		current_vpacket;
+    
+    // timestamp correction:
+    int		kf_base;// timestamp of the prev. video keyframe
+    int		kf_pts;	// timestamp of next video keyframe
+    int		a_pts;	// previous audio timestamp
+    float	v_pts;  // previous video timestamp
+    unsigned long	duration;
+    
+    /* stream id table */
+//    int		last_a_stream;
+//    int 	a_streams[MAX_STREAMS];
+//    int		last_v_stream;
+//    int 	v_streams[MAX_STREAMS];
+} real_priv_t;
+
+/* originally from FFmpeg */
+static void get_str(int isbyte, demuxer_t *demuxer, char *buf, int buf_size)
+{
+    int len;
+    
+    if (isbyte)
+	len = stream_read_char(demuxer->stream);
+    else
+	len = stream_read_word(demuxer->stream);
+
+    stream_read(demuxer->stream, buf, (len > buf_size) ? buf_size : len);
+    if (len > buf_size)
+	stream_skip(demuxer->stream, len-buf_size);
+
+    mp_msg(MSGT_DEMUX, MSGL_V, "read_str: %d bytes read\n", len);
+}
+
+static void skip_str(int isbyte, demuxer_t *demuxer)
+{
+    int len;
+
+    if (isbyte)
+	len = stream_read_char(demuxer->stream);
+    else
+	len = stream_read_word(demuxer->stream);
+
+    stream_skip(demuxer->stream, len);    
+
+    mp_msg(MSGT_DEMUX, MSGL_V, "skip_str: %d bytes skipped\n", len);
+}
+
+static void dump_index(demuxer_t *demuxer, int stream_id)
+{
+    real_priv_t *priv = demuxer->priv;
+    real_index_table_t *index;
+    int i, entries;
+
+    if (verbose<=0)
+	return;
+    
+    if (stream_id > MAX_STREAMS)
+	return;
+
+    index = priv->index_table[stream_id];
+    entries = priv->index_table_size[stream_id];
+    
+    mp_msg(MSGT_DEMUX, MSGL_V, "Index table for stream %d\n", stream_id);
+    for (i = 0; i < entries; i++)
+    {
+#if 1
+	mp_msg(MSGT_DEMUX, MSGL_V,"i: %d, pos: %d, timestamp: %d\n", i, index[i].offset, index[i].timestamp);
+#else
+	mp_msg(MSGT_DEMUX, MSGL_V,"packetno: %x pos: %x len: %x timestamp: %x flags: %x\n",
+	    index[i].packetno, index[i].offset, index[i].len, index[i].timestamp,
+	    index[i].flags);
+#endif
+    }
+}
+
+static int parse_index_chunk(demuxer_t *demuxer)
+{
+    real_priv_t *priv = demuxer->priv;
+    int origpos = stream_tell(demuxer->stream);
+    int next_header_pos = priv->index_chunk_offset;
+    int i, entries, stream_id;
+
+read_index:
+    stream_seek(demuxer->stream, next_header_pos);
+
+    i = stream_read_dword_le(demuxer->stream);
+    if ((i == -256) || (i != MKTAG('I', 'N', 'D', 'X')))
+    {
+	mp_msg(MSGT_DEMUX, MSGL_WARN,"Something went wrong, no index chunk found on given address (%d)\n",
+	    next_header_pos);
+	index_mode = -1;
+        if (i == -256)
+	    stream_reset(demuxer->stream);
+    	stream_seek(demuxer->stream, origpos);
+	return 0;
+	//goto end;
+    }
+
+    mp_msg(MSGT_DEMUX, MSGL_V,"Reading index table from index chunk (%d)\n",
+	next_header_pos);
+
+    i = stream_read_dword(demuxer->stream);
+    mp_msg(MSGT_DEMUX, MSGL_V,"size: %d bytes\n", i);
+
+    i = stream_read_word(demuxer->stream);
+    if (i != 0)
+	mp_msg(MSGT_DEMUX, MSGL_WARN,"Hmm, index table with unknown version (%d), please report it to MPlayer developers!\n", i);
+
+    entries = stream_read_dword(demuxer->stream);
+    mp_msg(MSGT_DEMUX, MSGL_V,"entries: %d\n", entries);
+    
+    stream_id = stream_read_word(demuxer->stream);
+    mp_msg(MSGT_DEMUX, MSGL_V,"stream_id: %d\n", stream_id);
+    
+    next_header_pos = stream_read_dword(demuxer->stream);
+    mp_msg(MSGT_DEMUX, MSGL_V,"next_header_pos: %d\n", next_header_pos);
+    if (entries <= 0)
+    {
+	if (next_header_pos)
+	    goto read_index;
+	i = entries;
+	goto end;
+    }
+
+    priv->index_table_size[stream_id] = entries;
+    priv->index_table[stream_id] = malloc(priv->index_table_size[stream_id] * sizeof(real_index_table_t));
+    
+    for (i = 0; i < entries; i++)
+    {
+	stream_skip(demuxer->stream, 2); /* version */
+	priv->index_table[stream_id][i].timestamp = stream_read_dword(demuxer->stream);
+	priv->index_table[stream_id][i].offset = stream_read_dword(demuxer->stream);
+	stream_skip(demuxer->stream, 4); /* packetno */
+//	priv->index_table[stream_id][i].packetno = stream_read_dword(demuxer->stream);
+//	printf("Index table: Stream#%d: entry: %d: pos: %d\n",
+//	    stream_id, i, priv->index_table[stream_id][i].offset);
+    }
+    
+    dump_index(demuxer, stream_id);
+
+    if (next_header_pos > 0)
+	goto read_index;
+
+end:
+    if (i == -256)
+	stream_reset(demuxer->stream);
+    stream_seek(demuxer->stream, origpos);
+    if (i == -256)
+	return 0;
+    else
+	return 1;
+}
+
+#if 1
+
+static void add_index_item(demuxer_t *demuxer, int stream_id, int timestamp, int offset)
+{
+  if ((unsigned)stream_id < MAX_STREAMS)
+  {
+    real_priv_t *priv = demuxer->priv;
+    real_index_table_t *index;
+    if (priv->index_table_size[stream_id] >= priv->index_malloc_size[stream_id])
+    {
+      if (priv->index_malloc_size[stream_id] == 0)
+	priv->index_malloc_size[stream_id] = 2048;
+      else
+	priv->index_malloc_size[stream_id] += priv->index_malloc_size[stream_id] / 2;
+      priv->index_table[stream_id] = realloc(priv->index_table[stream_id], priv->index_malloc_size[stream_id]*sizeof(priv->index_table[0][0]));
+    }
+    if (priv->index_table_size[stream_id] > 0)
+    {
+      index = &priv->index_table[stream_id][priv->index_table_size[stream_id] - 1];
+      if (index->timestamp >= timestamp || index->offset >= offset)
+	return;
+    }
+    index = &priv->index_table[stream_id][priv->index_table_size[stream_id]++];
+    index->timestamp = timestamp;
+    index->offset = offset;
+  }
+}
+
+static void add_index_segment(demuxer_t *demuxer, int seek_stream_id, int seek_timestamp)
+{
+  int tag, len, stream_id, timestamp, flags;
+  if (seek_timestamp != -1 && (unsigned)seek_stream_id >= MAX_STREAMS)
+    return;
+  while (1)
+  {
+    demuxer->filepos = stream_tell(demuxer->stream);
+    
+    tag = stream_read_dword(demuxer->stream);
+    if (tag == MKTAG('A', 'T', 'A', 'D'))
+    {
+      stream_skip(demuxer->stream, 14);
+      continue; /* skip to next loop */
+    }
+    len = tag & 0xffff;
+    if (tag == -256 || len < 12)
+      break;
+    
+    stream_id = stream_read_word(demuxer->stream);
+    timestamp = stream_read_dword(demuxer->stream);
+    
+    stream_skip(demuxer->stream, 1); /* reserved */
+    flags = stream_read_char(demuxer->stream);
+    
+    if (flags == -256)
+      break;
+    
+    if (flags & 2)
+    {
+      add_index_item(demuxer, stream_id, timestamp, demuxer->filepos);
+      if (stream_id == seek_stream_id && timestamp >= seek_timestamp)
+      {
+	stream_seek(demuxer->stream, demuxer->filepos);
+	return;
+      }
+    }
+    // printf("Index: stream=%d packet=%d timestamp=%d len=%d flags=0x%x datapos=0x%x\n", stream_id, entries, timestamp, len, flags, index->offset);
+    /* skip data */
+    stream_skip(demuxer->stream, len-12);
+  }
+}
+
+static int generate_index(demuxer_t *demuxer)
+{
+  real_priv_t *priv = demuxer->priv;
+  int origpos = stream_tell(demuxer->stream);
+  int data_pos = priv->data_chunk_offset-10;
+  int i;
+  int tag;
+  
+  stream_seek(demuxer->stream, data_pos);
+  tag = stream_read_dword(demuxer->stream);
+  if (tag != MKTAG('A', 'T', 'A', 'D'))
+  {
+    mp_msg(MSGT_DEMUX, MSGL_WARN,"Something went wrong, no data chunk found on given address (%d)\n", data_pos);
+  }
+  else
+  {
+    stream_skip(demuxer->stream, 14);
+    add_index_segment(demuxer, -1, -1);
+  }
+  for (i = 0; i < MAX_STREAMS; i++)
+  {
+    if (priv->index_table_size[i] > 0)
+    {
+      dump_index(demuxer, i);
+    }
+  }
+  stream_reset(demuxer->stream);
+  stream_seek(demuxer->stream, origpos);
+  return 0;
+}
+
+#else
+
+static int generate_index(demuxer_t *demuxer)
+{
+    real_priv_t *priv = demuxer->priv;
+    int origpos = stream_tell(demuxer->stream);
+    int data_pos = priv->data_chunk_offset-10;
+    int num_of_packets = 0;
+    int i, entries = 0;
+    int len, stream_id = 0, timestamp, flags;
+    int tab_pos = 0;
+
+read_index:
+    stream_seek(demuxer->stream, data_pos);
+
+    i = stream_read_dword_le(demuxer->stream);
+    if ((i == -256) || (i != MKTAG('D', 'A', 'T', 'A')))
+    {
+	mp_msg(MSGT_DEMUX, MSGL_WARN,"Something went wrong, no data chunk found on given address (%d)\n",
+	    data_pos);
+	goto end;
+    }
+    stream_skip(demuxer->stream, 4); /* chunk size */
+    stream_skip(demuxer->stream, 2); /* version */
+    
+    num_of_packets = stream_read_dword(demuxer->stream);
+    mp_msg(MSGT_DEMUX, MSGL_V,"Generating index table from raw data (pos: 0x%x) for %d packets\n",
+	data_pos, num_of_packets);
+
+    data_pos = stream_read_dword_le(demuxer->stream)-10; /* next data chunk */
+
+    for (i = 0; i < MAX_STREAMS; i++)
+    {
+    priv->index_table_size[i] = num_of_packets;
+    priv->index_table[i] = malloc(priv->index_table_size[i] * sizeof(real_index_table_t));
+//    priv->index_table[stream_id] = realloc(priv->index_table[stream_id],
+//	priv->index_table_size[stream_id] * sizeof(real_index_table_t));
+    }
+
+    tab_pos = 0;
+    
+//    memset(priv->index_table_size, 0, sizeof(int)*MAX_STREAMS);
+//    memset(priv->index_table, 0, sizeof(real_index_table_t)*MAX_STREAMS);
+    
+    while (tab_pos < num_of_packets)
+    {
+    i = stream_read_char(demuxer->stream);
+    if (i == -256)
+	goto end;
+    stream_skip(demuxer->stream, 1);
+//    stream_skip(demuxer->stream, 2); /* version */
+
+    len = stream_read_word(demuxer->stream);
+    stream_id = stream_read_word(demuxer->stream);
+    timestamp = stream_read_dword(demuxer->stream);
+    
+    stream_skip(demuxer->stream, 1); /* reserved */
+    flags = stream_read_char(demuxer->stream);
+
+    i = tab_pos;
+
+//    priv->index_table_size[stream_id] = i;
+//    if (priv->index_table[stream_id] == NULL)
+//	priv->index_table[stream_id] = malloc(priv->index_table_size[stream_id] * sizeof(real_index_table_t));
+//    else
+//	priv->index_table[stream_id] = realloc(priv->index_table[stream_id],
+//	    priv->index_table_size[stream_id] * sizeof(real_index_table_t));
+    
+    priv->index_table[stream_id][i].timestamp = timestamp;
+    priv->index_table[stream_id][i].offset = stream_tell(demuxer->stream)-12;
+    priv->index_table[stream_id][i].len = len;
+    priv->index_table[stream_id][i].packetno = entries;
+    priv->index_table[stream_id][i].flags = flags;
+
+    tab_pos++;
+
+    /* skip data */
+    stream_skip(demuxer->stream, len-12);
+    }
+    dump_index(demuxer, stream_id);
+    if (data_pos)
+	goto read_index;
+
+end:
+    if (i == -256)
+	stream_reset(demuxer->stream);
+    stream_seek(demuxer->stream, origpos);
+    if (i == -256)
+	return 0;
+    else
+	return 1;
+}
+#endif
+
+
+int real_check_file(demuxer_t* demuxer)
+{
+    real_priv_t *priv;
+    int c;
+
+    mp_msg(MSGT_DEMUX,MSGL_V,"Checking for REAL\n");
+    
+    c = stream_read_dword_le(demuxer->stream);
+    if (c == -256)
+	return 0; /* EOF */
+    if (c != MKTAG('.', 'R', 'M', 'F'))
+	return 0; /* bad magic */
+
+    priv = malloc(sizeof(real_priv_t));
+    memset(priv, 0, sizeof(real_priv_t));
+    demuxer->priv = priv;
+
+    return 1;
+}
+
+void hexdump(char *, unsigned long);
+
+#define SKIP_BITS(n) buffer<<=n
+#define SHOW_BITS(n) ((buffer)>>(32-(n)))
+
+static float real_fix_timestamp(real_priv_t* priv, unsigned char* s, int timestamp, float frametime, unsigned int format){
+  float v_pts;
+  uint32_t buffer= (s[0]<<24) + (s[1]<<16) + (s[2]<<8) + s[3];
+  int kf=timestamp;
+  int pict_type;
+  int orig_kf;
+
+#if 1
+  if(format==mmioFOURCC('R','V','3','0') || format==mmioFOURCC('R','V','4','0')){
+    if(format==mmioFOURCC('R','V','3','0')){
+      SKIP_BITS(3);
+      pict_type= SHOW_BITS(2);
+      SKIP_BITS(2 + 7);
+    }else{
+      SKIP_BITS(1);
+      pict_type= SHOW_BITS(2);
+      SKIP_BITS(2 + 7 + 3);
+    }
+    orig_kf=
+    kf= SHOW_BITS(13);  //    kf= 2*SHOW_BITS(12);
+//    if(pict_type==0)
+    if(pict_type<=1){
+      // I frame, sync timestamps:
+      priv->kf_base=timestamp-kf;
+      mp_msg(MSGT_DEMUX, MSGL_V,"\nTS: base=%08X\n",priv->kf_base);
+      kf=timestamp;
+    } else {
+      // P/B frame, merge timestamps:
+      int tmp=timestamp-priv->kf_base;
+      kf|=tmp&(~0x1fff);	// combine with packet timestamp
+      if(kf<tmp-4096) kf+=8192; else // workaround wrap-around problems
+      if(kf>tmp+4096) kf-=8192;
+      kf+=priv->kf_base;
+    }
+    if(pict_type != 3){ // P || I  frame -> swap timestamps
+	int tmp=kf;
+	kf=priv->kf_pts;
+	priv->kf_pts=tmp;
+//	if(kf<=tmp) kf=0;
+    }
+    mp_msg(MSGT_DEMUX, MSGL_V,"\nTS: %08X -> %08X (%04X) %d %02X %02X %02X %02X %5d\n",timestamp,kf,orig_kf,pict_type,s[0],s[1],s[2],s[3],kf-(int)(1000.0*priv->v_pts));
+  }
+#endif
+    v_pts=kf*0.001f;
+//    if(v_pts<priv->v_pts || !kf) v_pts=priv->v_pts+frametime;
+    priv->v_pts=v_pts;
+    return v_pts;
+}
+
+typedef struct dp_hdr_s {
+    uint32_t chunks;	// number of chunks
+    uint32_t timestamp; // timestamp from packet header
+    uint32_t len;	// length of actual data
+    uint32_t chunktab;	// offset to chunk offset array
+} dp_hdr_t;
+
+// return value:
+//     0 = EOF or no stream found
+//     1 = successfully read a packet
+int demux_real_fill_buffer(demuxer_t *demuxer)
+{
+    real_priv_t *priv = demuxer->priv;
+    demux_stream_t *ds = NULL;
+    int len;
+    int timestamp;
+    int stream_id;
+#ifdef CRACK_MATRIX
+    int i;
+#endif
+    int flags;
+    int version;
+    int reserved;
+    demux_packet_t *dp;
+
+  while(1){
+
+    demuxer->filepos = stream_tell(demuxer->stream);
+    version = stream_read_word(demuxer->stream); /* version */
+    len = stream_read_word(demuxer->stream);
+    if ((version==0x4441) && (len==0x5441)) { // new data chunk
+	mp_msg(MSGT_DEMUX,MSGL_INFO,"demux_real: New data chunk is coming!!!\n");
+	stream_skip(demuxer->stream,14); 
+	demuxer->filepos = stream_tell(demuxer->stream);
+        version = stream_read_word(demuxer->stream); /* version */
+	len = stream_read_word(demuxer->stream);	
+    } else if ((version == 0x494e) && (len == 0x4458)) {
+        mp_msg(MSGT_DEMUX,MSGL_V,"demux_real: Found INDX chunk. EOF.\n");
+        return 0;
+    }
+
+    
+    if (len == -256){ /* EOF */
+//	printf("len==-256!\n");
+	return 0;
+    }
+    if (len < 12){
+	mp_msg(MSGT_DEMUX, MSGL_V,"%08X: packet v%d len=%d  \n",(int)demuxer->filepos,(int)version,(int)len);
+	mp_msg(MSGT_DEMUX, MSGL_WARN,"bad packet len (%d)\n", len);
+	stream_skip(demuxer->stream, len);
+	continue; //goto loop;
+    }
+
+    stream_id = stream_read_word(demuxer->stream);
+    timestamp = stream_read_dword(demuxer->stream);
+    reserved = stream_read_char(demuxer->stream);
+    flags = stream_read_char(demuxer->stream);
+    /* flags:		*/
+    /*  0x1 - reliable  */
+    /* 	0x2 - keyframe	*/
+
+    if (flags & 2)
+      add_index_item(demuxer, stream_id, timestamp, demuxer->filepos);
+
+//    printf("%08X: packet v%d len=%4d  id=%d  pts=%6d  rvd=%d  flags=%d  \n",
+//	(int)demuxer->filepos,(int)version,(int)len, stream_id,
+//	(int) timestamp, reserved, flags);
+
+    mp_dbg(MSGT_DEMUX,MSGL_DBG2, "len:%d\n", len);
+    mp_dbg(MSGT_DEMUX,MSGL_V,  "\npacket#%d: pos: 0x%0x, len: %d, id: %d, pts: %d, flags: %x rvd:%d\n",
+	priv->current_packet, (int)demuxer->filepos, len, stream_id, timestamp, flags, reserved);
+
+    priv->current_packet++;
+    len -= 12;    
+
+//    printf("s_id=%d  aid=%d  vid=%d  \n",stream_id,demuxer->audio->id,demuxer->video->id);
+
+    /* check stream_id: */
+
+    if(demuxer->audio->id==stream_id){
+    	if (priv->audio_need_keyframe == 1&& flags != 0x2)
+		goto discard;
+got_audio:
+	ds=demuxer->audio;
+	mp_dbg(MSGT_DEMUX,MSGL_DBG2, "packet is audio (id: %d)\n", stream_id);
+
+	// parse audio chunk:
+	{
+#ifdef CRACK_MATRIX
+	    int spos=stream_tell(demuxer->stream);
+	    static int cnt=0;
+	    static int cnt2=CRACK_MATRIX;
+#endif
+	    if (((sh_audio_t *)ds->sh)->format == mmioFOURCC('M', 'P', '4', 'A')) {
+		uint16_t *sub_packet_lengths, sub_packets, i;
+		/* AAC in Real: several AAC frames in one Real packet. */
+		/* Second byte, upper four bits: number of AAC frames */
+		/* next n * 2 bytes: length of the AAC frames in bytes, BE */
+		sub_packets = (stream_read_word(demuxer->stream) & 0xf0) >> 4;
+		sub_packet_lengths = calloc(sub_packets, sizeof(uint16_t));
+		for (i = 0; i < sub_packets; i++)
+		    sub_packet_lengths[i] = stream_read_word(demuxer->stream);
+		for (i = 0; i < sub_packets; i++) {
+		    demux_packet_t *dp = new_demux_packet(sub_packet_lengths[i]);
+		    stream_read(demuxer->stream, dp->buffer, sub_packet_lengths[i]);
+		    dp->pts = (priv->a_pts == timestamp) ? 0 : (timestamp / 1000.0f);
+		    priv->a_pts = timestamp;
+		    dp->pos = demuxer->filepos;
+		    ds_add_packet(ds, dp);
+		}
+		free(sub_packet_lengths);
+		return 1;
+	    }
+            dp = new_demux_packet(len);
+	    stream_read(demuxer->stream, dp->buffer, len);
+#ifdef CRACK_MATRIX
+	    mp_msg(MSGT_DEMUX, MSGL_V,"*** audio block len=%d\n",len);
+	    { // HACK - used for reverse engineering the descrambling matrix
+		FILE* f=fopen("test.rm","r+");
+		fseek(f,spos,SEEK_SET);
+		++cnt;
+//		    for(i=0;i<len;i++) dp->buffer[i]=i/0x12;
+//		    for(i=0;i<len;i++) dp->buffer[i]=i;
+//		    for(i=0;i<len;i++) dp->buffer[i]=cnt;
+//		    for(i=0;i<len;i++) dp->buffer[i]=cnt<<4;
+		    for(i=0;i<len;i++) dp->buffer[i]=(i==cnt2) ? (cnt+16*(8+cnt)) : 0;
+		if(cnt==6){ cnt=0; ++cnt2; }
+		fwrite(dp->buffer, len, 1, f);
+		fclose(f);
+		if(cnt2>0x150) *((int*)NULL)=1; // sig11 :)
+	    }
+#endif
+#if 0
+	    if( ((sh_audio_t *)ds->sh)->format == 0x2000) {
+		// if DNET, swap bytes, as DNET is byte-swapped AC3:
+		char *ptr = dp->buffer;
+		int i;
+		for (i = 0; i < len; i += 2)
+		{
+		    const char tmp = ptr[0];
+		    ptr[0] = ptr[1];
+		    ptr[1] = tmp;
+		    ptr += 2;
+		}
+	    }
+#endif
+	    if (priv->audio_need_keyframe == 1) {
+	    	dp->pts = 0;
+		priv->audio_need_keyframe = 0;
+	    }else 
+	        dp->pts = (priv->a_pts==timestamp) ? 0 : (timestamp/1000.0f);
+	    priv->a_pts=timestamp;
+	    dp->pos = demuxer->filepos;
+	    dp->flags = (flags & 0x2) ? 0x10 : 0;
+	    ds_add_packet(ds, dp);
+	}
+// we will not use audio index if we use -idx and have a video
+	if(!demuxer->video->sh && index_mode == 2 && (unsigned)demuxer->audio->id < MAX_STREAMS)
+		while (priv->current_apacket + 1 < priv->index_table_size[demuxer->audio->id] &&
+		       timestamp > priv->index_table[demuxer->audio->id][priv->current_apacket].timestamp)
+			priv->current_apacket += 1;
+	
+	return 1;
+    }
+    
+    if(demuxer->video->id==stream_id){
+got_video:
+	ds=demuxer->video;
+	mp_dbg(MSGT_DEMUX,MSGL_DBG2, "packet is video (id: %d)\n", stream_id);
+	
+	// parse video chunk:
+	{
+	    // we need a more complicated, 2nd level demuxing, as the video
+	    // frames are stored fragmented in the video chunks :(
+	    sh_video_t *sh_video = ds->sh;
+	    demux_packet_t *dp;
+	    int vpkg_header, vpkg_length, vpkg_offset;
+	    int vpkg_seqnum=-1;
+	    int vpkg_subseq=0;
+
+	    while(len>2){
+		dp_hdr_t* dp_hdr;
+		unsigned char* dp_data;
+		uint32_t* extra;
+
+//		printf("xxx len=%d  \n",len);
+
+		// read packet header
+		// bit 7: 1=last block in block chain
+		// bit 6: 1=short header (only one block?)
+		vpkg_header=stream_read_char(demuxer->stream); --len;
+		mp_dbg(MSGT_DEMUX,MSGL_DBG2, "hdr: %02X (len=%d) ",vpkg_header,len);
+
+		if (0x40==(vpkg_header&0xc0)) {
+		    // seems to be a very short header
+	    	    // 2 bytes, purpose of the second byte yet unknown
+	    	    int bummer;
+		    bummer=stream_read_char(demuxer->stream); --len;
+ 		    mp_dbg(MSGT_DEMUX,MSGL_DBG2,  "%02X",bummer);
+ 	    	    vpkg_offset=0;
+ 		    vpkg_length=len;
+		} else {
+		
+		    if (0==(vpkg_header&0x40)) {
+			// sub-seqnum (bits 0-6: number of fragment. bit 7: ???)
+		        vpkg_subseq=stream_read_char(demuxer->stream);
+	                --len;
+		        mp_dbg(MSGT_DEMUX,MSGL_DBG2,  "subseq: %02X ",vpkg_subseq);
+			vpkg_subseq&=0x7f;
+	            }
+
+	  	    // size of the complete packet
+		    // bit 14 is always one (same applies to the offset)
+		    vpkg_length=stream_read_word(demuxer->stream);
+		    len-=2;
+		    mp_dbg(MSGT_DEMUX,MSGL_DBG2, "l: %02X %02X ",vpkg_length>>8,vpkg_length&0xff);
+		    if (!(vpkg_length&0xC000)) {
+			vpkg_length<<=16;
+		        vpkg_length|=stream_read_word(demuxer->stream);
+		        mp_dbg(MSGT_DEMUX,MSGL_DBG2, "l+: %02X %02X ",(vpkg_length>>8)&0xff,vpkg_length&0xff);
+	    	        len-=2;
+		    } else
+		    vpkg_length&=0x3fff;
+
+		    // offset of the following data inside the complete packet
+		    // Note: if (hdr&0xC0)==0x80 then offset is relative to the
+		    // _end_ of the packet, so it's equal to fragment size!!!
+		    vpkg_offset=stream_read_word(demuxer->stream);
+	            len-=2;
+		    mp_dbg(MSGT_DEMUX,MSGL_DBG2, "o: %02X %02X ",vpkg_offset>>8,vpkg_offset&0xff);
+		    if (!(vpkg_offset&0xC000)) {
+			vpkg_offset<<=16;
+		        vpkg_offset|=stream_read_word(demuxer->stream);
+		        mp_dbg(MSGT_DEMUX,MSGL_DBG2, "o+: %02X %02X ",(vpkg_offset>>8)&0xff,vpkg_offset&0xff);
+	    	        len-=2;
+		    } else
+		    vpkg_offset&=0x3fff;
+
+		    vpkg_seqnum=stream_read_char(demuxer->stream); --len;
+		    mp_dbg(MSGT_DEMUX,MSGL_DBG2, "seq: %02X ",vpkg_seqnum);
+	        }
+ 		mp_dbg(MSGT_DEMUX,MSGL_DBG2, "\n");
+                mp_dbg(MSGT_DEMUX,MSGL_DBG2, "blklen=%d\n", len);
+		mp_msg(MSGT_DEMUX,MSGL_DBG2, "block: hdr=0x%0x, len=%d, offset=%d, seqnum=%d\n",
+		    vpkg_header, vpkg_length, vpkg_offset, vpkg_seqnum);
+
+		if(ds->asf_packet){
+		    dp=ds->asf_packet;
+		    dp_hdr=(dp_hdr_t*)dp->buffer;
+		    dp_data=dp->buffer+sizeof(dp_hdr_t);
+		    extra=(uint32_t*)(dp->buffer+dp_hdr->chunktab);
+		    mp_dbg(MSGT_DEMUX,MSGL_DBG2, "we have an incomplete packet (oldseq=%d new=%d)\n",ds->asf_seq,vpkg_seqnum);
+		    // we have an incomplete packet:
+		    if(ds->asf_seq!=vpkg_seqnum){
+			// this fragment is for new packet, close the old one
+			mp_msg(MSGT_DEMUX,MSGL_DBG2, "closing probably incomplete packet, len: %d  \n",dp->len);
+			if(priv->video_after_seek){
+			    dp->pts=timestamp;
+				priv->kf_base = 0;
+				priv->kf_pts = dp_hdr->timestamp;
+				priv->video_after_seek = 0;
+			} else 
+			dp->pts=(dp_hdr->len<3)?0:
+			    real_fix_timestamp(priv,dp_data,dp_hdr->timestamp,sh_video->frametime,sh_video->format);
+			ds_add_packet(ds,dp);
+			ds->asf_packet=NULL;
+		    } else {
+			// append data to it!
+			++dp_hdr->chunks;
+			mp_msg(MSGT_DEMUX,MSGL_DBG2,"[chunks=%d  subseq=%d]\n",dp_hdr->chunks,vpkg_subseq);
+			if(dp_hdr->chunktab+8*(1+dp_hdr->chunks)>dp->len){
+			    // increase buffer size, this should not happen!
+			    mp_msg(MSGT_DEMUX,MSGL_WARN, "chunktab buffer too small!!!!!\n");
+			    dp->len=dp_hdr->chunktab+8*(4+dp_hdr->chunks);
+			    dp->buffer=realloc(dp->buffer,dp->len);
+			    // re-calc pointers:
+			    dp_hdr=(dp_hdr_t*)dp->buffer;
+			    dp_data=dp->buffer+sizeof(dp_hdr_t);
+			    extra=(uint32_t*)(dp->buffer+dp_hdr->chunktab);
+			}
+			extra[2*dp_hdr->chunks+0]=1;
+			extra[2*dp_hdr->chunks+1]=dp_hdr->len;
+			if(0x80==(vpkg_header&0xc0)){
+			    // last fragment!
+			    if(dp_hdr->len!=vpkg_length-vpkg_offset)
+				mp_msg(MSGT_DEMUX,MSGL_V,"warning! assembled.len=%d  frag.len=%d  total.len=%d  \n",dp->len,vpkg_offset,vpkg_length-vpkg_offset);
+            		    stream_read(demuxer->stream, dp_data+dp_hdr->len, vpkg_offset);
+			    if((dp_data[dp_hdr->len]&0x20) && (sh_video->format==0x30335652)) --dp_hdr->chunks; else
+			    dp_hdr->len+=vpkg_offset;
+			    len-=vpkg_offset;
+ 			    mp_dbg(MSGT_DEMUX,MSGL_DBG2, "fragment (%d bytes) appended, %d bytes left\n",vpkg_offset,len);
+			    // we know that this is the last fragment -> we can close the packet!
+			    if(priv->video_after_seek){
+			        dp->pts=timestamp;
+				    priv->kf_base = 0;
+				    priv->kf_pts = dp_hdr->timestamp;
+				    priv->video_after_seek = 0;
+			    } else 
+			    dp->pts=(dp_hdr->len<3)?0:
+				real_fix_timestamp(priv,dp_data,dp_hdr->timestamp,sh_video->frametime,sh_video->format);
+			    ds_add_packet(ds,dp);
+			    ds->asf_packet=NULL;
+			    // continue parsing
+			    continue;
+			}
+			// non-last fragment:
+			if(dp_hdr->len!=vpkg_offset)
+			    mp_msg(MSGT_DEMUX,MSGL_V,"warning! assembled.len=%d  offset=%d  frag.len=%d  total.len=%d  \n",dp->len,vpkg_offset,len,vpkg_length);
+            		stream_read(demuxer->stream, dp_data+dp_hdr->len, len);
+			if((dp_data[dp_hdr->len]&0x20) && (sh_video->format==0x30335652)) --dp_hdr->chunks; else
+			dp_hdr->len+=len;
+			len=0;
+			break; // no more fragments in this chunk!
+		    }
+		}
+		// create new packet!
+		dp = new_demux_packet(sizeof(dp_hdr_t)+vpkg_length+8*(1+2*(vpkg_header&0x3F)));
+	    	// the timestamp seems to be in milliseconds
+		dp->pts = 0; // timestamp/1000.0f; //timestamp=0;
+                dp->pos = demuxer->filepos;
+                dp->flags = (flags & 0x2) ? 0x10 : 0;
+		ds->asf_seq = vpkg_seqnum;
+		dp_hdr=(dp_hdr_t*)dp->buffer;
+		dp_hdr->chunks=0;
+		dp_hdr->timestamp=timestamp;
+		dp_hdr->chunktab=sizeof(dp_hdr_t)+vpkg_length;
+		dp_data=dp->buffer+sizeof(dp_hdr_t);
+		extra=(uint32_t*)(dp->buffer+dp_hdr->chunktab);
+		extra[0]=1; extra[1]=0; // offset of the first chunk
+		if(0x00==(vpkg_header&0xc0)){
+		    // first fragment:
+		    dp_hdr->len=len;
+		    stream_read(demuxer->stream, dp_data, len);
+		    ds->asf_packet=dp;
+		    len=0;
+		    break;
+		}
+		// whole packet (not fragmented):
+		if (vpkg_length > len) {
+		    mp_msg(MSGT_DEMUX, MSGL_WARN,"\n******** WARNING: vpkg_length=%i > len=%i ********\n", vpkg_length, len);
+		    /*
+		     * To keep the video stream rolling, we need to break 
+		     * here. We shouldn't touch len to make sure rest of the
+		     * broken packet is skipped.
+		     */
+		    break;
+		}
+		dp_hdr->len=vpkg_length; len-=vpkg_length;
+		stream_read(demuxer->stream, dp_data, vpkg_length);
+		if(priv->video_after_seek){
+		    dp->pts=timestamp;
+			priv->kf_base = 0;
+			priv->kf_pts = dp_hdr->timestamp;
+			priv->video_after_seek = 0;
+		} else 
+		dp->pts=(dp_hdr->len<3)?0:
+		    real_fix_timestamp(priv,dp_data,dp_hdr->timestamp,sh_video->frametime,sh_video->format);
+		ds_add_packet(ds,dp);
+
+	    } // while(len>0)
+	    
+	    if(len){
+		mp_msg(MSGT_DEMUX, MSGL_WARN,"\n******** !!!!!!!! BUG!! len=%d !!!!!!!!!!! ********\n",len);
+		if(len>0) stream_skip(demuxer->stream, len);
+	    }
+	}
+	if ((unsigned)demuxer->video->id < MAX_STREAMS)
+		while (priv->current_vpacket + 1 < priv->index_table_size[demuxer->video->id] && 
+		       timestamp > priv->index_table[demuxer->video->id][priv->current_vpacket + 1].timestamp)
+			priv->current_vpacket += 1;
+
+	return 1;
+    }
+
+if(stream_id<256){
+
+    if(demuxer->audio->id==-1 && demuxer->a_streams[stream_id]){
+	sh_audio_t *sh = demuxer->a_streams[stream_id];
+	demuxer->audio->id=stream_id;
+	sh->ds=demuxer->audio;
+	demuxer->audio->sh=sh;
+        mp_msg(MSGT_DEMUX,MSGL_V,"Auto-selected RM audio ID = %d\n",stream_id);
+	goto got_audio;
+    }
+
+    if(demuxer->video->id==-1 && demuxer->v_streams[stream_id]){
+	sh_video_t *sh = demuxer->v_streams[stream_id];
+	demuxer->video->id=stream_id;
+	sh->ds=demuxer->video;
+	demuxer->video->sh=sh;
+        mp_msg(MSGT_DEMUX,MSGL_V,"Auto-selected RM video ID = %d\n",stream_id);
+	goto got_video;
+    }
+
+}
+
+    mp_msg(MSGT_DEMUX,MSGL_DBG2, "unknown stream id (%d)\n", stream_id);
+discard:
+    stream_skip(demuxer->stream, len);
+  }//    goto loop;
+}
+
+extern void print_wave_header(WAVEFORMATEX *h);
+
+void demux_open_real(demuxer_t* demuxer)
+{
+    real_priv_t* priv = demuxer->priv;
+    int num_of_headers;
+    int a_streams=0;
+    int v_streams=0;
+    int i;
+    int header_size;
+
+    header_size = stream_read_dword(demuxer->stream); /* header size */
+    mp_msg(MSGT_DEMUX,MSGL_V, "real: Header size: %d\n", header_size);
+    i = stream_read_word(demuxer->stream); /* version */
+    mp_msg(MSGT_DEMUX,MSGL_V, "real: Header object version: %d\n", i);
+    if (header_size == 0x10)
+    	i = stream_read_word(demuxer->stream);
+    else /* we should test header_size here too. */
+    	i = stream_read_dword(demuxer->stream);
+    mp_msg(MSGT_DEMUX,MSGL_V, "real: File version: %d\n", i);
+    num_of_headers = stream_read_dword(demuxer->stream);
+//    stream_skip(demuxer->stream, 4); /* number of headers */
+
+    /* parse chunks */
+    for (i = 1; i <= num_of_headers; i++)
+//    for (i = 1; ; i++)
+    {
+	int chunk_id, chunk_pos, chunk_size;
+	
+	chunk_pos = stream_tell(demuxer->stream);
+	chunk_id = stream_read_dword_le(demuxer->stream);
+	chunk_size = stream_read_dword(demuxer->stream);
+
+	stream_skip(demuxer->stream, 2); /* version */
+
+	mp_msg(MSGT_DEMUX,MSGL_V, "Chunk: %.4s (%x) (size: 0x%x, offset: 0x%x)\n",
+	    (char *)&chunk_id, chunk_id, chunk_size, chunk_pos);
+	
+	if (chunk_size < 10){
+	    mp_msg(MSGT_DEMUX,MSGL_ERR,"demux_real: invalid chunksize! (%d)\n",chunk_size);
+	    break; //return;
+	}
+	
+	switch(chunk_id)
+	{
+	    case MKTAG('P', 'R', 'O', 'P'):
+		/* Properties header */
+
+		stream_skip(demuxer->stream, 4); /* max bitrate */
+		stream_skip(demuxer->stream, 4); /* avg bitrate */
+		stream_skip(demuxer->stream, 4); /* max packet size */
+		stream_skip(demuxer->stream, 4); /* avg packet size */
+		stream_skip(demuxer->stream, 4); /* nb packets */
+		priv->duration = stream_read_dword(demuxer->stream)/1000; /* duration */
+		//stream_skip(demuxer->stream, 4); /* duration */
+		stream_skip(demuxer->stream, 4); /* preroll */
+		priv->index_chunk_offset = stream_read_dword(demuxer->stream);
+		mp_msg(MSGT_DEMUX,MSGL_V,"First index chunk offset: 0x%x\n", priv->index_chunk_offset);
+		priv->data_chunk_offset = stream_read_dword(demuxer->stream)+10;
+		mp_msg(MSGT_DEMUX,MSGL_V,"First data chunk offset: 0x%x\n", priv->data_chunk_offset);
+		stream_skip(demuxer->stream, 2); /* nb streams */
+#if 0
+		stream_skip(demuxer->stream, 2); /* flags */
+#else
+		{
+		    int flags = stream_read_word(demuxer->stream);
+		    
+		    if (flags)
+		    {
+		    mp_msg(MSGT_DEMUX,MSGL_V,"Flags (%x): ", flags);
+		    if (flags & 0x1)
+			mp_msg(MSGT_DEMUX,MSGL_V,"[save allowed] ");
+		    if (flags & 0x2)
+			mp_msg(MSGT_DEMUX,MSGL_V,"[perfect play (more buffers)] ");
+		    if (flags & 0x4)
+			mp_msg(MSGT_DEMUX,MSGL_V,"[live broadcast] ");
+		    mp_msg(MSGT_DEMUX,MSGL_V,"\n");
+		    }
+		}
+#endif
+		break;
+	    case MKTAG('C', 'O', 'N', 'T'):
+	    {
+		/* Content description header */
+		char *buf;
+		int len;
+
+		len = stream_read_word(demuxer->stream);
+		if (len > 0)
+		{
+		    buf = malloc(len+1);
+		    stream_read(demuxer->stream, buf, len);
+		    buf[len] = 0;
+		    demux_info_add(demuxer, "name", buf);
+		    free(buf);
+		}
+
+		len = stream_read_word(demuxer->stream);
+		if (len > 0)
+		{
+		    buf = malloc(len+1);
+		    stream_read(demuxer->stream, buf, len);
+		    buf[len] = 0;
+		    demux_info_add(demuxer, "author", buf);
+		    free(buf);
+		}
+
+		len = stream_read_word(demuxer->stream);
+		if (len > 0)
+		{
+		    buf = malloc(len+1);
+		    stream_read(demuxer->stream, buf, len);
+		    buf[len] = 0;
+		    demux_info_add(demuxer, "copyright", buf);
+		    free(buf);
+		}
+
+		len = stream_read_word(demuxer->stream);
+		if (len > 0)
+		{
+		    buf = malloc(len+1);
+	    	    stream_read(demuxer->stream, buf, len);
+		    buf[len] = 0;
+		    demux_info_add(demuxer, "comment", buf);
+		    free(buf);
+		}
+		break;
+	    }
+	    case MKTAG('M', 'D', 'P', 'R'):
+	    {
+		/* Media properties header */
+		int stream_id;
+		int bitrate;
+		int codec_data_size;
+		int codec_pos;
+		int tmp;
+
+		stream_id = stream_read_word(demuxer->stream);
+		mp_msg(MSGT_DEMUX,MSGL_V,"Found new stream (id: %d)\n", stream_id);
+		
+		stream_skip(demuxer->stream, 4); /* max bitrate */
+		bitrate = stream_read_dword(demuxer->stream); /* avg bitrate */
+		stream_skip(demuxer->stream, 4); /* max packet size */
+		stream_skip(demuxer->stream, 4); /* avg packet size */
+		stream_skip(demuxer->stream, 4); /* start time */
+		stream_skip(demuxer->stream, 4); /* preroll */
+		stream_skip(demuxer->stream, 4); /* duration */
+		
+		skip_str(1, demuxer);	/* stream description (name) */
+		skip_str(1, demuxer);	/* mimetype */
+		
+		/* Type specific header */
+		codec_data_size = stream_read_dword(demuxer->stream);
+		codec_pos = stream_tell(demuxer->stream);
+
+		tmp = stream_read_dword(demuxer->stream);
+		
+		mp_msg(MSGT_DEMUX,MSGL_DBG2,"demux_real: type_spec: len=%d  fpos=0x%X  first_dword=0x%X (%.4s)  \n",
+		    (int)codec_data_size,(int)codec_pos,tmp,&tmp);
+
+#if 1
+		// skip unknown shit - FIXME: find a better/cleaner way!
+		{   int len=codec_data_size;
+		    while(--len>=8){
+			if(tmp==MKTAG(0xfd, 'a', 'r', '.')) break; // audio
+			if(tmp==MKTAG('O', 'D', 'I', 'V')) break;  // video
+			tmp=(tmp<<8)|stream_read_char(demuxer->stream);
+		    }
+		}
+#endif
+
+#ifdef MP_DEBUG
+#define stream_skip(st,siz) { int i; for(i=0;i<siz;i++) mp_msg(MSGT_DEMUX,MSGL_V," %02X",stream_read_char(st)); mp_msg(MSGT_DEMUX,MSGL_V,"\n");}
+#endif
+
+		if (tmp == MKTAG(0xfd, 'a', 'r', '.'))
+		{
+		    /* audio header */
+		    sh_audio_t *sh = new_sh_audio(demuxer, stream_id);
+		    char buf[128]; /* for codec name */
+		    int frame_size;
+		    int sub_packet_size;
+		    int sub_packet_h;
+		    int version;
+		    int flavor;
+		    int coded_frame_size;
+		    int codecdata_length;
+		    int i;
+		    char *buft;
+		    int hdr_size;
+		    
+		    mp_msg(MSGT_DEMUX,MSGL_V,"Found audio stream!\n");
+		    version = stream_read_word(demuxer->stream);
+		    mp_msg(MSGT_DEMUX,MSGL_V,"version: %d\n", version);
+//		    stream_skip(demuxer->stream, 2); /* version (4 or 5) */
+                   if (version == 3) {
+                    stream_skip(demuxer->stream, 2);
+                    stream_skip(demuxer->stream, 10);
+                    stream_skip(demuxer->stream, 4);
+                    // Name, author, (c) are also in CONT tag
+                    if ((i = stream_read_char(demuxer->stream)) != 0) {
+                      buft = malloc(i+1);
+                      stream_read(demuxer->stream, buft, i);
+                      buft[i] = 0;
+                      demux_info_add(demuxer, "Name", buft);
+                      free(buft);
+                    }
+                    if ((i = stream_read_char(demuxer->stream)) != 0) {
+                      buft = malloc(i+1);
+                      stream_read(demuxer->stream, buft, i);
+                      buft[i] = 0;
+                      demux_info_add(demuxer, "Author", buft);
+                      free(buft);
+                    }
+                    if ((i = stream_read_char(demuxer->stream)) != 0) {
+                      buft = malloc(i+1);
+                      stream_read(demuxer->stream, buft, i);
+                      buft[i] = 0;
+                      demux_info_add(demuxer, "Copyright", buft);
+                      free(buft);
+                    }
+                    if ((i = stream_read_char(demuxer->stream)) != 0)
+                      mp_msg(MSGT_DEMUX,MSGL_WARN,"Last header byte is not zero!\n");
+                    stream_skip(demuxer->stream, 1);
+                    i = stream_read_char(demuxer->stream);
+                    sh->format = stream_read_dword_le(demuxer->stream);
+                    if (i != 4) {
+                      mp_msg(MSGT_DEMUX,MSGL_WARN,"Audio FourCC size is not 4 (%d), please report to "
+                             "MPlayer developers\n", i);
+                      stream_skip(demuxer->stream, i - 4);
+                    }
+                    if (sh->format != mmioFOURCC('l','p','c','J')) {
+                      mp_msg(MSGT_DEMUX,MSGL_WARN,"Version 3 audio with FourCC %8x, please report to "
+                             "MPlayer developers\n", sh->format);
+                    }
+                    sh->channels = 1;
+                    sh->samplesize = 16;
+                    sh->samplerate = 8000;
+                    frame_size = 240;
+                    strcpy(buf, "14_4");
+                   } else {
+		    stream_skip(demuxer->stream, 2); // 00 00
+		    stream_skip(demuxer->stream, 4); /* .ra4 or .ra5 */
+		    stream_skip(demuxer->stream, 4); // ???
+		    stream_skip(demuxer->stream, 2); /* version (4 or 5) */
+//		    stream_skip(demuxer->stream, 4); // header size == 0x4E
+		    hdr_size = stream_read_dword(demuxer->stream); // header size
+		    mp_msg(MSGT_DEMUX,MSGL_V,"header size: %d\n", hdr_size);
+		    flavor = stream_read_word(demuxer->stream);/* codec flavor id */
+		    coded_frame_size = stream_read_dword(demuxer->stream);/* needed by codec */
+		    //stream_skip(demuxer->stream, 4); /* coded frame size */
+		    stream_skip(demuxer->stream, 4); // big number
+		    stream_skip(demuxer->stream, 4); // bigger number
+		    stream_skip(demuxer->stream, 4); // 2 || -''-
+//		    stream_skip(demuxer->stream, 2); // 0x10
+		    sub_packet_h = stream_read_word(demuxer->stream);
+//		    stream_skip(demuxer->stream, 2); /* coded frame size */
+		    frame_size = stream_read_word(demuxer->stream);
+		    mp_msg(MSGT_DEMUX,MSGL_V,"frame_size: %d\n", frame_size);
+		    sub_packet_size = stream_read_word(demuxer->stream);
+		    mp_msg(MSGT_DEMUX,MSGL_V,"sub_packet_size: %d\n", sub_packet_size);
+		    stream_skip(demuxer->stream, 2); // 0
+		    
+		    if (version == 5)
+			stream_skip(demuxer->stream, 6); //0,srate,0
+
+		    sh->samplerate = stream_read_word(demuxer->stream);
+		    stream_skip(demuxer->stream, 2);  // 0
+		    sh->samplesize = stream_read_word(demuxer->stream)/8;
+		    sh->channels = stream_read_word(demuxer->stream);
+		    mp_msg(MSGT_DEMUX,MSGL_V,"samplerate: %d, channels: %d\n",
+			sh->samplerate, sh->channels);
+
+		    if (version == 5)
+		    {
+			stream_skip(demuxer->stream, 4);  // "genr"
+			stream_read(demuxer->stream, buf, 4); // fourcc
+			buf[4] = 0;
+		    }
+		    else
+		    {		
+			/* Desc #1 */
+			skip_str(1, demuxer);
+			/* Desc #2 */
+			get_str(1, demuxer, buf, sizeof(buf));
+		    }
+                   }
+
+		    /* Emulate WAVEFORMATEX struct: */
+		    sh->wf = malloc(sizeof(WAVEFORMATEX));
+		    memset(sh->wf, 0, sizeof(WAVEFORMATEX));
+		    sh->wf->nChannels = sh->channels;
+		    sh->wf->wBitsPerSample = sh->samplesize*8;
+		    sh->wf->nSamplesPerSec = sh->samplerate;
+		    sh->wf->nAvgBytesPerSec = bitrate;
+		    sh->wf->nBlockAlign = frame_size;
+		    sh->wf->cbSize = 0;
+		    sh->format = MKTAG(buf[0], buf[1], buf[2], buf[3]);
+
+#if 0
+		    switch (sh->format){
+			case MKTAG('d', 'n', 'e', 't'):
+			    mp_msg(MSGT_DEMUX,MSGL_V,"Audio: DNET (AC3 with low-bitrate extension)\n");
+			    break;
+			case MKTAG('s', 'i', 'p', 'r'):
+			    mp_msg(MSGT_DEMUX,MSGL_V,"Audio: SiproLab's ACELP.net\n");
+			    break;
+			case MKTAG('c', 'o', 'o', 'k'):
+			    mp_msg(MSGT_DEMUX,MSGL_V,"Audio: Real's GeneralCooker (?) (RealAudio G2?) (unsupported)\n");
+			    break;
+			case MKTAG('a', 't', 'r', 'c'):
+			    mp_msg(MSGT_DEMUX,MSGL_V,"Audio: Sony ATRAC3 (RealAudio 8) (unsupported)\n");
+			    break;
+			default:
+			    mp_msg(MSGT_DEMUX,MSGL_V,"Audio: Unknown (%s)\n", buf);
+		    }
+#endif
+
+		    switch (sh->format)
+		    {
+			case MKTAG('d', 'n', 'e', 't'):
+			    mp_msg(MSGT_DEMUX,MSGL_V,"Audio: DNET -> AC3\n");
+//			    sh->format = 0x2000;
+			    break;
+			case MKTAG('1', '4', '_', '4'):
+                            sh->wf->cbSize = 10;
+                            sh->wf = realloc(sh->wf, sizeof(WAVEFORMATEX)+sh->wf->cbSize);
+                            ((short*)(sh->wf+1))[0]=0;
+                            ((short*)(sh->wf+1))[1]=240;
+                            ((short*)(sh->wf+1))[2]=0;
+                            ((short*)(sh->wf+1))[3]=0x14;
+                            ((short*)(sh->wf+1))[4]=0;
+                            break;
+
+			case MKTAG('2', '8', '_', '8'):
+			    sh->wf->cbSize = 10;
+			    sh->wf = realloc(sh->wf, sizeof(WAVEFORMATEX)+sh->wf->cbSize);
+			    ((short*)(sh->wf+1))[0]=sub_packet_size;
+			    ((short*)(sh->wf+1))[1]=sub_packet_h;
+			    ((short*)(sh->wf+1))[2]=flavor;
+			    ((short*)(sh->wf+1))[3]=coded_frame_size;
+			    ((short*)(sh->wf+1))[4]=0;
+			    break;
+
+			case MKTAG('s', 'i', 'p', 'r'):
+#if 0
+			    sh->format = 0x130;
+			    /* for buggy directshow loader */
+			    sh->wf->cbSize = 4;
+			    sh->wf = realloc(sh->wf, sizeof(WAVEFORMATEX)+sh->wf->cbSize);
+			    sh->wf->wBitsPerSample = 0;
+			    sh->wf->nAvgBytesPerSec = 1055;
+			    sh->wf->nBlockAlign = 19;
+//			    sh->wf->nBlockAlign = frame_size / 288;
+			    buf[0] = 30;
+			    buf[1] = 1;
+			    buf[2] = 1;
+			    buf[3] = 0;
+			    memcpy((sh->wf+18), (char *)&buf[0], 4);
+//			    sh->wf[sizeof(WAVEFORMATEX)+1] = 30;
+//			    sh->wf[sizeof(WAVEFORMATEX)+2] = 1;
+//			    sh->wf[sizeof(WAVEFORMATEX)+3] = 1;
+//			    sh->wf[sizeof(WAVEFORMATEX)+4] = 0;
+			    break;
+#endif
+			case MKTAG('a', 't', 'r', 'c'):
+#if 0
+			    sh->format = 0x270;
+			    /* 14 bytes extra header needed ! */
+			    sh->wf->cbSize = 14;
+			    sh->wf = realloc(sh->wf, sizeof(WAVEFORMATEX)+sh->wf->cbSize);
+			    sh->wf->nAvgBytesPerSec = 16537; // 8268
+			    sh->wf->nBlockAlign = 384; // 192
+			    sh->wf->wBitsPerSample = 0; /* from AVI created by VirtualDub */
+			    break;
+#endif
+			case MKTAG('c', 'o', 'o', 'k'):
+			    // realaudio codec plugins - common:
+//			    sh->wf->cbSize = 4+2+24;
+			    stream_skip(demuxer->stream,3);  // Skip 3 unknown bytes 
+			    if (version==5)
+			      stream_skip(demuxer->stream,1);  // Skip 1 additional unknown byte 
+			    codecdata_length=stream_read_dword(demuxer->stream);
+			    sh->wf->cbSize = 10+codecdata_length;
+			    sh->wf = realloc(sh->wf, sizeof(WAVEFORMATEX)+sh->wf->cbSize);
+			    ((short*)(sh->wf+1))[0]=sub_packet_size;
+			    ((short*)(sh->wf+1))[1]=sub_packet_h;
+			    ((short*)(sh->wf+1))[2]=flavor;
+			    ((short*)(sh->wf+1))[3]=coded_frame_size;
+			    ((short*)(sh->wf+1))[4]=codecdata_length;
+//			    stream_read(demuxer->stream, ((char*)(sh->wf+1))+6, 24); // extras
+			    stream_read(demuxer->stream, ((char*)(sh->wf+1))+10, codecdata_length); // extras
+			    break;
+			case MKTAG('r', 'a', 'a', 'c'):
+			case MKTAG('r', 'a', 'c', 'p'):
+			    /* This is just AAC. The two or five bytes of */
+			    /* config data needed for libfaad are stored */
+			    /* after the audio headers. */
+			    stream_skip(demuxer->stream,3);  // Skip 3 unknown bytes 
+			    if (version==5)
+				stream_skip(demuxer->stream,1);  // Skip 1 additional unknown byte 
+			    codecdata_length=stream_read_dword(demuxer->stream);
+			    if (codecdata_length>=1) {
+				sh->codecdata_len = codecdata_length - 1;
+				sh->codecdata = calloc(sh->codecdata_len, 1);
+				stream_skip(demuxer->stream, 1);
+				stream_read(demuxer->stream, sh->codecdata, sh->codecdata_len);
+			    }
+			    sh->format = mmioFOURCC('M', 'P', '4', 'A');
+			    break;
+			default:
+			    mp_msg(MSGT_DEMUX,MSGL_V,"Audio: Unknown (%s)\n", buf);
+		    }
+
+		    sh->wf->wFormatTag = sh->format;
+		    
+		    print_wave_header(sh->wf);
+
+		    if(demuxer->audio->id==stream_id){
+			demuxer->audio->id=stream_id;
+			sh->ds=demuxer->audio;
+			demuxer->audio->sh=sh;
+		    }
+		    
+		    ++a_streams;
+
+#ifdef stream_skip
+#undef stream_skip
+#endif
+		}
+		else
+//		case MKTAG('V', 'I', 'D', 'O'):
+		if(tmp == MKTAG('O', 'D', 'I', 'V'))
+		{
+		    /* video header */
+		    sh_video_t *sh = new_sh_video(demuxer, stream_id);
+
+		    sh->format = stream_read_dword_le(demuxer->stream); /* fourcc */
+		    mp_msg(MSGT_DEMUX,MSGL_V,"video fourcc: %.4s (%x)\n", (char *)&sh->format, sh->format);
+
+		    /* emulate BITMAPINFOHEADER */
+		    sh->bih = malloc(sizeof(BITMAPINFOHEADER)+12);
+		    memset(sh->bih, 0, sizeof(BITMAPINFOHEADER)+12);
+	    	    sh->bih->biSize = 48;
+		    sh->disp_w = sh->bih->biWidth = stream_read_word(demuxer->stream);
+		    sh->disp_h = sh->bih->biHeight = stream_read_word(demuxer->stream);
+		    sh->bih->biPlanes = 1;
+		    sh->bih->biBitCount = 24;
+		    sh->bih->biCompression = sh->format;
+		    sh->bih->biSizeImage= sh->bih->biWidth*sh->bih->biHeight*3;
+
+		    sh->fps = (float) stream_read_word(demuxer->stream);
+		    if (sh->fps<=0) sh->fps=24; // we probably won't even care about fps
+		    sh->frametime = 1.0f/sh->fps;
+		    
+#if 1
+		    stream_skip(demuxer->stream, 4);
+#else
+		    mp_msg(MSGT_DEMUX, MSGL_V,"unknown1: 0x%X  \n",stream_read_dword(demuxer->stream));
+		    mp_msg(MSGT_DEMUX, MSGL_V,"unknown2: 0x%X  \n",stream_read_word(demuxer->stream));
+		    mp_msg(MSGT_DEMUX, MSGL_V,"unknown3: 0x%X  \n",stream_read_word(demuxer->stream));
+#endif
+//		    if(sh->format==0x30335652 || sh->format==0x30325652 )
+		    if(1)
+		    {
+			int tmp=stream_read_word(demuxer->stream);
+			if(tmp>0){
+			    sh->fps=tmp; sh->frametime = 1.0f/sh->fps;
+			}
+		    } else {
+	    		int fps=stream_read_word(demuxer->stream);
+			mp_msg(MSGT_DEMUX, MSGL_WARN,"realvid: ignoring FPS = %d\n",fps);
+		    }
+		    stream_skip(demuxer->stream, 2);
+		    
+		    // read codec sub-format (to make difference between low and high rate codec)
+		    ((unsigned int*)(sh->bih+1))[0]=stream_read_dword(demuxer->stream);
+
+		    /* h263 hack */
+		    tmp = stream_read_dword(demuxer->stream);
+		    ((unsigned int*)(sh->bih+1))[1]=tmp;
+		    mp_msg(MSGT_DEMUX,MSGL_V,"H.263 ID: %x\n", tmp);
+		    switch (tmp)
+		    {
+			case 0x10000000:
+			    /* sub id: 0 */
+			    /* codec id: rv10 */
+			    break;
+			case 0x10003000:
+			case 0x10003001:
+			    /* sub id: 3 */
+			    /* codec id: rv10 */
+			    sh->bih->biCompression = sh->format = mmioFOURCC('R', 'V', '1', '3');
+			    break;
+			case 0x20001000:
+			case 0x20100001:
+			case 0x20200002:
+			    /* codec id: rv20 */
+			    break;
+			case 0x30202002:
+			    /* codec id: rv30 */
+			    break;
+			case 0x40000000:
+			    /* codec id: rv40 */
+			    break;
+			default:
+			    /* codec id: none */
+			    mp_msg(MSGT_DEMUX,MSGL_V,"unknown id: %x\n", tmp);
+		    }
+
+		    if((sh->format<=0x30335652) && (tmp>=0x20200002)){
+			// read secondary WxH for the cmsg24[] (see vd_realvid.c)
+			((unsigned short*)(sh->bih+1))[4]=4*(unsigned short)stream_read_char(demuxer->stream); //widht
+			((unsigned short*)(sh->bih+1))[5]=4*(unsigned short)stream_read_char(demuxer->stream); //height
+		    } 
+		    
+		    if(demuxer->video->id==stream_id){
+			demuxer->video->id=stream_id;
+			sh->ds=demuxer->video;
+			demuxer->video->sh=sh;
+		    }
+		    
+		    ++v_streams;
+
+		}
+		else {
+		    mp_msg(MSGT_DEMUX, MSGL_ERR, "Not audio/video stream or unsupported!\n");
+		}
+//		break;
+//	    default:
+//skip_this_chunk:
+		/* skip codec info */
+		tmp = stream_tell(demuxer->stream) - codec_pos;
+		mp_msg(MSGT_DEMUX,MSGL_V,"### skipping %d bytes of codec info\n", codec_data_size - tmp);
+#if 0
+		{ int i;
+		  for(i=0;i<codec_data_size - tmp;i++)
+		      mp_msg(MSGT_DEMUX, MSGL_V," %02X",stream_read_char(demuxer->stream));
+		  mp_msg(MSGT_DEMUX, MSGL_V,"\n");
+		}
+#else
+		stream_skip(demuxer->stream, codec_data_size - tmp);
+#endif
+		break;
+//	    }
+	    }
+	    case MKTAG('D', 'A', 'T', 'A'):
+		goto header_end;
+	    case MKTAG('I', 'N', 'D', 'X'):
+	    default:
+		mp_msg(MSGT_DEMUX,MSGL_V,"Unknown chunk: %x\n", chunk_id);
+		stream_skip(demuxer->stream, chunk_size - 10);
+		break;
+	}
+    }
+
+header_end:
+//    printf("i=%d num_of_headers=%d   \n",i,num_of_headers);
+    priv->num_of_packets = stream_read_dword(demuxer->stream);
+//    stream_skip(demuxer->stream, 4); /* number of packets */
+    stream_skip(demuxer->stream, 4); /* next data header */
+
+    mp_msg(MSGT_DEMUX,MSGL_V,"Packets in file: %d\n", priv->num_of_packets);
+
+    if (priv->num_of_packets == 0)
+	priv->num_of_packets = -10;
+
+
+    priv->audio_need_keyframe = 0;
+    priv->video_after_seek = 0;
+
+    switch (index_mode){
+	case -1: // untouched
+	    if (priv->index_chunk_offset && (priv->index_chunk_offset < demuxer->movi_end))
+	    {
+		parse_index_chunk(demuxer);
+		demuxer->seekable = 1;
+	    }
+	    break;
+	case 1: // use (generate index)
+	    if (priv->index_chunk_offset && (priv->index_chunk_offset < demuxer->movi_end))
+	    {
+		parse_index_chunk(demuxer);
+		demuxer->seekable = 1;
+	    } else {
+		generate_index(demuxer);
+		demuxer->seekable = 1;
+	    }
+	    break;
+	case 2: // force generating index
+	    generate_index(demuxer);
+	    demuxer->seekable = 1;
+	    break;
+	default: // do nothing
+    	    break;
+    }
+
+    // detect streams:
+    if(demuxer->video->id==-1 && v_streams>0){
+	// find the valid video stream:
+	if(!ds_fill_buffer(demuxer->video)){
+          mp_msg(MSGT_DEMUXER,MSGL_INFO,"RM: " MSGTR_MissingVideoStream);
+	}
+    }
+    if(demuxer->audio->id==-1 && a_streams>0){
+	// find the valid audio stream:
+	if(!ds_fill_buffer(demuxer->audio)){
+          mp_msg(MSGT_DEMUXER,MSGL_INFO,"RM: " MSGTR_MissingAudioStream);
+	}
+    }
+
+    if(demuxer->video->sh){
+	sh_video_t *sh=demuxer->video->sh;
+	mp_msg(MSGT_DEMUX,MSGL_INFO,"VIDEO:  %.4s [%08X,%08X]  %dx%d  (aspect %4.2f)  %4.2f fps\n",
+	    &sh->format,((unsigned int*)(sh->bih+1))[1],((unsigned int*)(sh->bih+1))[0],
+	    sh->disp_w,sh->disp_h,sh->aspect,sh->fps);
+    }
+
+}
+
+void demux_close_real(demuxer_t *demuxer)
+{
+    real_priv_t* priv = demuxer->priv;
+ 
+    if (priv)
+	free(priv);
+
+    return;
+}
+
+extern void resync_audio_stream(sh_audio_t * sh_audio);
+
+/* please upload RV10 samples WITH INDEX CHUNK */
+int demux_seek_real(demuxer_t *demuxer, float rel_seek_secs, int flags)
+{
+    real_priv_t *priv = demuxer->priv;
+    demux_stream_t *d_audio = demuxer->audio;
+    demux_stream_t *d_video = demuxer->video;
+    sh_audio_t *sh_audio = d_audio->sh;
+    sh_video_t *sh_video = d_video->sh;
+    int vid = d_video->id, aid = d_audio->id;
+    int next_offset = 0;
+    int cur_timestamp = 0;
+    int streams = 0;
+    int retried = 0;
+
+
+    if (sh_video && (unsigned)vid < MAX_STREAMS && priv->index_table_size[vid])
+	streams |= 1;
+    if (sh_audio && (unsigned)aid < MAX_STREAMS && priv->index_table_size[aid])
+	streams |= 2;
+
+//    printf("streams: %d\n", streams);
+
+    if (!streams)
+	return 0;
+
+    if (flags & 1)
+	/* seek absolute */
+	priv->current_apacket = priv->current_vpacket = 0;
+
+    if ((streams & 1) && priv->current_vpacket >= priv->index_table_size[vid])
+	priv->current_vpacket = priv->index_table_size[vid] - 1;
+    if ((streams & 2) && priv->current_apacket >= priv->index_table_size[aid])
+	priv->current_apacket = priv->index_table_size[aid] - 1;
+
+//    if (index_mode == 1 || index_mode == 2) {
+    	if (streams & 1) {// use the video index if we have one
+            cur_timestamp = priv->index_table[vid][priv->current_vpacket].timestamp;
+	    if (rel_seek_secs > 0)
+	    	while ((priv->index_table[vid][priv->current_vpacket].timestamp - cur_timestamp) < rel_seek_secs * 1000){
+	    		priv->current_vpacket += 1;
+	    		if (priv->current_vpacket >= priv->index_table_size[vid]) {
+	    			priv->current_vpacket = priv->index_table_size[vid] - 1;
+				if (!retried) {
+					stream_seek(demuxer->stream, priv->index_table[vid][priv->current_vpacket].offset);
+					add_index_segment(demuxer, vid, cur_timestamp + rel_seek_secs * 1000);
+					retried = 1;
+				}
+				else
+	    				break;
+	    		}
+	    	} 
+	    else if (rel_seek_secs < 0)
+	    	while ((cur_timestamp - priv->index_table[vid][priv->current_vpacket].timestamp) < - rel_seek_secs * 1000){
+	    		priv->current_vpacket -= 1;
+	    		if (priv->current_vpacket < 0) {
+	    			priv->current_vpacket = 0;
+	    			break;
+	    		}
+	    	}
+	    next_offset = priv->index_table[vid][priv->current_vpacket].offset;
+	    priv->audio_need_keyframe = 1;
+	    priv->video_after_seek = 1;
+        }
+    	else if (streams & 2) {
+            cur_timestamp = priv->index_table[aid][priv->current_apacket].timestamp;
+	    if (rel_seek_secs > 0)
+	    	while ((priv->index_table[aid][priv->current_apacket].timestamp - cur_timestamp) < rel_seek_secs * 1000){
+	    		priv->current_apacket += 1;
+	    		if (priv->current_apacket >= priv->index_table_size[aid]) {
+	    			priv->current_apacket = priv->index_table_size[aid] - 1;
+	    			break;
+	    		}
+	    	}
+	    else if (rel_seek_secs < 0)
+	    	while ((cur_timestamp - priv->index_table[aid][priv->current_apacket].timestamp) < - rel_seek_secs * 1000){
+	    		priv->current_apacket -= 1;
+	    		if (priv->current_apacket < 0) {
+	    			priv->current_apacket = 0;
+	    			break;
+	    		}
+	    	}
+	    next_offset = priv->index_table[aid][priv->current_apacket].offset;
+        }
+//    }
+//    printf("seek: pos: %d, current packets: a: %d, v: %d\n",
+//	next_offset, priv->current_apacket, priv->current_vpacket);
+    if (next_offset)
+        stream_seek(demuxer->stream, next_offset);
+
+    demux_real_fill_buffer(demuxer);
+    if (sh_audio)
+        resync_audio_stream(sh_audio);
+    return 1;
+}
+
+int demux_real_control(demuxer_t *demuxer, int cmd, void *arg)
+{
+    real_priv_t *priv = demuxer->priv;
+    int lastpts = priv->v_pts ? priv->v_pts : priv->a_pts;
+    
+    switch (cmd) {
+        case DEMUXER_CTRL_GET_TIME_LENGTH:
+	    if (priv->duration == 0)
+	        return DEMUXER_CTRL_DONTKNOW;
+	    
+	    *((unsigned long *)arg) = priv->duration;
+	    return DEMUXER_CTRL_OK;
+
+	case DEMUXER_CTRL_GET_PERCENT_POS:
+	    if (priv->duration == 0)
+	        return DEMUXER_CTRL_DONTKNOW;
+	    
+	    *((int *)arg) = (int)(100 * lastpts / priv->duration);
+	    return DEMUXER_CTRL_OK;
+	
+	default:
+	    return DEMUXER_CTRL_NOTIMPL;
+    }
+}
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_ty.c MPlayer-1.0pre5/libmpdemux/demux_ty.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_ty.c	2003-10-05 00:29:01 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_ty.c	2004-08-08 10:36:04 +0700
@@ -426,8 +426,13 @@
                if ( demux->stream->end_pos > TIVO_PART_LENGTH )
                {
                   numberParts = demux->stream->end_pos / TIVO_PART_LENGTH;
+#ifdef _LARGEFILE_SOURCE 
+                  mp_msg( MSGT_DEMUX, MSGL_DBG3, "ty:Number Parts %lld\n",
+                    numberParts );
+#else
                   mp_msg( MSGT_DEMUX, MSGL_DBG3, "ty:Number Parts %d\n",
                     numberParts );
+#endif
                   stream_seek( demux->stream, numberParts * TIVO_PART_LENGTH );
                   // mp_msg( MSGT_DEMUX, MSGL_DBG3, 
 				      //    "ty:Reading a chunk %d\n", __LINE__ );
diff -urN MPlayer-1.0pre5.orig/libmpdemux/demux_viv.c MPlayer-1.0pre5/libmpdemux/demux_viv.c
--- MPlayer-1.0pre5.orig/libmpdemux/demux_viv.c	2004-03-31 12:40:31 +0700
+++ MPlayer-1.0pre5/libmpdemux/demux_viv.c	2004-08-08 10:36:04 +0700
@@ -105,8 +105,13 @@
 	header_len -= strlen(token)+2;
 	if (sscanf(token, "%[^:]:%[^\n]", opt, param) != 2)
 	{
-	    mp_msg(MSGT_DEMUX, MSGL_V, "viv_text_header_parser: bad line: '%s' at ~%p\n",
+#ifdef _LARGEFILE_SOURCE 
+	    mp_msg(MSGT_DEMUX, MSGL_V, "viv_text_header_parser: bad line: '%s' at ~%#llx\n",
 		token, stream_tell(demux->stream));
+#else
+	    mp_msg(MSGT_DEMUX, MSGL_V, "viv_text_header_parser: bad line: '%s' at ~%#lx\n",
+		token, stream_tell(demux->stream));
+#endif
 	    break;
 	}
 	mp_dbg(MSGT_DEMUX, MSGL_DBG3, "token: '%s' (%d bytes/%d bytes left)\n",
@@ -356,8 +361,13 @@
       audio_pos+=len;
       break;
   default:
+#ifdef _LARGEFILE_SOURCE 
+      mp_msg(MSGT_DEMUX,MSGL_WARN,"VIVO - unknown ID found: %02X at pos %llu contact author!\n",
+        c, stream_tell(demux->stream));
+#else
       mp_msg(MSGT_DEMUX,MSGL_WARN,"VIVO - unknown ID found: %02X at pos %lu contact author!\n",
         c, stream_tell(demux->stream));
+#endif
       return 0;
   }
 
diff -urN MPlayer-1.0pre5.orig/libmpdemux/tvi_v4l.c MPlayer-1.0pre5/libmpdemux/tvi_v4l.c
--- MPlayer-1.0pre5.orig/libmpdemux/tvi_v4l.c	2004-05-02 01:15:29 +0700
+++ MPlayer-1.0pre5/libmpdemux/tvi_v4l.c	2004-08-08 10:36:04 +0700
@@ -437,7 +437,7 @@
     priv->audio_skew_buffer = NULL;
 
     priv->video_fd = open(priv->video_device, O_RDWR);
-    mp_msg(MSGT_TV, MSGL_DBG2, "Video fd: %d, %x\n", priv->video_fd,
+    mp_msg(MSGT_TV, MSGL_DBG2, "Video fd: %d, %p\n", priv->video_fd,
 	priv->video_device);
     if (priv->video_fd == -1)
     {
diff -urN MPlayer-1.0pre5.orig/libmpdemux/tvi_v4l.c.orig MPlayer-1.0pre5/libmpdemux/tvi_v4l.c.orig
--- MPlayer-1.0pre5.orig/libmpdemux/tvi_v4l.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/libmpdemux/tvi_v4l.c.orig	2004-05-02 01:15:29 +0700
@@ -0,0 +1,1757 @@
+/*
+  Video 4 Linux input
+
+  (C) Alex Beregszaszi
+  
+  Some ideas are based on xawtv/libng's grab-v4l.c written by
+    Gerd Knorr <kraxel@bytesex.org>
+
+  Multithreading, a/v sync and native ALSA support by
+    Jindrich Makovicka <makovick@kmlinux.fjfi.cvut.cz>
+
+  Mjpeg hardware encoding support by 
+    Ivn Sznt <szivan@freemail.hu>
+
+  CODE IS UNDER DEVELOPMENT, NO FEATURE REQUESTS PLEASE!
+*/
+
+#include "config.h"
+
+#if defined(USE_TV) && defined(HAVE_TV_V4L)
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+/* Necessary to prevent collisions between <linux/time.h> and <sys/time.h> when V4L2 is installed. */
+#define _LINUX_TIME_H
+
+#include <linux/videodev.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#ifdef HAVE_SYS_SYSINFO_H
+#include <sys/sysinfo.h>
+#endif
+
+#include "mp_msg.h"
+#include "../libao2/afmt.h"
+#include "../libvo/img_format.h"
+#include "../libvo/fastmemcpy.h"
+#include "../libvo/videodev_mjpeg.h"
+
+#include "tv.h"
+
+#include "audio_in.h"
+
+static tvi_info_t info = {
+	"Video 4 Linux input",
+	"v4l",
+	"Alex Beregszaszi",
+	"under development"
+};
+
+#define PAL_WIDTH  768
+#define PAL_HEIGHT 576
+#define PAL_FPS    25
+
+#define NTSC_WIDTH  640
+#define NTSC_HEIGHT 480
+#define NTSC_FPS    29.97
+
+#define MAX_AUDIO_CHANNELS	10
+
+#define VID_BUF_SIZE_IMMEDIATE 2
+#define VIDEO_AVG_BUFFER_SIZE 600
+
+typedef struct {
+    /* general */
+    char			*video_device;
+    int                         video_fd;
+    struct video_capability	capability;
+    struct video_channel	*channels;
+    int				act_channel;
+    struct video_tuner		tuner;
+
+    /* video */
+    struct video_picture	picture;
+    int				format;		/* output format */
+    int				width;
+    int				height;
+    int				bytesperline;
+    float			fps;
+
+    struct video_mbuf		mbuf;
+    unsigned char               *mmap;
+    struct video_mmap		*buf;
+    int				nbuf;
+
+    /* audio */
+    char			*audio_device;
+    audio_in_t                  audio_in;
+
+    int				audio_id;
+    struct video_audio		audio[MAX_AUDIO_CHANNELS];
+    int				audio_channels[MAX_AUDIO_CHANNELS];
+
+    /* buffering stuff */
+    int                         immediate_mode;
+
+    int                         audio_buffer_size;
+    int                         aud_skew_cnt;
+    unsigned char		*audio_ringbuffer;
+    long long			*audio_skew_buffer;
+    volatile int		audio_head;
+    volatile int		audio_tail;
+    volatile int		audio_cnt;
+    volatile long long          audio_skew;
+    volatile double             audio_skew_factor;
+    volatile long long          audio_skew_measure_time;
+    volatile int                audio_drop;
+
+    int                         first;
+    int                         video_buffer_size_max;
+    volatile int                video_buffer_size_current;
+    unsigned char		**video_ringbuffer;
+    long long                   *video_timebuffer;
+    long long                   *video_avg_buffer;
+    int		                video_avg_ptr;
+    int		                video_interval_sum;
+    volatile int		video_head;
+    volatile int		video_tail;
+    volatile int		video_cnt;
+
+    volatile int                shutdown;
+
+    pthread_t			audio_grabber_thread;
+    pthread_t			video_grabber_thread;
+    pthread_mutex_t             audio_starter;
+    pthread_mutex_t             skew_mutex;
+    pthread_mutex_t             video_buffer_mutex;
+
+    long long                   starttime;
+    double                      audio_secs_per_block;
+    long long                   audio_skew_total;
+    long			audio_recv_blocks_total;
+    long			audio_sent_blocks_total;
+    long                        mjpeg_bufsize;
+    
+} priv_t;
+
+#include "tvi_def.h"
+
+static const char *device_cap2name[] = {
+    "capture", "tuner", "teletext", "overlay", "chromakey", "clipping",
+    "frameram", "scales", "monochrome", "subcapture", "mpeg-decoder",
+    "mpeg-encoder", "mjpeg-decoder", "mjpeg-encoder", NULL
+};
+
+static const char *device_palette2name[] = {
+    "-", "grey", "hi240", "rgb16", "rgb24", "rgb32", "rgb15", "yuv422",
+    "yuyv", "uyvy", "yuv420", "yuv411", "raw", "yuv422p", "yuv411p",
+    "yuv420p", "yuv410p"
+};
+#define PALETTE(x) ((x < sizeof(device_palette2name)/sizeof(char*)) ? device_palette2name[x] : "UNKNOWN")
+
+static const char *norm2name(int mode)
+{
+    switch (mode) {
+    case VIDEO_MODE_PAL:
+	return "pal";
+    case VIDEO_MODE_SECAM:
+	return "secam";
+    case VIDEO_MODE_NTSC:
+	return "ntsc";
+    case VIDEO_MODE_AUTO:
+	return "auto";
+    default:
+	return "unknown";
+    }
+};
+
+static const char *audio_mode2name(int mode)
+{
+    switch (mode) {
+    case VIDEO_SOUND_MONO:
+	return "mono";
+    case VIDEO_SOUND_STEREO:
+	return "stereo";
+    case VIDEO_SOUND_LANG1:
+	return "language1";
+    case VIDEO_SOUND_LANG2:
+	return "language2";
+    default:
+	return "unknown";
+    }
+};
+
+static void *audio_grabber(void *data);
+static void *video_grabber(void *data);
+
+static int palette2depth(int palette)
+{
+    switch(palette)
+    {
+	/* component */
+	case VIDEO_PALETTE_RGB555:
+	    return(15);
+	case VIDEO_PALETTE_RGB565:
+	    return(16);
+	case VIDEO_PALETTE_RGB24:
+	    return(24);
+	case VIDEO_PALETTE_RGB32:
+	    return(32);
+	/* planar */
+	case VIDEO_PALETTE_YUV411P:
+	case VIDEO_PALETTE_YUV420P:
+	case VIDEO_PALETTE_YUV410P:
+	    return(12);
+	/* packed */
+	case VIDEO_PALETTE_YUV422P:
+	case VIDEO_PALETTE_YUV422:
+	case VIDEO_PALETTE_YUYV:
+	case VIDEO_PALETTE_UYVY:
+	case VIDEO_PALETTE_YUV420:
+	case VIDEO_PALETTE_YUV411:
+	    return(16);
+    }
+    return(-1);
+}
+
+static int format2palette(int format)
+{
+    switch(format)
+    {
+	case IMGFMT_BGR15:
+	    return(VIDEO_PALETTE_RGB555);
+	case IMGFMT_BGR16:
+	    return(VIDEO_PALETTE_RGB565);
+	case IMGFMT_BGR24:
+	    return(VIDEO_PALETTE_RGB24);
+	case IMGFMT_BGR32:
+	    return(VIDEO_PALETTE_RGB32);
+	case IMGFMT_YV12:
+	case IMGFMT_I420:
+	    return(VIDEO_PALETTE_YUV420P);
+	case IMGFMT_YUY2:
+	    return(VIDEO_PALETTE_YUV422);
+    case IMGFMT_UYVY:
+       return(VIDEO_PALETTE_UYVY);
+    }
+    return(-1);
+}
+
+// sets and sanitizes audio buffer/block sizes
+static void setup_audio_buffer_sizes(priv_t *priv)
+{
+    int bytes_per_sample = priv->audio_in.bytes_per_sample;
+
+    // make the audio buffer at least 5 seconds long
+    priv->audio_buffer_size = 1 + 5*priv->audio_in.samplerate
+	*priv->audio_in.channels
+	*bytes_per_sample/priv->audio_in.blocksize;
+    if (priv->audio_buffer_size < 256) priv->audio_buffer_size = 256;
+
+    // make the skew buffer at least 1 second long
+    priv->aud_skew_cnt = 1 + 1*priv->audio_in.samplerate
+	*priv->audio_in.channels
+	*bytes_per_sample/priv->audio_in.blocksize;
+    if (priv->aud_skew_cnt < 16) priv->aud_skew_cnt = 16;
+
+    mp_msg(MSGT_TV, MSGL_V, "Audio capture - buffer %d blocks of %d bytes, skew average from %d meas.\n",
+	   priv->audio_buffer_size, priv->audio_in.blocksize, priv->aud_skew_cnt);
+}
+
+tvi_handle_t *tvi_init_v4l(char *device, char *adevice)
+{
+    tvi_handle_t *h;
+    priv_t *priv;
+    
+    h = new_handle();
+    if (!h)
+	return(NULL);
+
+    priv = h->priv;
+
+    /* set video device name */
+    if (!device)
+	priv->video_device = strdup("/dev/video0");
+    else
+	priv->video_device = strdup(device);
+
+    /* set video device name */
+    if (!adevice)
+	priv->audio_device = NULL;
+    else {
+	priv->audio_device = strdup(adevice);
+    }
+    
+    /* allocation failed */
+    if (!priv->video_device) {
+	free_handle(h);
+	return(NULL);
+    }
+
+    return(h);
+}
+
+/* retrieves info about audio channels from the BTTV */
+static void init_v4l_audio(priv_t *priv)
+{
+    int i;
+    int reqmode;
+
+    if (!priv->capability.audios) return;
+
+    /* audio chanlist */
+
+    mp_msg(MSGT_TV, MSGL_V, " Audio devices: %d\n", priv->capability.audios);
+
+    mp_msg(MSGT_TV, MSGL_V, "Video capture card reports the audio setup as follows:\n");
+    for (i = 0; i < priv->capability.audios; i++)
+    {
+	if (i >= MAX_AUDIO_CHANNELS)
+	{
+	    mp_msg(MSGT_TV, MSGL_ERR, "no space for more audio channels (increase in source!) (%d > %d)\n",
+		   i, MAX_AUDIO_CHANNELS);
+	    i = priv->capability.audios;
+	    break;
+	}
+
+	priv->audio[i].audio = i;
+	if (ioctl(priv->video_fd, VIDIOCGAUDIO, &priv->audio[i]) == -1)
+	{
+	    mp_msg(MSGT_TV, MSGL_ERR, "ioctl get audio failed: %s\n", strerror(errno));
+	    break;
+	}
+
+	/* mute all channels */
+	priv->audio[i].flags |= VIDEO_AUDIO_MUTE;
+	reqmode = -1;
+	if (tv_param_amode >= 0) {
+	    switch (tv_param_amode) {
+	    case 0:
+		reqmode = VIDEO_SOUND_MONO;
+		break;
+	    case 1:
+		reqmode = VIDEO_SOUND_STEREO;
+		break;
+	    case 2:
+		reqmode = VIDEO_SOUND_LANG1;
+		break;
+	    case 3:
+		reqmode = VIDEO_SOUND_LANG2;
+		break;
+	    default:
+		mp_msg(MSGT_TV, MSGL_ERR, "Unknown audio mode requested.\n");
+		break;
+	    }
+	    if (reqmode >= 0) priv->audio[i].mode = reqmode;
+	}
+	ioctl(priv->video_fd, VIDIOCSAUDIO, &priv->audio[i]);
+	
+	// get the parameters back
+	if (ioctl(priv->video_fd, VIDIOCGAUDIO, &priv->audio[i]) == -1)
+	{
+	    mp_msg(MSGT_TV, MSGL_ERR, "ioctl get audio failed: %s\n", strerror(errno));
+	    break;
+	}
+	    
+	switch(priv->audio[i].mode)
+	{
+	case VIDEO_SOUND_MONO:
+	case VIDEO_SOUND_LANG1:
+	case VIDEO_SOUND_LANG2:
+	    priv->audio_channels[i] = 1;
+	    break;
+	case VIDEO_SOUND_STEREO:
+	    priv->audio_channels[i] = 2;
+	    break;
+	default:
+	    mp_msg(MSGT_TV, MSGL_ERR, "Card reports an unknown audio mode !\n");
+	    mp_msg(MSGT_TV, MSGL_ERR, "Trying two channel audio. Use forcechan to override.\n");
+	    priv->audio_channels[i] = 2;
+	    break;
+	}
+
+	if (reqmode >= 0 && priv->audio[i].mode != reqmode) {
+	    mp_msg(MSGT_TV, MSGL_ERR, "Audio mode setup warning!\n");
+	    mp_msg(MSGT_TV, MSGL_ERR, "Requested mode was %s, but v4l still reports %s.\n",
+		   audio_mode2name(reqmode), audio_mode2name(priv->audio[i].mode));
+	    mp_msg(MSGT_TV, MSGL_ERR, "You may need \"forcechan\" option to force stereo/mono audio recording.\n");
+	}
+
+	/* display stuff */
+	mp_msg(MSGT_TV, MSGL_V, "  %d: %s: ", priv->audio[i].audio,
+	       priv->audio[i].name);
+	if (priv->audio[i].flags & VIDEO_AUDIO_MUTABLE) {
+	    mp_msg(MSGT_TV, MSGL_V, "muted=%s ",
+		   (priv->audio[i].flags & VIDEO_AUDIO_MUTE) ? "yes" : "no");
+	}
+	mp_msg(MSGT_TV, MSGL_V, "vol=%d bass=%d treble=%d balance=%d mode=%s",
+	       priv->audio[i].volume, priv->audio[i].bass, priv->audio[i].treble,
+	       priv->audio[i].balance, audio_mode2name(priv->audio[i].mode));
+	mp_msg(MSGT_TV, MSGL_V, " chan=%d\n", priv->audio_channels[i]);
+
+	if (tv_param_forcechan >= 0)
+	    priv->audio_channels[i] = tv_param_forcechan;
+
+	// we'll call VIDIOCSAUDIO again when starting capture
+	// let's set audio mode to requested mode again for the case
+	// when VIDIOCGAUDIO just cannot report the mode correctly
+	if (reqmode >= 0) priv->audio[i].mode = reqmode;
+    }
+}
+
+#if !defined(__LINUX_VIDEODEV2_H) && !defined(VIDIOC_QUERYCAP)
+struct v4l2_capability
+{
+        __u8    driver[16];     /* i.e. "bttv" */
+        __u8    card[32];       /* i.e. "Hauppauge WinTV" */
+        __u8    bus_info[32];   /* "PCI:" + pci_dev->slot_name */
+        __u32   version;        /* should use KERNEL_VERSION() */
+        __u32   capabilities;   /* Device capabilities */
+        __u32   reserved[4];
+};
+
+#define VIDIOC_QUERYCAP         _IOR  ('V',  0, struct v4l2_capability)
+#endif
+
+static int init(priv_t *priv)
+{
+    int i;
+
+    if (tv_param_immediate == 1)
+	tv_param_noaudio = 1;
+    
+    priv->video_ringbuffer = NULL;
+    priv->video_timebuffer = NULL;
+    priv->video_avg_buffer = NULL;
+    priv->audio_ringbuffer = NULL;
+    priv->audio_skew_buffer = NULL;
+
+    priv->video_fd = open(priv->video_device, O_RDWR);
+    mp_msg(MSGT_TV, MSGL_DBG2, "Video fd: %d, %x\n", priv->video_fd,
+	priv->video_device);
+    if (priv->video_fd == -1)
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "unable to open '%s': %s\n",
+	    priv->video_device, strerror(errno));
+	goto err;
+    }
+    
+    /* check for v4l2 */
+    if (ioctl(priv->video_fd, VIDIOC_QUERYCAP, &priv->capability) == 0) {
+	mp_msg(MSGT_TV, MSGL_ERR, "=================================================================\n");
+	mp_msg(MSGT_TV, MSGL_ERR, " WARNING: YOU ARE USING V4L DEMUXER WITH V4L2 DRIVERS!!!\n");
+	mp_msg(MSGT_TV, MSGL_ERR, " As the V4L1 compatibility layer is broken, this may not work.\n");
+	mp_msg(MSGT_TV, MSGL_ERR, " If you encounter any problems, use driver=v4l2 instead.\n");
+	mp_msg(MSGT_TV, MSGL_ERR, " Bugreports on driver=v4l with v4l2 drivers will be ignored.\n");
+	mp_msg(MSGT_TV, MSGL_ERR, "=================================================================\n");
+    }
+    
+    /* get capabilities (priv->capability is needed!) */
+    if (ioctl(priv->video_fd, VIDIOCGCAP, &priv->capability) == -1)
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "ioctl get capabilites failed: %s\n", strerror(errno));
+	goto err;
+    }
+
+    fcntl(priv->video_fd, F_SETFD, FD_CLOEXEC);
+
+    mp_msg(MSGT_TV, MSGL_INFO, "Selected device: %s\n", priv->capability.name);
+    mp_msg(MSGT_TV, MSGL_INFO, " Capabilites: ");
+    for (i = 0; device_cap2name[i] != NULL; i++)
+	if (priv->capability.type & (1 << i))
+	    mp_msg(MSGT_TV, MSGL_INFO, "%s ", device_cap2name[i]);
+    mp_msg(MSGT_TV, MSGL_INFO, "\n");
+    mp_msg(MSGT_TV, MSGL_INFO, " Device type: %d\n", priv->capability.type);
+    mp_msg(MSGT_TV, MSGL_INFO, " Supported sizes: %dx%d => %dx%d\n",
+	priv->capability.minwidth, priv->capability.minheight,
+	priv->capability.maxwidth, priv->capability.maxheight);
+    priv->width = priv->capability.minwidth;
+    priv->height = priv->capability.minheight;
+
+    /* somewhere here could disable tv_param_mjpeg, if it is not a capability */
+
+    /* initialize if necessary */
+    if ( tv_param_mjpeg )
+      {
+        struct mjpeg_params bparm;
+        struct mjpeg_requestbuffers breq;          /* buffer requests */
+
+        if (ioctl(priv->video_fd, MJPIOC_G_PARAMS, &bparm) < 0)
+        {
+           mp_msg(MSGT_TV, MSGL_ERR, 
+              "  MJP: Error getting video parameters: %s\n", strerror(errno));
+           goto err;
+        }
+
+        mp_msg(MSGT_TV, MSGL_INFO, 
+	       "  MJP: previous params: x: %d, y: %d, w: %d, h: %d, decim: %d, fields: %d,\n",
+	           bparm.img_x, bparm.img_y, bparm.img_width, bparm.img_height,          
+		   bparm.decimation, bparm.field_per_buff);
+
+        mp_msg(MSGT_TV, MSGL_INFO, 
+	       "  MJP: HorDcm: %d, VerDcm: %d, TmpDcm: %d\n",
+	           bparm.HorDcm, bparm.VerDcm, bparm.TmpDcm);
+
+        bparm.input = tv_param_input; /* tv */
+        if (!strcasecmp(tv_param_norm, "pal"))
+	  bparm.norm =  0; /* PAL */
+        else if (!strcasecmp(tv_param_norm, "ntsc"))
+	  bparm.norm =  1; /* NTSC */
+        else if (!strcasecmp(tv_param_norm, "secam"))
+	  bparm.norm =  2; /* SECAM */
+        bparm.quality = tv_param_quality;
+        bparm.decimation = tv_param_decimation;
+
+        mp_msg(MSGT_TV, MSGL_INFO, "  MJP: setting params to decimation: %d, quality: %d\n", 
+	                                 bparm.decimation, bparm.quality);
+
+        if (ioctl(priv->video_fd, MJPIOC_S_PARAMS, &bparm) < 0)
+         {
+            mp_msg(MSGT_TV, MSGL_ERR,
+               "  MJP: Error setting video parameters: %s\n", strerror(errno));
+            goto err;
+         }
+
+        if (ioctl(priv->video_fd, MJPIOC_G_PARAMS, &bparm) < 0)
+        {
+           mp_msg(MSGT_TV, MSGL_ERR, 
+              "  MJP: Error getting video parameters: %s\n", strerror(errno));
+           goto err;
+        }
+
+        mp_msg(MSGT_TV, MSGL_INFO, 
+	       "  MJP: current params: x: %d, y: %d, w: %d, h: %d, decim: %d, fields: %d,\n",
+	           bparm.img_x, bparm.img_y, bparm.img_width, bparm.img_height,          
+		   bparm.decimation, bparm.field_per_buff);
+
+        mp_msg(MSGT_TV, MSGL_INFO, 
+	       "  MJP: HorDcm: %d, VerDcm: %d, TmpDcm: %d\n",
+	           bparm.HorDcm, bparm.VerDcm, bparm.TmpDcm);
+
+
+        breq.count = 64;
+	priv -> nbuf = breq.count;
+        priv->mbuf.frames = priv -> nbuf;
+        priv->mjpeg_bufsize = 256*1024;
+        if (tv_param_buffer_size >= 0) {
+          priv->mjpeg_bufsize = tv_param_buffer_size*1024;
+	  }
+        breq.size  = priv -> mjpeg_bufsize;
+        if (ioctl(priv->video_fd, MJPIOC_REQBUFS,&(breq)) < 0)
+        {
+           mp_msg (MSGT_TV, MSGL_ERR,
+              "  MJP: Error requesting video buffers: %s\n", strerror(errno));
+           goto err;
+        }
+        mp_msg(MSGT_TV, MSGL_INFO,
+           "  MJP: Got %ld buffers of size %ld KB\n", 
+                    breq.count, breq.size/1024);
+
+        priv -> mmap = mmap(0, breq.count * breq.size, 
+           PROT_READ|PROT_WRITE, MAP_SHARED, priv->video_fd, 0);
+        if (priv -> mmap == MAP_FAILED)
+        {
+           mp_msg(MSGT_TV, MSGL_INFO,
+              "  MJP: Error mapping video buffers: %s\n", strerror(errno));
+           goto err;
+        }
+      }
+
+    mp_msg(MSGT_TV, MSGL_INFO, " Inputs: %d\n", priv->capability.channels);
+    priv->channels = (struct video_channel *)malloc(sizeof(struct video_channel)*priv->capability.channels);
+    if (!priv->channels)
+	goto malloc_failed;
+    memset(priv->channels, 0, sizeof(struct video_channel)*priv->capability.channels);
+    for (i = 0; i < priv->capability.channels; i++)
+    {
+	priv->channels[i].channel = i;
+	if (ioctl(priv->video_fd, VIDIOCGCHAN, &priv->channels[i]) == -1)
+	{
+	    mp_msg(MSGT_TV, MSGL_ERR, "ioctl get channel failed: %s\n", strerror(errno));
+	    break;
+	}
+	mp_msg(MSGT_TV, MSGL_INFO, "  %d: %s: %s%s%s%s (tuner:%d, norm:%s)\n", i,
+	    priv->channels[i].name,
+	    (priv->channels[i].flags & VIDEO_VC_TUNER) ? "tuner " : "",
+	    (priv->channels[i].flags & VIDEO_VC_AUDIO) ? "audio " : "",
+	    (priv->channels[i].flags & VIDEO_TYPE_TV) ? "tv " : "",
+	    (priv->channels[i].flags & VIDEO_TYPE_CAMERA) ? "camera " : "",
+	    priv->channels[i].tuners,
+	    norm2name(priv->channels[i].norm));
+    }
+    priv->act_channel = 0;
+
+    if (!(priv->capability.type & VID_TYPE_CAPTURE))
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "Only grabbing supported (for overlay use another program)\n");
+	goto err;
+    }
+    
+    if ( !tv_param_mjpeg )
+    {
+    /* map grab buffer */
+    if (ioctl(priv->video_fd, VIDIOCGMBUF, &priv->mbuf) == -1)
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "ioctl get mbuf failed: %s\n", strerror(errno));
+	goto err;
+    }
+
+    mp_msg(MSGT_TV, MSGL_V, "mbuf: size=%d, frames=%d\n",
+	priv->mbuf.size, priv->mbuf.frames);
+    priv->mmap = mmap(0, priv->mbuf.size, PROT_READ|PROT_WRITE,
+		MAP_SHARED, priv->video_fd, 0);
+    if (priv->mmap == (unsigned char *)-1)
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "Unable to map memory for buffers: %s\n", strerror(errno));
+	goto err;
+    }
+    mp_msg(MSGT_TV, MSGL_DBG2, "our buffer: %p\n", priv->mmap);
+
+    /* num of buffers */
+    priv->nbuf = priv->mbuf.frames;
+    
+    /* video buffers */
+    priv->buf = (struct video_mmap *)malloc(priv->nbuf * sizeof(struct video_mmap));
+    if (!priv->buf)
+	goto malloc_failed;
+    memset(priv->buf, 0, priv->nbuf * sizeof(struct video_mmap));
+    }
+    
+    /* init v4l audio even when we don't capture */
+    init_v4l_audio(priv);
+
+    if (!priv->capability.audios && !tv_param_force_audio) tv_param_noaudio = 1;
+
+    /* audio init */
+    if (!tv_param_noaudio) {
+	
+#if defined(HAVE_ALSA9) || defined(HAVE_ALSA1X)
+	if (tv_param_alsa)
+	    audio_in_init(&priv->audio_in, AUDIO_IN_ALSA);
+	else
+	    audio_in_init(&priv->audio_in, AUDIO_IN_OSS);
+#else
+	audio_in_init(&priv->audio_in, AUDIO_IN_OSS);
+#endif
+
+	if (priv->audio_device) {
+	    audio_in_set_device(&priv->audio_in, priv->audio_device);
+	}
+
+	if (tv_param_audio_id < priv->capability.audios)
+	    priv->audio_id = tv_param_audio_id;
+	else
+	    priv->audio_id = 0;
+	audio_in_set_samplerate(&priv->audio_in, 44100);
+	if (priv->capability.audios) {
+	    audio_in_set_channels(&priv->audio_in, priv->audio_channels[priv->audio_id]);
+	} else {
+	    if (tv_param_forcechan >= 0) {
+		audio_in_set_channels(&priv->audio_in, tv_param_forcechan);
+	    } else {
+		audio_in_set_channels(&priv->audio_in, 2);
+	    }
+	}
+	if (audio_in_setup(&priv->audio_in) < 0) return 0;
+	setup_audio_buffer_sizes(priv);
+    }
+
+    return(1);
+
+malloc_failed:
+    if (priv->channels)
+	free(priv->channels);
+    if (priv->buf)
+	free(priv->buf);
+err:
+    if (priv->video_fd != -1)
+	close(priv->video_fd);
+    return(0);
+}
+
+static int uninit(priv_t *priv)
+{
+    unsigned long num;
+    priv->shutdown = 1;
+
+    mp_msg(MSGT_TV, MSGL_V, "Waiting for threads to finish... ");
+    if (!tv_param_noaudio) {
+	pthread_join(priv->audio_grabber_thread, NULL);
+	pthread_mutex_destroy(&priv->audio_starter);
+	pthread_mutex_destroy(&priv->skew_mutex);
+    }
+    pthread_mutex_destroy(&priv->video_buffer_mutex);
+    pthread_join(priv->video_grabber_thread, NULL);
+    mp_msg(MSGT_TV, MSGL_V, "done\n");
+
+    if (priv->capability.audios) {
+	priv->audio[priv->audio_id].flags |= VIDEO_AUDIO_MUTE;
+	ioctl(priv->video_fd, VIDIOCSAUDIO, &priv->audio[priv->audio_id]);
+    }
+    
+    if ( tv_param_mjpeg )
+      {
+	num = -1;
+        if (ioctl(priv->video_fd, MJPIOC_QBUF_CAPT, &num) < 0)
+          {
+            mp_msg(MSGT_TV, MSGL_ERR, "\n  MJP: ioctl MJPIOC_QBUF_CAPT failed: %s\n", strerror(errno));
+          }
+      }
+    else
+      {
+	// We need to munmap as close don't close mem mappings
+	if(munmap(priv->mmap,priv->mbuf.size))
+	  mp_msg(MSGT_TV, MSGL_ERR, "Munmap failed: %s\n",strerror(errno));
+      }
+
+    if(close(priv->video_fd))
+      mp_msg(MSGT_TV, MSGL_ERR, "Close tv failed: %s\n",strerror(errno));
+
+    audio_in_uninit(&priv->audio_in);
+
+    if (priv->video_ringbuffer) {
+	int i;
+	for (i = 0; i < priv->video_buffer_size_current; i++) {
+	    free(priv->video_ringbuffer[i]);
+	}
+	free(priv->video_ringbuffer);
+    }
+    
+    if (priv->video_timebuffer)
+	free(priv->video_timebuffer);
+    if (priv->video_avg_buffer)
+	free(priv->video_avg_buffer);
+    if (!tv_param_noaudio) {
+	if (priv->audio_ringbuffer)
+	    free(priv->audio_ringbuffer);
+	if (priv->audio_skew_buffer)
+	    free(priv->audio_skew_buffer);
+    }
+
+    return(1);
+}
+
+static int get_capture_buffer_size(priv_t *priv)
+{
+    int bufsize, cnt;
+
+    if (tv_param_buffer_size >= 0) {
+	bufsize = tv_param_buffer_size*1024*1024;
+    } else {
+#ifdef HAVE_SYS_SYSINFO_H
+	struct sysinfo si;
+	
+	sysinfo(&si);
+	if (si.totalram<2*1024*1024) {
+	    bufsize = 1024*1024;
+	} else {
+	    bufsize = si.totalram/2;
+	}
+#else
+	bufsize = 16*1024*1024;
+#endif
+    }
+    
+    cnt = bufsize/(priv->height*priv->bytesperline);
+    if (cnt < 2) cnt = 2;
+    
+    return cnt;
+}
+
+static int start(priv_t *priv)
+{
+    int i;
+    int bytes_per_sample;
+    
+    if (ioctl(priv->video_fd, VIDIOCGPICT, &priv->picture) == -1)
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "ioctl get picture failed: %s\n", strerror(errno));
+	return(0);
+    }
+
+    priv->picture.palette = format2palette(priv->format);
+    priv->picture.depth = palette2depth(priv->picture.palette);
+
+    if (priv->format != IMGFMT_BGR15) {
+	priv->bytesperline = priv->width * priv->picture.depth / 8;
+    } else {
+	priv->bytesperline = priv->width * 2;
+    }
+
+    mp_msg(MSGT_TV, MSGL_V, "Picture values:\n");
+    mp_msg(MSGT_TV, MSGL_V, " Depth: %d, Palette: %s (Format: %s)\n", priv->picture.depth,
+	PALETTE(priv->picture.palette), vo_format_name(priv->format));
+    mp_msg(MSGT_TV, MSGL_V, " Brightness: %d, Hue: %d, Colour: %d, Contrast: %d\n",
+	priv->picture.brightness, priv->picture.hue,
+	priv->picture.colour, priv->picture.contrast);
+    
+
+    if (ioctl(priv->video_fd, VIDIOCSPICT, &priv->picture) == -1)
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "ioctl set picture failed: %s\n", strerror(errno));
+	return(0);
+    }
+
+    if ( !tv_param_mjpeg )
+    {
+    priv->nbuf = priv->mbuf.frames;
+    for (i=0; i < priv->nbuf; i++)
+    {
+	priv->buf[i].format = priv->picture.palette;
+	priv->buf[i].frame = i;
+	priv->buf[i].width = priv->width;
+	priv->buf[i].height = priv->height;
+	mp_msg(MSGT_TV, MSGL_DBG2, "buffer: %d => %p\n", i, &priv->buf[i]);
+    } 
+    } 
+
+#if 0
+    {
+	struct video_play_mode pmode;
+	
+	pmode.mode = VID_PLAY_NORMAL;
+	pmode.p1 = 1;
+	pmode.p2 = 0;
+	if (ioctl(priv->video_fd, VIDIOCSPLAYMODE, &pmode) == -1)
+	{
+	    mp_msg(MSGT_TV, MSGL_ERR, "ioctl set play mode failed: %s\n", strerror(errno));
+//	    return(0);
+	}
+    }
+#endif
+
+#if 0
+    {
+	struct video_window win;
+
+	win.x = 0;
+	win.y = 0;
+	win.width = priv->width;
+	win.height = priv->height;
+	win.chromakey = -1;
+	win.flags = 0;
+	//win.clipcount = 0;
+	
+	ioctl(priv->video_fd, VIDIOCSWIN, &win);
+    }
+
+    // initialize video capture
+    if (ioctl(priv->video_fd, VIDIOCCAPTURE, &one) == -1)
+    {
+	mp_msg(MSGT_TV, MSGL_ERR, "FATAL: ioctl ccapture failed: %s\n", strerror(errno));
+	return(0);
+    }
+#endif
+
+    /* setup audio parameters */
+    if (!tv_param_noaudio) {
+	setup_audio_buffer_sizes(priv);
+	bytes_per_sample = priv->audio_in.bytes_per_sample;
+	priv->audio_skew_buffer = (long long*)malloc(sizeof(long long)*priv->aud_skew_cnt);
+	if (!priv->audio_skew_buffer) {
+	    mp_msg(MSGT_TV, MSGL_ERR, "cannot allocate skew buffer: %s\n", strerror(errno));
+	    return 0;
+	}
+
+	priv->audio_ringbuffer = (unsigned char*)malloc(priv->audio_in.blocksize*priv->audio_buffer_size);
+	if (!priv->audio_ringbuffer) {
+	    mp_msg(MSGT_TV, MSGL_ERR, "cannot allocate audio buffer: %s\n", strerror(errno));
+	    return 0;
+	}
+
+	priv->audio_secs_per_block = (double)priv->audio_in.blocksize/(priv->audio_in.samplerate
+								    *priv->audio_in.channels
+								    *bytes_per_sample);
+	priv->audio_head = 0;
+	priv->audio_tail = 0;
+	priv->audio_cnt = 0;
+	priv->audio_drop = 0;
+	priv->audio_skew = 0;
+	priv->audio_skew_total = 0;
+	priv->audio_recv_blocks_total = 0;
+	priv->audio_sent_blocks_total = 0;
+    }
+
+    /* setup video parameters */
+    if (priv->immediate_mode) {
+	priv->video_buffer_size_max = VID_BUF_SIZE_IMMEDIATE;
+    } else {
+	priv->video_buffer_size_max = get_capture_buffer_size(priv);
+    }
+    priv->video_buffer_size_current = 0;
+
+    if (!tv_param_noaudio) {
+	if (priv->video_buffer_size_max < 3.0*priv->fps*priv->audio_secs_per_block) {
+	    mp_msg(MSGT_TV, MSGL_ERR, "Video buffer shorter than 3 times audio frame duration.\n"
+		   "You will probably experience heavy framedrops.\n");
+	}
+    }
+
+    mp_msg(MSGT_TV, MSGL_V, "Using a ring buffer for maximum %d frames, %d MB total size.\n",
+	   priv->video_buffer_size_max,
+	   priv->video_buffer_size_max*priv->height*priv->bytesperline/(1024*1024));
+
+    priv->video_ringbuffer = (unsigned char**)malloc(priv->video_buffer_size_max*sizeof(unsigned char*));
+    if (!priv->video_ringbuffer) {
+	mp_msg(MSGT_TV, MSGL_ERR, "cannot allocate video buffer: %s\n", strerror(errno));
+	return 0;
+    }
+    for (i = 0; i < priv->video_buffer_size_max; i++)
+	priv->video_ringbuffer[i] = NULL;
+    
+    priv->video_timebuffer = (long long*)malloc(sizeof(long long) * priv->video_buffer_size_max);
+    if (!priv->video_timebuffer) {
+	mp_msg(MSGT_TV, MSGL_ERR, "cannot allocate time buffer: %s\n", strerror(errno));
+	return 0;
+    }
+    priv->video_avg_buffer = (long long*)malloc(sizeof(long long) * VIDEO_AVG_BUFFER_SIZE);
+    if (!priv->video_avg_buffer) {
+	mp_msg(MSGT_TV, MSGL_ERR, "cannot allocate period buffer: %s\n", strerror(errno));
+	return 0;
+    }
+    priv->video_interval_sum = (1e6/priv->fps)*VIDEO_AVG_BUFFER_SIZE;
+    for (i = 0; i < VIDEO_AVG_BUFFER_SIZE; i++) {
+	priv->video_avg_buffer[i] = 1e6/priv->fps;
+    }
+
+    priv->video_avg_ptr = 0;
+    
+    priv->video_head = 0;
+    priv->video_tail = 0;
+    priv->video_cnt = 0;
+    priv->first = 1;
+
+    if (priv->capability.audios) {
+	/* enable audio */
+	if (tv_param_volume >= 0)
+	    priv->audio[priv->audio_id].volume = tv_param_volume;
+	if (tv_param_bass >= 0)
+	    priv->audio[priv->audio_id].bass = tv_param_bass;
+	if (tv_param_treble >= 0)
+	    priv->audio[priv->audio_id].treble = tv_param_treble;
+	if (tv_param_balance >= 0)
+	    priv->audio[priv->audio_id].balance = tv_param_balance;
+	priv->audio[priv->audio_id].flags &= ~VIDEO_AUDIO_MUTE;
+	mp_msg(MSGT_TV, MSGL_V, "Enabling tv audio. Requested setup is:\n");
+	mp_msg(MSGT_TV, MSGL_V, "id=%d vol=%d bass=%d treble=%d balance=%d mode=%s",
+	       priv->audio_id,
+	       priv->audio[priv->audio_id].volume, priv->audio[priv->audio_id].bass, priv->audio[priv->audio_id].treble,
+	       priv->audio[priv->audio_id].balance, audio_mode2name(priv->audio[priv->audio_id].mode));
+	mp_msg(MSGT_TV, MSGL_V, " chan=%d\n", priv->audio_channels[priv->audio_id]);
+	ioctl(priv->video_fd, VIDIOCSAUDIO, &priv->audio[priv->audio_id]);
+    }
+    
+    /* launch capture threads */
+    priv->shutdown = 0;
+    if (!tv_param_noaudio) {
+	pthread_mutex_init(&priv->audio_starter, NULL);
+	pthread_mutex_init(&priv->skew_mutex, NULL);
+	pthread_mutex_lock(&priv->audio_starter);
+	pthread_create(&priv->audio_grabber_thread, NULL, audio_grabber, priv);
+    }
+    pthread_mutex_init(&priv->video_buffer_mutex, NULL);
+    /* we'll launch the video capture later, when a first request for a frame arrives */
+
+    return(1);
+}
+
+// 2nd order polynomial with p(-100)=0, p(100)=65535, p(0)=y0
+static int poly(int x, int y0)
+{
+    return ((65535-2*y0)*x*x+6553500*x+20000*y0)/20000;
+}
+
+static int control(priv_t *priv, int cmd, void *arg)
+{
+    mp_msg(MSGT_TV, MSGL_DBG2, "\ndebug: control(priv=%p, cmd=%d, arg=%p)\n",
+	priv, cmd, arg);
+    switch(cmd)
+    {
+	/* ========== GENERIC controls =========== */
+	case TVI_CONTROL_IS_VIDEO:
+	{
+	    if (priv->capability.type & VID_TYPE_CAPTURE)
+		return(TVI_CONTROL_TRUE);
+	    return(TVI_CONTROL_FALSE);
+	}
+	case TVI_CONTROL_IS_AUDIO:
+	    if (tv_param_force_audio) return(TVI_CONTROL_TRUE);
+	    if (priv->channels[priv->act_channel].flags & VIDEO_VC_AUDIO)
+	    {
+		return(TVI_CONTROL_TRUE);
+	    }
+	    return(TVI_CONTROL_FALSE);
+	case TVI_CONTROL_IS_TUNER:
+	{
+//	    if (priv->capability.type & VID_TYPE_TUNER)
+	    if (priv->channels[priv->act_channel].flags & VIDEO_VC_TUNER)
+		return(TVI_CONTROL_TRUE);
+	    return(TVI_CONTROL_FALSE);
+	}
+
+	/* ========== VIDEO controls =========== */
+	case TVI_CONTROL_VID_GET_FORMAT:
+	{
+	    int output_fmt = -1;
+
+	    output_fmt = priv->format;
+            if ( tv_param_mjpeg )
+	    {
+              mp_msg(MSGT_TV, MSGL_INFO, "  MJP: setting sh_video->format to mjpg\n");
+	      output_fmt = 0x47504a4d;
+	      output_fmt = 0x67706a6d;
+	      *(int *)arg = output_fmt;
+	      mp_msg(MSGT_TV, MSGL_V, "Output format: %s\n", "mjpg");
+	    }
+	    else
+	    {
+	    *(int *)arg = output_fmt;
+	    mp_msg(MSGT_TV, MSGL_V, "Output format: %s\n", vo_format_name(output_fmt));
+	    }
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_VID_SET_FORMAT:
+	    priv->format = *(int *)arg;
+	    // !HACK! v4l uses BGR format instead of RGB
+	    // and we have to correct this. Fortunately,
+	    // tv.c reads later the format back so we
+	    // can persuade it to use what we want.
+	    if (IMGFMT_IS_RGB(priv->format)) {
+		priv->format &= ~IMGFMT_RGB_MASK;
+		priv->format |= IMGFMT_BGR;
+	    }
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_GET_PLANES:
+	    *(int *)arg = 1; /* FIXME, also not needed at this time */
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_GET_BITS:
+	    *(int *)arg = palette2depth(format2palette(priv->format));
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_GET_WIDTH:
+	    *(int *)arg = priv->width;
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_CHK_WIDTH:
+	{
+	    int req_width = *(int *)arg;
+	    
+	    mp_msg(MSGT_TV, MSGL_V, "Requested width: %d\n", req_width);
+	    if ((req_width >= priv->capability.minwidth) &&
+		(req_width <= priv->capability.maxwidth))
+		return(TVI_CONTROL_TRUE);
+	    return(TVI_CONTROL_FALSE);
+	}
+	case TVI_CONTROL_VID_SET_WIDTH:
+	    priv->width = *(int *)arg;
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_GET_HEIGHT:
+	    *(int *)arg = priv->height;
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_CHK_HEIGHT:
+	{
+	    int req_height = *(int *)arg;
+	    
+	    mp_msg(MSGT_TV, MSGL_V, "Requested height: %d\n", req_height);
+	    if ((req_height >= priv->capability.minheight) &&
+		(req_height <= priv->capability.maxheight))
+		return(TVI_CONTROL_TRUE);
+	    return(TVI_CONTROL_FALSE);
+	}
+	case TVI_CONTROL_VID_SET_HEIGHT:
+	    priv->height = *(int *)arg;
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_GET_PICTURE:
+	    if (ioctl(priv->video_fd, VIDIOCGPICT, &priv->picture) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl get picture failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_SET_PICTURE:
+	    if (ioctl(priv->video_fd, VIDIOCSPICT, &priv->picture) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl get picture failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_SET_BRIGHTNESS:
+	    priv->picture.brightness = 65535*(*(int *)arg+100)/200;
+	    control(priv, TVI_CONTROL_VID_SET_PICTURE, 0);
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_SET_HUE:
+	    priv->picture.hue = 65535*(*(int *)arg+100)/200;
+	    control(priv, TVI_CONTROL_VID_SET_PICTURE, 0);
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_SET_SATURATION:
+	    priv->picture.colour = 65535*(*(int *)arg+100)/200;
+	    control(priv, TVI_CONTROL_VID_SET_PICTURE, 0);
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_SET_CONTRAST:
+	    priv->picture.contrast = poly(*(int *)arg, 24576);
+	    control(priv, TVI_CONTROL_VID_SET_PICTURE, 0);
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_VID_GET_FPS:
+	    *(float *)arg=priv->fps;
+	    return(TVI_CONTROL_TRUE);
+
+	/* ========== TUNER controls =========== */
+	case TVI_CONTROL_TUN_GET_FREQ:
+	{
+	    unsigned long freq;
+	    
+	    if (ioctl(priv->video_fd, VIDIOCGFREQ, &freq) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl get freq failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    
+	    /* tuner uses khz not mhz ! */
+//	    if (priv->tuner.flags & VIDEO_TUNER_LOW)
+//	        freq /= 1000;
+	    *(unsigned long *)arg = freq;
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_TUN_SET_FREQ:
+	{
+	    /* argument is in MHz ! */
+	    unsigned long freq = *(unsigned long *)arg;
+	    
+	    if (priv->capability.audios) {
+		priv->audio[priv->audio_id].flags |= VIDEO_AUDIO_MUTE;
+		ioctl(priv->video_fd, VIDIOCSAUDIO, &priv->audio[priv->audio_id]);
+	    }
+
+	    mp_msg(MSGT_TV, MSGL_V, "requested frequency: %.3f\n", (float)freq/16);
+	    
+	    /* tuner uses khz not mhz ! */
+//	    if (priv->tuner.flags & VIDEO_TUNER_LOW)
+//	        freq *= 1000;
+//	    mp_msg(MSGT_TV, MSGL_V, " requesting from driver: freq=%.3f\n", (float)freq/16);
+	    if (ioctl(priv->video_fd, VIDIOCSFREQ, &freq) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl set freq failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    usleep(100000); // wait to supress noise during switching
+
+	    if (priv->capability.audios) {
+		priv->audio[priv->audio_id].flags &= ~VIDEO_AUDIO_MUTE;
+		ioctl(priv->video_fd, VIDIOCSAUDIO, &priv->audio[priv->audio_id]);
+	    }
+
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_TUN_GET_TUNER:
+	{
+	    if (ioctl(priv->video_fd, VIDIOCGTUNER, &priv->tuner) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl get tuner failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    
+	    mp_msg(MSGT_TV, MSGL_V, "Tuner (%s) range: %lu -> %lu\n", priv->tuner.name,
+		priv->tuner.rangelow, priv->tuner.rangehigh);
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_TUN_SET_TUNER:
+	{
+	    if (ioctl(priv->video_fd, VIDIOCSTUNER, &priv->tuner) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl set tuner failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_TUN_SET_NORM:
+	{
+	    int req_mode = *(int *)arg;
+
+	    if ((req_mode != TV_NORM_PAL) && (req_mode != TV_NORM_NTSC) && (req_mode != TV_NORM_SECAM)
+		&& (req_mode != TV_NORM_PALNC) && (req_mode != TV_NORM_PALM) && (req_mode != TV_NORM_PALN)
+		&& (req_mode != TV_NORM_NTSCJP)) {
+		mp_msg(MSGT_TV, MSGL_ERR, "Unknown norm!\n");
+		return(TVI_CONTROL_FALSE);
+	    }
+
+	    if (priv->channels[priv->act_channel].flags & VIDEO_VC_TUNER) {
+		int prev_mode;
+		
+		control(priv, TVI_CONTROL_TUN_GET_TUNER, 0);
+		if (((req_mode == TV_NORM_PAL
+		      || req_mode == TV_NORM_PALNC
+		      || req_mode == TV_NORM_PALN) && !(priv->tuner.flags & VIDEO_TUNER_PAL)) ||
+		    ((req_mode == TV_NORM_NTSC
+		      || req_mode == TV_NORM_NTSCJP
+		      || req_mode == TV_NORM_PALM) && !(priv->tuner.flags & VIDEO_TUNER_NTSC)) ||
+		    ((req_mode == TV_NORM_SECAM) && !(priv->tuner.flags & VIDEO_TUNER_SECAM)))
+		{
+		    mp_msg(MSGT_TV, MSGL_ERR, "Tuner isn't capable to set norm!\n");
+		    return(TVI_CONTROL_FALSE);
+		}
+
+		prev_mode = priv->tuner.mode;
+
+		switch(req_mode) {
+		case TV_NORM_PAL:
+		case TV_NORM_PALNC:
+		case TV_NORM_PALN:
+		    priv->tuner.mode = VIDEO_MODE_PAL;
+		    break;
+		case TV_NORM_NTSC:
+		case TV_NORM_NTSCJP:
+		case TV_NORM_PALM:
+		    priv->tuner.mode = VIDEO_MODE_NTSC;
+		    break;
+		case TV_NORM_SECAM:
+		    priv->tuner.mode = VIDEO_MODE_SECAM;
+		    break;
+		}
+	    
+		if (control(priv, TVI_CONTROL_TUN_SET_TUNER, &priv->tuner) != TVI_CONTROL_TRUE) {
+		    // norm setting failed, but maybe it's only because it's fixed
+		    if (priv->tuner.mode != prev_mode) return(TVI_CONTROL_FALSE); // no it really failed
+		}
+
+	    }
+
+	    switch(req_mode) {
+	    case TV_NORM_PAL:
+		priv->channels[priv->act_channel].norm = VIDEO_MODE_PAL;
+		break;
+	    case TV_NORM_NTSC:
+		priv->channels[priv->act_channel].norm = VIDEO_MODE_NTSC;
+		break;
+	    case TV_NORM_SECAM:
+		priv->channels[priv->act_channel].norm = VIDEO_MODE_SECAM;
+		break;
+	    case TV_NORM_PALNC:
+		priv->channels[priv->act_channel].norm = 3;
+		break;
+	    case TV_NORM_PALM:
+		priv->channels[priv->act_channel].norm = 4;
+		break;
+	    case TV_NORM_PALN:
+		priv->channels[priv->act_channel].norm = 5;
+		break;
+	    case TV_NORM_NTSCJP:
+		priv->channels[priv->act_channel].norm = 6;
+		break;
+	    }
+	    if (ioctl(priv->video_fd, VIDIOCSCHAN, &priv->channels[priv->act_channel]) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl set chan failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+
+	    if (ioctl(priv->video_fd, VIDIOCGCAP, &priv->capability) == -1) {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl get capabilites failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+
+	    if(req_mode == TV_NORM_PAL || req_mode == TV_NORM_SECAM || req_mode == TV_NORM_PALN || req_mode == TV_NORM_PALNC) {
+		priv->fps = PAL_FPS;
+            }
+
+	    if(req_mode == TV_NORM_NTSC || req_mode == TV_NORM_NTSCJP || req_mode == TV_NORM_PALM) {
+		priv->fps = NTSC_FPS;
+            }
+
+	    if(priv->height > priv->capability.maxheight) {
+		priv->height = priv->capability.maxheight;
+	    }
+
+	    if(priv->width > priv->capability.maxwidth) {
+		priv->width = priv->capability.maxwidth;
+	    }
+	    
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_TUN_GET_NORM:
+	{
+	    *(int *)arg = priv->tuner.mode;
+
+	    return(TVI_CONTROL_TRUE);
+	}
+	
+	/* ========== AUDIO controls =========== */
+	case TVI_CONTROL_AUD_GET_FORMAT:
+	{
+	    *(int *)arg = AFMT_S16_LE;
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_AUD_GET_CHANNELS:
+	{
+	    *(int *)arg = priv->audio_in.channels;
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_AUD_GET_SAMPLERATE:
+	{
+	    *(int *)arg = priv->audio_in.samplerate;
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_AUD_GET_SAMPLESIZE:
+	{
+	    *(int *)arg = priv->audio_in.bytes_per_sample;
+	    return(TVI_CONTROL_TRUE);
+	}
+	case TVI_CONTROL_AUD_SET_SAMPLERATE:
+	{
+	    if (audio_in_set_samplerate(&priv->audio_in, *(int *)arg) < 0) return TVI_CONTROL_FALSE;
+	    setup_audio_buffer_sizes(priv);
+	    return(TVI_CONTROL_TRUE);
+	}
+	/* ========== SPECIFIC controls =========== */
+	case TVI_CONTROL_SPC_GET_INPUT:
+	{
+	    int req_chan = *(int *)arg;
+	    int i;
+
+	    for (i = 0; i < priv->capability.channels; i++)
+	    {
+		if (priv->channels[i].channel == req_chan)
+		    break;
+	    }
+	    
+	    priv->act_channel = i;
+
+	    if (ioctl(priv->video_fd, VIDIOCGCHAN, &priv->channels[i]) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl get channel failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    return(TVI_CONTROL_TRUE);
+	}
+
+	case TVI_CONTROL_SPC_SET_INPUT:
+	{
+	    struct video_channel chan;
+	    int req_chan = *(int *)arg;
+	    int i;
+	    
+	    if (req_chan >= priv->capability.channels)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "Invalid input requested: %d, valid: 0-%d\n",
+		    req_chan, priv->capability.channels - 1);
+		return(TVI_CONTROL_FALSE);
+	    }
+
+	    for (i = 0; i < priv->capability.channels; i++)
+	    {
+		if (priv->channels[i].channel == req_chan)
+		    chan = priv->channels[i];
+	    }
+
+	    if (ioctl(priv->video_fd, VIDIOCSCHAN, &chan) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "ioctl set chan failed: %s\n", strerror(errno));
+		return(TVI_CONTROL_FALSE);
+	    }
+	    mp_msg(MSGT_TV, MSGL_INFO, "Using input '%s'\n", chan.name);
+
+	    priv->act_channel = i;
+
+	    /* update tuner state */
+//	    if (priv->capability.type & VID_TYPE_TUNER)
+	    if (priv->channels[priv->act_channel].flags & VIDEO_VC_TUNER)
+		control(priv, TVI_CONTROL_TUN_GET_TUNER, 0);
+
+	    /* update local channel list */	
+	    control(priv, TVI_CONTROL_SPC_GET_INPUT, &req_chan);
+	    return(TVI_CONTROL_TRUE);
+	case TVI_CONTROL_IMMEDIATE:
+	    priv->immediate_mode = 1;
+	    return(TVI_CONTROL_TRUE);
+	}
+    }
+
+    return(TVI_CONTROL_UNKNOWN);
+}
+
+// copies a video frame
+// for RGB (i.e. BGR in mplayer) flips the image upside down
+// for YV12 swaps the 2nd and 3rd plane
+static inline void copy_frame(priv_t *priv, unsigned char *dest, unsigned char *source)
+{
+    int i;
+    unsigned char *sptr;
+
+    // YV12 uses VIDEO_PALETTE_YUV420P, but the planes are swapped
+    if (priv->format == IMGFMT_YV12) {
+	memcpy(dest, source, priv->width * priv->height);
+	memcpy(dest+priv->width * priv->height*5/4, source+priv->width * priv->height, priv->width * priv->height/4);
+	memcpy(dest+priv->width * priv->height, source+priv->width * priv->height*5/4, priv->width * priv->height/4);
+	return;
+    }
+
+    switch (priv->picture.palette) {
+    case VIDEO_PALETTE_RGB24:
+    case VIDEO_PALETTE_RGB32:
+    case VIDEO_PALETTE_RGB555:
+    case VIDEO_PALETTE_RGB565:
+	sptr = source + (priv->height-1)*priv->bytesperline;
+	for (i = 0; i < priv->height; i++) {
+	    memcpy(dest, sptr, priv->bytesperline);
+	    dest += priv->bytesperline;
+	    sptr -= priv->bytesperline;
+	}
+	break;
+    case VIDEO_PALETTE_UYVY:
+    case VIDEO_PALETTE_YUV420P:
+    default:
+	memcpy(dest, source, priv->bytesperline * priv->height);
+    }
+    
+}
+
+// maximum skew change, in frames
+#define MAX_SKEW_DELTA 0.6
+static void *video_grabber(void *data)
+{
+#define MAXTOL (priv->nbuf)
+    priv_t *priv = (priv_t*)data;
+    struct timeval curtime;
+    long long skew, prev_skew, xskew, interval, prev_interval;
+    int frame;
+    int i;
+    int framecount;
+    int tolerance;
+    unsigned long num;
+
+    /* start the capture process */
+
+    if ( tv_param_mjpeg )
+      {
+        mp_msg(MSGT_TV, MSGL_INFO, "  MJP: gonna capture ! \n");
+        for (i=0; i < priv->nbuf; i++) {
+	num = i;
+        if (ioctl(priv->video_fd, MJPIOC_QBUF_CAPT, &num) < 0)
+          {
+            mp_msg(MSGT_TV, MSGL_ERR, 
+	           "\n  MJP: ioctl MJPIOC_QBUF_CAPT b failed: %s\n", strerror(errno));
+          }
+	  }
+      }
+    else
+      {
+    for (i=0; i < priv->nbuf; i++) {
+	if (ioctl(priv->video_fd, VIDIOCMCAPTURE, &priv->buf[i]) == -1)
+	{
+	    mp_msg(MSGT_TV, MSGL_ERR, "\nioctl mcapture failed: %s\n", strerror(errno));
+	}
+      }
+    }
+
+    gettimeofday(&curtime, NULL);
+    priv->starttime = (long long)1e6*curtime.tv_sec + curtime.tv_usec;
+    priv->audio_skew_measure_time = 0;
+    pthread_mutex_unlock(&priv->audio_starter);
+    xskew = 0;
+    skew = 0;
+    interval = 0;
+
+    prev_interval = 0;
+    prev_skew = 0;
+
+    tolerance = MAXTOL;
+
+    for (framecount = 0; !priv->shutdown;)
+    {
+	for (i = 0; i < priv->nbuf && !priv->shutdown; i++, framecount++) {
+
+	    if (priv->immediate_mode) {
+		while (priv->video_cnt == priv->video_buffer_size_max) {
+		    usleep(10000);
+                    if (priv->shutdown) {
+                      return NULL;
+                    }
+		}
+	    }
+		
+	    frame = i;
+
+	    if ( tv_param_mjpeg )
+	    {
+	    while (ioctl(priv->video_fd, MJPIOC_SYNC, &priv->buf[frame].frame) < 0 &&
+		   (errno == EAGAIN || errno == EINTR));
+
+	    }
+	    else
+	    {
+	    while (ioctl(priv->video_fd, VIDIOCSYNC, &priv->buf[frame].frame) < 0 &&
+		   (errno == EAGAIN || errno == EINTR));
+	    }
+	    mp_dbg(MSGT_TV, MSGL_DBG3, "\npicture sync failed\n");
+
+	    gettimeofday(&curtime, NULL);
+	    if (!priv->immediate_mode) {
+		interval = (long long)1e6*curtime.tv_sec + curtime.tv_usec - priv->starttime;
+	    } else {
+		interval = (long long)1e6*framecount/priv->fps;
+	    }
+
+	    if (!priv->immediate_mode) {
+		long long period, orig_interval;
+
+		if (tolerance == 0) {
+		    if (interval - prev_interval == 0) {
+			mp_msg(MSGT_TV, MSGL_V, "\nvideo capture thread: frame delta = 0\n");
+		    } else if ((interval - prev_interval < (long long)0.85e6/priv->fps)
+			       || (interval - prev_interval > (long long)1.15e6/priv->fps) ) {
+			mp_msg(MSGT_TV, MSGL_V, "\nvideo capture thread: frame delta ~ %.1lf fps\n",
+			       (double)1e6/(interval - prev_interval));
+		    }
+		}
+
+		// correct the rate fluctuations on a small scale
+		orig_interval = interval;
+		period = priv->video_interval_sum/VIDEO_AVG_BUFFER_SIZE;
+		if (interval - prev_interval > 105*period/100) {
+		    if (tolerance > 0) {
+			mp_msg(MSGT_TV, MSGL_DBG3, "correcting timestamp\n");
+			interval = prev_interval + priv->video_interval_sum/VIDEO_AVG_BUFFER_SIZE;
+			tolerance--;
+		    } else {
+			mp_msg(MSGT_TV, MSGL_DBG3, "bad - frames were dropped\n");
+			tolerance = MAXTOL;
+		    }
+		} else {
+		    if (tolerance < MAXTOL) {
+			mp_msg(MSGT_TV, MSGL_DBG3, "fluctuation overcome\n");
+		    }
+		    tolerance = MAXTOL;
+		}
+		    
+		priv->video_interval_sum -= priv->video_avg_buffer[priv->video_avg_ptr];
+		priv->video_avg_buffer[priv->video_avg_ptr++] = orig_interval-prev_interval;
+		priv->video_interval_sum += orig_interval-prev_interval;
+		if (priv->video_avg_ptr >= VIDEO_AVG_BUFFER_SIZE) priv->video_avg_ptr = 0;
+
+//		fprintf(stderr, "fps: %lf\n", (double)1e6*VIDEO_AVG_BUFFER_SIZE/priv->video_interval_sum);
+		
+		// interpolate the skew in time
+		pthread_mutex_lock(&priv->skew_mutex);
+		xskew = priv->audio_skew + (interval - priv->audio_skew_measure_time)*priv->audio_skew_factor;
+		pthread_mutex_unlock(&priv->skew_mutex);
+		// correct extreme skew changes to avoid (especially) moving backwards in time
+		if (xskew - prev_skew > (interval - prev_interval)*MAX_SKEW_DELTA) {
+		    skew = prev_skew + (interval - prev_interval)*MAX_SKEW_DELTA;
+		} else if (xskew - prev_skew < -(interval - prev_interval)*MAX_SKEW_DELTA) {
+		    skew = prev_skew - (interval - prev_interval)*MAX_SKEW_DELTA;
+		} else {
+		    skew = xskew;
+		}
+	    }
+
+	    mp_msg(MSGT_TV, MSGL_DBG3, "\nfps = %lf, interval = %lf, a_skew = %f, corr_skew = %f\n",
+		   (interval != prev_interval) ? (double)1e6/(interval - prev_interval) : -1,
+		   (double)1e-6*interval, (double)1e-6*xskew, (double)1e-6*skew);
+	    mp_msg(MSGT_TV, MSGL_DBG3, "vcnt = %d, acnt = %d\n", priv->video_cnt, priv->audio_cnt);
+
+	    prev_skew = skew;
+	    prev_interval = interval;
+
+	    /* allocate a new buffer, if needed */
+	    pthread_mutex_lock(&priv->video_buffer_mutex);
+	    if (priv->video_buffer_size_current < priv->video_buffer_size_max) {
+		if (priv->video_cnt == priv->video_buffer_size_current) {
+		    unsigned char *newbuf = (unsigned char*)malloc(priv->bytesperline * priv->height);
+		    if (newbuf) {
+			memmove(priv->video_ringbuffer+priv->video_tail+1, priv->video_ringbuffer+priv->video_tail,
+			       (priv->video_buffer_size_current-priv->video_tail)*sizeof(unsigned char *));
+			memmove(priv->video_timebuffer+priv->video_tail+1, priv->video_timebuffer+priv->video_tail,
+			       (priv->video_buffer_size_current-priv->video_tail)*sizeof(long long));
+			priv->video_ringbuffer[priv->video_tail] = newbuf;
+			if ((priv->video_head >= priv->video_tail) && (priv->video_cnt > 0)) priv->video_head++;
+			priv->video_buffer_size_current++;
+		    }
+		}
+	    }
+	    pthread_mutex_unlock(&priv->video_buffer_mutex);
+
+	    if (priv->video_cnt == priv->video_buffer_size_current) {
+		if (!priv->immediate_mode) {
+		    mp_msg(MSGT_TV, MSGL_ERR, "\nvideo buffer full - dropping frame\n");
+		}
+	    } else {
+		if (priv->immediate_mode) {
+		    priv->video_timebuffer[priv->video_tail] = interval;
+		} else {
+		    // compensate for audio skew
+		    // negative skew => there are more audio samples, increase interval
+		    // positive skew => less samples, shorten the interval
+		    priv->video_timebuffer[priv->video_tail] = interval - skew;
+		}
+		
+                if ( tv_param_mjpeg )
+		copy_frame(priv, priv->video_ringbuffer[priv->video_tail], 
+		           priv->mmap+(priv->mjpeg_bufsize)*i);
+		else
+		copy_frame(priv, priv->video_ringbuffer[priv->video_tail], priv->mmap+priv->mbuf.offsets[frame]);
+		priv->video_tail = (priv->video_tail+1)%priv->video_buffer_size_current;
+		priv->video_cnt++;
+	    }
+
+            if ( tv_param_mjpeg )
+            {
+	      num = frame;
+              if (ioctl(priv->video_fd, MJPIOC_QBUF_CAPT, &num) < 0)
+                {
+                  mp_msg(MSGT_TV, MSGL_ERR, "\n  MJP: ioctl MJPIOC_QBUF_CAPT end failed: %s\n", 
+		                                    strerror(errno));
+		  continue;
+                }
+	    }
+	    else
+	    {
+	    if (ioctl(priv->video_fd, VIDIOCMCAPTURE, &priv->buf[frame]) == -1)
+	    {
+		mp_msg(MSGT_TV, MSGL_ERR, "\nioctl mcapture failed: %s\n", strerror(errno));
+		continue;
+	    }
+	    }
+
+	}
+
+    }
+    mp_msg(MSGT_TV, MSGL_INFO, "  MJP: returning! \n");
+    return NULL;
+}
+
+static double grab_video_frame(priv_t *priv, char *buffer, int len)
+{
+    double interval;
+
+    if (priv->first) {
+	pthread_create(&priv->video_grabber_thread, NULL, video_grabber, priv);
+	priv->first = 0;
+    }
+
+    while (priv->video_cnt == 0) {
+	usleep(10000);
+    }
+
+    pthread_mutex_lock(&priv->video_buffer_mutex);
+    interval = (double)priv->video_timebuffer[priv->video_head]*1e-6;
+    memcpy(buffer, priv->video_ringbuffer[priv->video_head], len);
+    priv->video_cnt--;
+    priv->video_head = (priv->video_head+1)%priv->video_buffer_size_current;
+    pthread_mutex_unlock(&priv->video_buffer_mutex);
+
+    return interval;
+}
+
+static int get_video_framesize(priv_t *priv)
+{
+    return(priv->bytesperline * priv->height);
+}
+
+static void *audio_grabber(void *data)
+{
+    priv_t *priv = (priv_t*)data;
+    struct timeval tv;
+    int i, audio_skew_ptr = 0;
+    long long current_time, prev_skew = 0;
+
+    pthread_mutex_lock(&priv->audio_starter);
+
+    audio_in_start_capture(&priv->audio_in);
+    for (i = 0; i < priv->aud_skew_cnt; i++)
+	priv->audio_skew_buffer[i] = 0;
+
+    for (; !priv->shutdown;)
+    {
+	if (audio_in_read_chunk(&priv->audio_in, priv->audio_ringbuffer+priv->audio_tail*priv->audio_in.blocksize) < 0)
+	    continue;
+
+	gettimeofday(&tv, NULL);
+
+	priv->audio_recv_blocks_total++;
+	current_time = (long long)1e6*tv.tv_sec + tv.tv_usec - priv->starttime;
+
+	priv->audio_skew_total -= priv->audio_skew_buffer[audio_skew_ptr];
+	priv->audio_skew_buffer[audio_skew_ptr] = current_time
+	    - 1e6*priv->audio_secs_per_block*priv->audio_recv_blocks_total;
+	priv->audio_skew_total += priv->audio_skew_buffer[audio_skew_ptr];
+	audio_skew_ptr = (audio_skew_ptr+1) % priv->aud_skew_cnt;
+
+	pthread_mutex_lock(&priv->skew_mutex);
+	// linear interpolation - here we interpolate current skew value
+	// from the moving average, which we expect to be in the middle
+	// of the interval
+	if (priv->audio_recv_blocks_total > priv->aud_skew_cnt) {
+	    priv->audio_skew = priv->audio_skew_total/priv->aud_skew_cnt;
+	    priv->audio_skew += (priv->audio_skew*priv->aud_skew_cnt)/(2*priv->audio_recv_blocks_total-priv->aud_skew_cnt);
+	} else {
+	    // this smoothes the evolution of audio_skew at startup a bit
+	    priv->audio_skew = ((priv->aud_skew_cnt+priv->audio_recv_blocks_total)*priv->audio_skew_total)/(priv->aud_skew_cnt*priv->audio_recv_blocks_total);
+	}
+	// current skew factor (assuming linearity)
+	// used for further interpolation in video_grabber
+	// probably overkill but seems to be necessary for
+	// stress testing by dropping half of the audio frames ;)
+	// especially when using ALSA with large block sizes
+	// where audio_skew remains a long while behind
+	if ((priv->audio_skew_measure_time != 0) && (current_time - priv->audio_skew_measure_time != 0)) {
+	    priv->audio_skew_factor = (double)(priv->audio_skew-prev_skew)/(current_time - priv->audio_skew_measure_time);
+	} else {
+	    priv->audio_skew_factor = 0.0;
+	}
+	
+	priv->audio_skew_measure_time = current_time;
+	prev_skew = priv->audio_skew;
+	pthread_mutex_unlock(&priv->skew_mutex);
+	
+	if ((priv->audio_tail+1) % priv->audio_buffer_size == priv->audio_head) {
+	    mp_msg(MSGT_TV, MSGL_ERR, "\ntoo bad - dropping audio frame !\n");
+	    priv->audio_drop++;
+	} else {
+	    priv->audio_tail = (priv->audio_tail+1) % priv->audio_buffer_size;
+	    priv->audio_cnt++;
+	}
+    }
+    return NULL;
+}
+
+static double grab_audio_frame(priv_t *priv, char *buffer, int len)
+{
+    mp_dbg(MSGT_TV, MSGL_DBG2, "grab_audio_frame(priv=%p, buffer=%p, len=%d)\n",
+	priv, buffer, len);
+
+    if (priv->first) {
+	pthread_create(&priv->video_grabber_thread, NULL, video_grabber, priv);
+	priv->first = 0;
+    }
+
+    // compensate for dropped audio frames
+    if (priv->audio_drop && (priv->audio_head == priv->audio_tail)) {
+	priv->audio_drop--;
+	priv->audio_sent_blocks_total++;
+	memset(buffer, 0, len);
+	return (double)priv->audio_sent_blocks_total*priv->audio_secs_per_block;
+    }
+
+    while (priv->audio_head == priv->audio_tail) {
+	usleep(10000);
+    }
+    memcpy(buffer, priv->audio_ringbuffer+priv->audio_head*priv->audio_in.blocksize, len);
+    priv->audio_head = (priv->audio_head+1) % priv->audio_buffer_size;
+    priv->audio_cnt--;
+    priv->audio_sent_blocks_total++;
+    return (double)priv->audio_sent_blocks_total*priv->audio_secs_per_block;
+}
+
+static int get_audio_framesize(priv_t *priv)
+{
+    return(priv->audio_in.blocksize);
+}
+
+#endif /* USE_TV */
diff -urN MPlayer-1.0pre5.orig/libvo/font_load_ft.c MPlayer-1.0pre5/libvo/font_load_ft.c
--- MPlayer-1.0pre5.orig/libvo/font_load_ft.c	2003-12-08 19:30:30 +0600
+++ MPlayer-1.0pre5/libvo/font_load_ft.c	2004-08-08 10:36:04 +0700
@@ -179,8 +179,8 @@
 	else {
 	    glyph_index = FT_Get_Char_Index(face, uni_charmap ? character:code);
 	    if (glyph_index==0) {
-		WARNING("Glyph for char 0x%02x|U+%04X|%c not found.", code, character,
-			code<' '||code>255 ? '.':code);
+		WARNING("Glyph for char 0x%02lx|U+%04lX|%c not found.", code, character,
+			code<' '||code>255 ? '.':(char)code);
 		desc->font[unicode?character:code] = -1;
 		continue;
 	    }
diff -urN MPlayer-1.0pre5.orig/libvo/vo_dga.c MPlayer-1.0pre5/libvo/vo_dga.c
--- MPlayer-1.0pre5.orig/libvo/vo_dga.c	2004-06-14 11:53:02 +0700
+++ MPlayer-1.0pre5/libvo/vo_dga.c	2004-08-08 10:36:13 +0700
@@ -811,7 +811,7 @@
     // do some more checkings here ...
 
     mp_msg(MSGT_VO, MSGL_V,
-           "vo_dga: bytes/line: %d, screen res: %dx%d, depth: %d, base: %08x, bpp: %d\n",
+           "vo_dga: bytes/line: %d, screen res: %dx%d, depth: %d, base: %p, bpp: %d\n", 
            vo_dga_width, vo_dga_vp_width, vo_dga_vp_height,
            HW_MODE.vdm_bytespp, vo_dga_base, HW_MODE.vdm_bitspp);
 
@@ -900,7 +900,7 @@
             for (i = 0; i < vo_modecount; i++)
             {
                 mp_msg(MSGT_VO, MSGL_V,
-                       "vo_dga: (%03d) depth=%d, bpp=%d, r=%08x, g=%08x, b=%08x, %d x %d\n",
+		       "vo_dga: (%03d) depth=%d, bpp=%d, r=%08lx, g=%08lx, b=%08lx, %d x %d\n",
                        i, vo_modelines[i].depth,
                        vo_modelines[i].bitsPerPixel,
                        vo_modelines[i].redMask, vo_modelines[i].greenMask,
diff -urN MPlayer-1.0pre5.orig/libvo/x11_common.c MPlayer-1.0pre5/libvo/x11_common.c
--- MPlayer-1.0pre5.orig/libvo/x11_common.c	2004-07-12 05:27:17 +0700
+++ MPlayer-1.0pre5/libvo/x11_common.c	2004-08-08 10:36:10 +0700
@@ -197,7 +197,7 @@
     mp_msg(MSGT_VO, MSGL_ERR, "X11 error: %s\n", msg);
 
     mp_msg(MSGT_VO, MSGL_V,
-           "Type: %x, display: %x, resourceid: %x, serial: %x\n",
+	   "Type: %x, display: %p, resourceid: %lx, serial: %lx\n",
            event->type, event->display, event->resourceid, event->serial);
     mp_msg(MSGT_VO, MSGL_V,
            "Error code: %x, request code: %x, minor code: %x\n",
@@ -1283,7 +1283,7 @@
         xev.data.l[0] = layer ? fs_layer : orig_layer;  // if not fullscreen, stay on default layer
         xev.data.l[1] = CurrentTime;
         mp_msg(MSGT_VO, MSGL_V,
-               "[x11] Layered style stay on top (layer %d).\n",
+	       "[x11] Layered style stay on top (layer %ld).\n",
                xev.data.l[0]);
         XSendEvent(mDisplay, mRootWin, False, SubstructureNotifyMask,
                    (XEvent *) & xev);
@@ -1585,7 +1585,7 @@
         return;
     }
     mp_msg(MSGT_VO, MSGL_INFO,
-           "xscreensaver_disable: xscreensaver wid=%d.\n", xs_windowid);
+           "xscreensaver_disable: xscreensaver wid=%ld.\n", xs_windowid);
 
     deactivate = XInternAtom(dpy, "DEACTIVATE", False);
     screensaver = XInternAtom(dpy, "SCREENSAVER", False);
@@ -1885,7 +1885,7 @@
         for (i = 0; i < nvisuals; i++)
         {
             mp_msg(MSGT_VO, MSGL_V,
-                   "vo: X11 truecolor visual %#x, depth %d, R:%lX G:%lX B:%lX\n",
+		   "vo: X11 truecolor visual %#lx, depth %d, R:%lX G:%lX B:%lX\n",
                    visuals[i].visualid, visuals[i].depth,
                    visuals[i].red_mask, visuals[i].green_mask,
                    visuals[i].blue_mask);
diff -urN MPlayer-1.0pre5.orig/m_option.c MPlayer-1.0pre5/m_option.c
--- MPlayer-1.0pre5.orig/m_option.c	2004-07-08 07:04:42 +0700
+++ MPlayer-1.0pre5/m_option.c	2004-08-08 10:36:04 +0700
@@ -1389,7 +1389,7 @@
       char prefix[len];
       strncpy(prefix,opt->name,len-1);
       prefix[len-1] = '\0';
-      mp_msg(MSGT_VFILTER,MSGL_ERR, "Option %s: unknown postfix %s\n"
+      mp_msg(MSGT_VFILTER,MSGL_ERR, "Option %1$s: unknown postfix %2$s\n"
 	     "Supported postfixes are:\n"
 	     "  %s-add\n"
 	     " Append the given list to the current list\n\n"
diff -urN MPlayer-1.0pre5.orig/m_option.c.orig MPlayer-1.0pre5/m_option.c.orig
--- MPlayer-1.0pre5.orig/m_option.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/m_option.c.orig	2004-07-08 07:04:42 +0700
@@ -0,0 +1,1834 @@
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <inttypes.h>
+#include <unistd.h>
+
+#include "m_option.h"
+//#include "m_config.h"
+#include "mp_msg.h"
+#include "libmpdemux/url.h"
+
+// Don't free for 'production' atm
+#ifndef MP_DEBUG
+#define NO_FREE
+#endif
+
+m_option_t* m_option_list_find(m_option_t* list,char* name) {
+  int i;
+
+  for(i = 0 ; list[i].name ; i++) {
+    int l = strlen(list[i].name) - 1;
+    if((list[i].type->flags & M_OPT_TYPE_ALLOW_WILDCARD) &&
+       (l > 0) && (list[i].name[l] == '*')) {
+      if(strncasecmp(list[i].name,name,l) == 0)
+	return &list[i];
+    } else if(strcasecmp(list[i].name,name) == 0)
+      return &list[i];
+  }
+  return NULL;
+}
+
+// Default function that just does a memcpy
+
+static void copy_opt(m_option_t* opt,void* dst,void* src) {
+  if(dst && src)
+    memcpy(dst,src,opt->type->size);
+}
+
+// Helper for the print funcs (from man printf)
+static char* dup_printf(const char *fmt, ...) {       
+  /* Guess we need no more than 50 bytes. */
+  int n, size = 50;
+  char *p;
+  va_list ap;
+  if ((p = malloc (size)) == NULL)
+    return NULL;
+  while (1) {
+    /* Try to print in the allocated space. */
+    va_start(ap, fmt);
+    n = vsnprintf (p, size, fmt, ap);
+    va_end(ap);
+    /* If that worked, return the string. */
+    if (n > -1 && n < size)      
+      return p;
+    /* Else try again with more space. */
+    if (n > -1)    /* glibc 2.1 */
+      size = n+1; /* precisely what is needed */
+    else           /* glibc 2.0 */
+      size *= 2;  /* twice the old size */
+    if ((p = realloc (p, size)) == NULL)
+      return NULL;
+  }
+}
+
+
+// Flag
+
+#define VAL(x) (*(int*)(x))
+
+static int parse_flag(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  if (src == M_CONFIG_FILE) {
+    if(!param) return M_OPT_MISSING_PARAM;
+    if (!strcasecmp(param, "yes") ||	/* any other language? */
+	!strcasecmp(param, "on") ||
+	!strcasecmp(param, "ja") ||
+	!strcasecmp(param, "si") ||
+	!strcasecmp(param, "igen") ||
+	!strcasecmp(param, "y") ||
+	!strcasecmp(param, "j") ||
+	!strcasecmp(param, "i") ||
+	!strcasecmp(param, "tak") ||
+	!strcasecmp(param, "ja") ||
+	!strcasecmp(param, "true") ||
+	!strcmp(param, "1")) {
+      if(dst) VAL(dst) = opt->max;
+    } else if (!strcasecmp(param, "no") ||
+	       !strcasecmp(param, "off") ||
+	       !strcasecmp(param, "nein") ||
+	       !strcasecmp(param, "nicht") ||
+	       !strcasecmp(param, "nem") ||
+	       !strcasecmp(param, "n") ||
+	       !strcasecmp(param, "nie") ||
+	       !strcasecmp(param, "nej") ||
+	       !strcasecmp(param, "false") ||
+	       !strcmp(param, "0")) {
+      if(dst) VAL(dst) = opt->min;
+    } else {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Invalid parameter for %s flag: %s\n",name, param);
+      return M_OPT_INVALID;
+    }
+    return 1;
+  } else {
+    if(dst) VAL(dst) = opt->max;
+    return 0;
+  }
+}
+
+static char* print_flag(m_option_t* opt,  void* val) {
+  if(VAL(val) == opt->min)
+    return strdup("no");
+  else
+    return strdup("yes");
+}
+
+m_option_type_t m_option_type_flag = {
+  "Flag",
+  "need yes or no in config files",
+  sizeof(int),
+  0,
+  parse_flag,
+  print_flag,
+  copy_opt,
+  copy_opt,
+  NULL,
+  NULL
+};
+
+// Integer
+
+static int parse_int(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  long tmp_int;
+  char *endptr;
+  src = 0;
+
+  if (param == NULL)
+    return M_OPT_MISSING_PARAM;
+
+  tmp_int = strtol(param, &endptr, 0);
+  if (*endptr) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "The %s option must be an integer: %s\n",name, param);
+    return M_OPT_INVALID;
+  }
+
+  if ((opt->flags & M_OPT_MIN) && (tmp_int < opt->min)) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "The %s option must be >= %d: %s\n", name, (int) opt->min, param);
+    return M_OPT_OUT_OF_RANGE;
+  }
+
+  if ((opt->flags & M_OPT_MAX) && (tmp_int > opt->max)) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "The %s option must be <= %d: %s\n",name, (int) opt->max, param);
+    return M_OPT_OUT_OF_RANGE;
+  }
+
+  if(dst) VAL(dst) = tmp_int;
+
+  return 1;
+}
+
+static char* print_int(m_option_t* opt,  void* val) {
+  opt = NULL;
+  return dup_printf("%d",VAL(val));
+}
+
+m_option_type_t m_option_type_int = {
+  "Integer",
+  "",
+  sizeof(int),
+  0,
+  parse_int,
+  print_int,
+  copy_opt,
+  copy_opt,
+  NULL,
+  NULL
+};
+
+// Float
+
+#undef VAL
+#define VAL(x) (*(double*)(x))
+
+static int parse_double(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  double tmp_float;
+  char* endptr;
+  src = 0;
+
+  if (param == NULL)
+    return M_OPT_MISSING_PARAM;
+
+  tmp_float = strtod(param, &endptr);
+
+  switch(*endptr) {
+  case ':':
+  case '/':
+    tmp_float /= strtod(endptr+1, &endptr);
+    break;
+  case '.':
+  case ',':
+    /* we also handle floats specified with
+     * non-locale decimal point ::atmos
+     */
+    if(tmp_float<0)
+      tmp_float -= 1.0/pow(10,strlen(endptr+1)) * strtod(endptr+1, &endptr);
+    else
+      tmp_float += 1.0/pow(10,strlen(endptr+1)) * strtod(endptr+1, &endptr);
+    break;
+  }
+
+  if (*endptr) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "The %s option must be a floating point "
+	   "number or a ratio (numerator[:/]denominator): %s\n",name, param);
+    return M_OPT_INVALID;
+  }
+
+  if (opt->flags & M_OPT_MIN)
+    if (tmp_float < opt->min) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "The %s option must be >= %f: %s\n", name, opt->min, param);
+      return M_OPT_OUT_OF_RANGE;
+    }
+
+  if (opt->flags & M_OPT_MAX)
+    if (tmp_float > opt->max) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "The %s option must be <= %f: %s\n", name, opt->max, param);
+      return M_OPT_OUT_OF_RANGE;
+    }
+
+  if(dst) VAL(dst) = tmp_float;
+  return 1;
+}
+
+static char* print_double(m_option_t* opt,  void* val) {
+  opt = NULL;
+  return dup_printf("%f",VAL(val));
+}
+
+m_option_type_t m_option_type_double = {
+  "Double",
+  "double precission floating point number or ratio (numerator[:/]denominator)",
+  sizeof(double),
+  0,
+  parse_double,
+  print_double,
+  copy_opt,
+  copy_opt,
+  NULL,
+  NULL
+};
+
+#undef VAL
+#define VAL(x) (*(float*)(x))
+
+static int parse_float(m_option_t* opt,char *name, char *param, void* dst, int src) {
+    double tmp;
+    int r= parse_double(opt, name, param, &tmp, src);
+    if(r==1 && dst) VAL(dst) = tmp;
+    return r;
+}
+
+static char* print_float(m_option_t* opt,  void* val) {
+  opt = NULL;
+  return dup_printf("%f",VAL(val));
+}
+
+m_option_type_t m_option_type_float = {
+  "Float",
+  "floating point number or ratio (numerator[:/]denominator)",
+  sizeof(float),
+  0,
+  parse_float,
+  print_float,
+  copy_opt,
+  copy_opt,
+  NULL,
+  NULL
+};
+
+///////////// Position
+#undef VAL
+#define VAL(x) (*(off_t*)(x))
+
+static int parse_position(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  off_t tmp_off;
+  char dummy;
+
+  if (param == NULL)
+    return M_OPT_MISSING_PARAM;
+  if (sscanf(param, sizeof(off_t) == sizeof(int) ?
+	     "%d%c" : "%lld%c", &tmp_off, &dummy) != 1) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "The %s option must be an integer: %s\n",opt->name,param);
+    return M_OPT_INVALID;
+  }
+
+  if (opt->flags & M_OPT_MIN)
+    if (tmp_off < opt->min) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR,
+	     (sizeof(off_t) == sizeof(int) ?
+	      "The %s option must be >= %d: %s\n" :
+	      "The %s option must be >= %lld: %s\n"),
+	     name, (off_t) opt->min, param);
+      return M_OPT_OUT_OF_RANGE;
+    }
+
+  if (opt->flags & M_OPT_MAX)
+    if (tmp_off > opt->max) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR,
+	     (sizeof(off_t) == sizeof(int) ?
+	      "The %s option must be <= %d: %s\n" :
+	      "The %s option must be <= %lld: %s\n"),
+	     name, (off_t) opt->max, param);
+      return M_OPT_OUT_OF_RANGE;
+    }
+
+  if(dst)
+    VAL(dst) = tmp_off;
+  return 1;
+}
+
+static char* print_position(m_option_t* opt,  void* val) {
+  return dup_printf(sizeof(off_t) == sizeof(int) ?  "%d" : "%lld",VAL(val));
+}
+
+m_option_type_t m_option_type_position = {
+  "Position",
+  "Integer (off_t)",
+  sizeof(off_t),
+  0,
+  parse_position,
+  print_position,
+  copy_opt,
+  copy_opt,
+  NULL,
+  NULL
+};
+
+
+///////////// String
+
+#undef VAL
+#define VAL(x) (*(char**)(x))
+
+static int parse_str(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  
+
+  if (param == NULL)
+      return M_OPT_MISSING_PARAM;
+
+  if ((opt->flags & M_OPT_MIN) && (strlen(param) < opt->min)) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Parameter must be >= %d chars: %s\n",
+	   (int) opt->min, param);
+    return M_OPT_OUT_OF_RANGE;
+  }
+
+  if ((opt->flags & M_OPT_MAX) && (strlen(param) > opt->max)) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Parameter must be <= %d chars: %s\n",
+	   (int) opt->max, param);
+    return M_OPT_OUT_OF_RANGE;
+  }
+
+  if(dst) {
+    if(VAL(dst))
+      free(VAL(dst));
+    VAL(dst) = strdup(param);
+  }
+
+  return 1;
+
+}
+
+static char* print_str(m_option_t* opt,  void* val) {
+  return (val && VAL(val) && strlen(VAL(val)) > 0) ? strdup(VAL(val)) : NULL;
+}
+
+static void copy_str(m_option_t* opt,void* dst, void* src) {
+  if(dst && src) {
+#ifndef NO_FREE
+    if(VAL(dst)) free(VAL(dst)); //FIXME!!!
+#endif
+    VAL(dst) = VAL(src) ? strdup(VAL(src)) : NULL;
+  }
+}
+  
+static void free_str(void* src) {
+  if(src && VAL(src)){
+#ifndef NO_FREE
+    free(VAL(src)); //FIXME!!!
+#endif
+    VAL(src) = NULL;
+  }
+}
+
+m_option_type_t m_option_type_string = {
+  "String",
+  "",
+  sizeof(char*),
+  M_OPT_TYPE_DYNAMIC,
+  parse_str,
+  print_str,
+  copy_str,
+  copy_str,
+  copy_str,
+  free_str
+};
+  
+//////////// String list
+
+#define LIST_SEPARATOR ','
+#undef VAL
+#define VAL(x) (*(char***)(x))
+
+#define OP_NONE 0
+#define OP_ADD 1
+#define OP_PRE 2
+#define OP_DEL 3
+#define OP_CLR 4
+
+static void free_str_list(void* dst) {
+  char** d;
+  int i;
+
+  if(!dst || !VAL(dst)) return;
+  d = VAL(dst);
+
+// FIXME!!!
+#ifndef NO_FREE
+  for(i = 0 ; d[i] != NULL ; i++)
+    free(d[i]);
+  free(d);
+#endif
+  VAL(dst) = NULL;
+}
+
+static int str_list_add(char** add, int n,void* dst,int pre) {
+  char** lst = VAL(dst);
+  int ln;
+
+  if(!dst) return M_OPT_PARSER_ERR;
+  lst = VAL(dst);
+
+  for(ln = 0 ; lst && lst[ln] ; ln++)
+    /**/;
+
+  lst = realloc(lst,(n+ln+1)*sizeof(char*));
+  
+  if(pre) {
+    memmove(&lst[n],lst,(ln+1)*sizeof(char*));
+    memcpy(lst,add,n*sizeof(char*));
+  } else 
+    memcpy(&lst[ln],add,(n+1)*sizeof(char*));
+
+  free(add);
+
+  VAL(dst) = lst;
+  
+  return 1;
+}
+
+static int str_list_del(char** del, int n,void* dst) {
+  char **lst,*ep,**d;
+  int i,ln,s;
+  long idx;
+  
+  if(!dst) return M_OPT_PARSER_ERR;
+  lst = VAL(dst);
+
+  for(ln = 0 ; lst && lst[ln] ; ln++)
+    /**/;
+  s = ln;
+
+  for(i = 0 ; del[i] != NULL ; i++) {
+    idx = strtol(del[i], &ep, 0);
+    if(*ep) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Invalid index: %s\n",del[i]);
+      free(del[i]);
+      continue;
+    }
+    free(del[i]);
+    if(idx < 0 || idx >= ln) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Index %ld is out of range.\n",idx);
+      continue;
+    } else if(!lst[idx])
+      continue;
+    free(lst[idx]);
+    lst[idx] = NULL;
+    s--;
+  }
+  free(del);
+
+  if(s == 0) {
+    if(lst) free(lst);
+    VAL(dst) = NULL;
+    return 1;
+  }
+
+  d = calloc(s+1,sizeof(char*));
+  for(i = 0, n = 0 ; i < ln ; i++) {
+    if(!lst[i]) continue;
+    d[n] = lst[i];
+    n++;
+  }
+  d[s] = NULL;
+
+  if(lst) free(lst);
+  VAL(dst) = d;
+
+  return 1;
+}
+  
+
+static int parse_str_list(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  int n = 0,len = strlen(opt->name);
+  char *ptr = param, *last_ptr, **res;
+  int op = OP_NONE;
+
+  if(opt->name[len-1] == '*' && ((int)strlen(name) > len - 1)) {
+    char* n = &name[len-1];
+    if(strcasecmp(n,"-add") == 0)
+      op = OP_ADD;
+    else if(strcasecmp(n,"-pre") == 0)
+      op = OP_PRE;
+    else if(strcasecmp(n,"-del") == 0)
+      op = OP_DEL;
+    else if(strcasecmp(n,"-clr") == 0)
+      op = OP_CLR;
+    else
+      return M_OPT_UNKNOWN;
+  }
+
+  // Clear the list ??
+  if(op == OP_CLR) {
+    if(dst)
+      free_str_list(dst);
+    return 0;
+  }
+
+  // All other ops need a param
+  if (param == NULL || strlen(param) == 0)
+      return M_OPT_MISSING_PARAM;
+
+
+  while(ptr[0] != '\0') {
+    last_ptr = ptr;
+    ptr = strchr(ptr,LIST_SEPARATOR);
+    if(!ptr) {
+      n++;
+      break;
+    }
+    ptr++;
+    n++;
+  }
+  if(n == 0)
+    return M_OPT_INVALID;
+  if( ((opt->flags & M_OPT_MIN) && (n < opt->min)) || 
+      ((opt->flags & M_OPT_MAX) && (n > opt->max)) )
+    return M_OPT_OUT_OF_RANGE;
+
+  if(!dst) return 1;
+
+  res = malloc((n+2)*sizeof(char*));
+  ptr = param;
+  n = 0;
+
+  while(1) {
+    last_ptr = ptr;
+    ptr = strchr(ptr,LIST_SEPARATOR);
+    if(!ptr) {
+      res[n] = strdup(last_ptr);
+      n++;
+      break;
+    }
+    len = ptr - last_ptr;
+    res[n] = (char*)malloc(len + 1);
+    if(len) strncpy(res[n],last_ptr,len);
+    res[n][len] = '\0';
+    ptr++;
+    n++;
+  }
+  res[n] = NULL;
+
+  switch(op) {
+  case OP_ADD:
+    return str_list_add(res,n,dst,0);
+  case OP_PRE:
+    return str_list_add(res,n,dst,1);
+  case OP_DEL:
+    return str_list_del(res,n,dst);
+  }
+
+  if(VAL(dst))
+    free_str_list(dst);
+  VAL(dst) = res;
+
+  return 1;
+}
+  
+static void copy_str_list(m_option_t* opt,void* dst, void* src) {
+  int n;
+  char **d,**s;
+
+  if(!(dst && src)) return;
+  s = VAL(src);
+
+  if(VAL(dst))
+    free_str_list(dst);
+
+  if(!s) {
+    VAL(dst) = NULL;
+    return;
+  }
+
+  for(n = 0 ; s[n] != NULL ; n++)
+    /* NOTHING */;
+  d = (char**)malloc((n+1)*sizeof(char*));
+  for( ; n >= 0 ; n--)
+    d[n] = s[n] ? strdup(s[n]) : NULL;
+
+  VAL(dst) = d;
+}
+
+static char* print_str_list(m_option_t* opt, void* src) {
+  char **lst = NULL;
+  char *ret = NULL,*last = NULL;
+  int i;
+  
+  if(!(src && VAL(src))) return NULL;
+  lst = VAL(src);
+
+  for(i = 0 ; lst[i] ; i++) {
+    if(last) {
+      ret = dup_printf("%s,%s",last,lst[i]);
+      free(last);
+    } else
+      ret = strdup(lst[i]);
+    last = ret;
+  }
+  if(last && last != ret) free(last);
+  return ret;
+}
+
+m_option_type_t m_option_type_string_list = {
+  "String list",
+  "A list of strings separated by ','\n"
+  "Option with a name ending in an * permits using the following suffix: \n"
+  "\t-add: Add the given parameters at the end of the list.\n"
+  "\t-pre: Add the given parameters at the begining of the list.\n"
+  "\t-del: Remove the entry at the given indices.\n"
+  "\t-clr: Clear the list.\n"
+  "e.g: -vf-add flip,mirror -vf-del 2,5\n",  
+  sizeof(char**),
+  M_OPT_TYPE_DYNAMIC | M_OPT_TYPE_ALLOW_WILDCARD,
+  parse_str_list,
+  print_str_list,
+  copy_str_list,
+  copy_str_list,
+  copy_str_list,
+  free_str_list
+};
+ 
+ 
+///////////////////  Func based options
+
+// A chained list to save the various calls for func_param and func_full
+typedef struct m_func_save m_func_save_t;
+struct m_func_save {
+  m_func_save_t* next;
+  char* name;
+  char* param;
+};
+
+#undef VAL
+#define VAL(x) (*(m_func_save_t**)(x))
+
+static void free_func_pf(void* src) {
+  m_func_save_t *s,*n;
+
+  if(!src) return;
+
+  s = VAL(src);
+  
+  while(s) {
+    n = s->next;
+    free(s->name);
+    if(s->param) free(s->param);
+    free(s);
+    s = n;
+  }
+  VAL(src) = NULL;
+}
+
+// Parser for func_param and func_full
+static int parse_func_pf(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  m_func_save_t *s,*p;
+
+  if(!dst)
+    return 1;
+
+  s = (m_func_save_t*)calloc(1,sizeof(m_func_save_t));
+  s->name = strdup(name);
+  s->param = param ? strdup(param) : NULL;
+
+  p = VAL(dst);
+  if(p) {
+    for( ; p->next != NULL ; p = p->next)
+      /**/;
+    p->next = s;
+  } else
+    VAL(dst) = s;
+
+  return 1;
+}
+
+static void copy_func_pf(m_option_t* opt,void* dst, void* src) {
+  m_func_save_t *d = NULL, *s,* last = NULL;
+
+  if(!(dst && src)) return;
+  s = VAL(src);
+
+  if(VAL(dst))
+    free_func_pf(dst);
+
+  while(s) {
+    d = (m_func_save_t*)malloc(sizeof(m_func_save_t));
+    d->name = strdup(s->name);
+    d->param = s->param ? strdup(s->param) : NULL;
+    if(last)
+      last->next = d;
+    else
+      VAL(dst) = d;
+    last = d;
+    s = s->next;
+  }
+  
+    
+}
+
+/////////////////// Func_param
+
+static void set_func_param(m_option_t* opt, void* dst, void* src) {
+  m_func_save_t* s;
+
+  if(!src) return;
+  s = VAL(src);
+  
+  if(!s) return;
+
+  // Revert if needed
+  if(opt->priv) ((m_opt_default_func_t)opt->priv)(opt,opt->name);
+  for( ; s != NULL ; s = s->next)
+    ((m_opt_func_param_t) opt->p)(opt,s->param);
+}
+
+m_option_type_t m_option_type_func_param = {
+  "Func param",
+  "",
+  sizeof(m_func_save_t*),
+  M_OPT_TYPE_INDIRECT,
+  parse_func_pf,
+  NULL,
+  NULL, // Nothing to do on save
+  set_func_param,
+  copy_func_pf,
+  free_func_pf
+};
+
+/////////////////// Func_full
+
+static void set_func_full(m_option_t* opt, void* dst, void* src) {
+  m_func_save_t* s;
+
+  if(!src) return;
+
+  for(s = VAL(src) ; s ; s = s->next) {
+    // Revert if needed
+    if(opt->priv) ((m_opt_default_func_t)opt->priv)(opt,s->name);
+    ((m_opt_func_full_t) opt->p)(opt,s->name,s->param);
+  }
+}
+
+m_option_type_t m_option_type_func_full = {
+  "Func full",
+  "",
+  sizeof(m_func_save_t*),
+  M_OPT_TYPE_ALLOW_WILDCARD|M_OPT_TYPE_INDIRECT,
+  parse_func_pf,
+  NULL,
+  NULL, // Nothing to do on save
+  set_func_full,
+  copy_func_pf,
+  free_func_pf
+};
+
+/////////////// Func
+
+#undef VAL
+#define VAL(x) (*(int*)(x))
+
+static int parse_func(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  if(dst)
+    VAL(dst) += 1;
+  return 0;
+}
+
+static void set_func(m_option_t* opt,void* dst, void* src) {
+  int i;
+  if(opt->priv) ((m_opt_default_func_t)opt->priv)(opt,opt->name);
+  for(i = 0 ; i < VAL(src) ; i++)
+    ((m_opt_func_t) opt->p)(opt);
+}
+
+m_option_type_t m_option_type_func = {
+  "Func",
+  "",
+  sizeof(int),
+  M_OPT_TYPE_INDIRECT,
+  parse_func,
+  NULL,
+  NULL, // Nothing to do on save
+  set_func,
+  NULL,
+  NULL
+};
+
+/////////////////// Print
+
+static int parse_print(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  if(opt->type->flags&M_OPT_TYPE_INDIRECT)
+    mp_msg(MSGT_CFGPARSER, MSGL_INFO, "%s", *(char **) opt->p);
+  else
+    mp_msg(MSGT_CFGPARSER, MSGL_INFO, "%s", (char *) opt->p);
+
+  if(opt->priv == NULL)
+    return M_OPT_EXIT;
+  return 1;
+}
+
+m_option_type_t m_option_type_print = {
+  "Print",
+  "",
+  0,
+  0,
+  parse_print,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+};
+
+m_option_type_t m_option_type_print_indirect = {
+  "Print",
+  "",
+  0,
+  M_OPT_TYPE_INDIRECT,
+  parse_print,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+};
+
+
+/////////////////////// Subconfig
+#undef VAL
+#define VAL(x) (*(char***)(x))
+
+static int parse_subconf(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  char *subparam;
+  char *subopt;
+  int nr = 0,i,r;
+  m_option_t *subopts;
+  char *token;
+  char *p;
+  char** lst = NULL;
+
+  if (param == NULL || strlen(param) == 0)
+    return M_OPT_MISSING_PARAM;
+
+  subparam = malloc(strlen(param)+1);
+  subopt = malloc(strlen(param)+1);
+  p = strdup(param); // In case that param is a static string (cf man strtok)
+
+  subopts = opt->p;
+
+  token = strtok(p, (char *)&(":"));
+  while(token)
+    {
+      int sscanf_ret;
+      /* clear out */
+      subopt[0] = subparam[0] = 0;
+			    
+      sscanf_ret = sscanf(token, "%[^=]=%[^:]", subopt, subparam);
+
+      mp_msg(MSGT_CFGPARSER, MSGL_DBG3, "token: '%s', subopt='%s', subparam='%s' (ret: %d)\n", token, subopt, subparam, sscanf_ret);
+      switch(sscanf_ret)
+	{
+	case 1:
+	  subparam[0] = 0;
+	case 2:
+	  for(i = 0 ; subopts[i].name ; i++) {
+	    if(!strcmp(subopts[i].name,subopt)) break;
+	  }
+	  if(!subopts[i].name) {
+	    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Unknown suboption %s\n",name,subopt);
+	    return M_OPT_UNKNOWN;
+	  }
+	  r = m_option_parse(&subopts[i],subopt,
+			     subparam[0] == 0 ? NULL : subparam,NULL,src);
+	  if(r < 0) return r;
+	  if(dst) {
+	    lst = (char**)realloc(lst,2 * (nr+2) * sizeof(char*));
+	    lst[2*nr] = strdup(subopt);
+	    lst[2*nr+1] = subparam[0] == 0 ? NULL : strdup(subparam);
+	    memset(&lst[2*(nr+1)],0,2*sizeof(char*));
+	    nr++;
+	  }
+	  break;
+	default:
+	  mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Invalid subconfig argument! ('%s')\n", token);
+	  return M_OPT_INVALID;
+	}
+      token = strtok(NULL, (char *)&(":"));
+    }
+
+  free(subparam);
+  free(subopt);
+  free(p);
+  if(dst)
+    VAL(dst) = lst;
+
+  return 1;
+}
+
+m_option_type_t m_option_type_subconfig = {
+  "Subconfig",
+  "The syntax is -option opt1=foo:flag:opt2=blah",
+  sizeof(int),
+  M_OPT_TYPE_HAS_CHILD,
+  parse_subconf,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+};
+
+#include "libmpcodecs/img_format.h"
+
+/* FIXME: snyc with img_format.h */
+static struct {
+  char* name;
+  unsigned int fmt;
+} mp_imgfmt_list[] = {
+  {"444p", IMGFMT_444P},
+  {"422p", IMGFMT_422P},
+  {"411p", IMGFMT_411P},
+  {"yuy2", IMGFMT_YUY2},
+  {"uyvy", IMGFMT_UYVY},
+  {"yvu9", IMGFMT_YVU9},
+  {"if09", IMGFMT_IF09},
+  {"yv12", IMGFMT_YV12},
+  {"i420", IMGFMT_I420},
+  {"iyuv", IMGFMT_IYUV},
+  {"clpl", IMGFMT_CLPL},
+  {"hm12", IMGFMT_HM12},
+  {"y800", IMGFMT_Y800},
+  {"y8", IMGFMT_Y8},
+  {"nv12", IMGFMT_NV12},
+  {"nv21", IMGFMT_NV21},
+  {"bgr24", IMGFMT_BGR24},
+  {"bgr32", IMGFMT_BGR32},
+  {"bgr16", IMGFMT_BGR16},
+  {"bgr15", IMGFMT_BGR15},
+  {"bgr8", IMGFMT_BGR8},
+  {"bgr4", IMGFMT_BGR4},
+  {"bg4b", IMGFMT_BG4B},
+  {"bgr1", IMGFMT_BGR1},
+  {"rgb24", IMGFMT_RGB24},
+  {"rgb32", IMGFMT_RGB32},
+  {"rgb16", IMGFMT_RGB16},
+  {"rgb15", IMGFMT_RGB15},
+  {"rgb8", IMGFMT_RGB8},
+  {"rgb4", IMGFMT_RGB4},
+  {"rg4b", IMGFMT_RG4B},
+  {"rgb1", IMGFMT_RGB1},
+  { NULL, 0 }
+};
+
+static int parse_imgfmt(m_option_t* opt,char *name, char *param, void* dst, int src) {
+  uint32_t fmt = 0;
+  int i;
+
+  if (param == NULL || strlen(param) == 0)
+    return M_OPT_MISSING_PARAM;
+
+  if(!strcmp(param,"help")) {
+    mp_msg(MSGT_CFGPARSER, MSGL_INFO, "Available formats:");
+    for(i = 0 ; mp_imgfmt_list[i].name ; i++)
+      mp_msg(MSGT_CFGPARSER, MSGL_INFO, " %s",mp_imgfmt_list[i].name);
+    mp_msg(MSGT_CFGPARSER, MSGL_INFO, "\n");
+    return M_OPT_EXIT;
+  }
+  
+  if (sscanf(param, "0x%x", &fmt) != 1)
+  {
+  for(i = 0 ; mp_imgfmt_list[i].name ; i++) {
+    if(!strcasecmp(param,mp_imgfmt_list[i].name)) {
+      fmt=mp_imgfmt_list[i].fmt;
+      break;
+    }
+  }
+  if(!mp_imgfmt_list[i].name) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: unknown format name: '%s'\n",name,param);
+    return M_OPT_INVALID;
+  }
+  }
+
+  if(dst)
+    *((uint32_t*)dst) = fmt;
+
+  return 1;
+}
+
+m_option_type_t m_option_type_imgfmt = {
+  "Image format",
+  "Please report any missing colorspaces.",
+  sizeof(uint32_t),
+  0,
+  parse_imgfmt,
+  NULL,
+  copy_opt,
+  copy_opt,
+  NULL,
+  NULL
+};
+
+//// Objects (i.e. filters, etc) settings
+
+#include "m_struct.h"
+
+#undef VAL
+#define VAL(x) (*(m_obj_settings_t**)(x))
+
+static int find_obj_desc(char* name,m_obj_list_t* l,m_struct_t** ret) {
+  int i;
+  char* n;
+
+  for(i = 0 ; l->list[i] ; i++) {
+    n = M_ST_MB(char*,l->list[i],l->name_off);
+    if(!strcmp(n,name)) {
+      *ret = M_ST_MB(m_struct_t*,l->list[i],l->desc_off);
+      return 1;
+    }
+  }
+  return 0;
+}
+
+static int get_obj_param(char* opt_name,char* obj_name, m_struct_t* desc,
+			 char* str,int* nold,int oldmax,char** dst) {
+  char* eq,param;
+  m_option_t* opt;
+  int r;
+
+  eq = strchr(str,'=');
+  if(eq && eq == str)
+    eq = NULL;
+
+  if(eq) {
+    char* p = eq + 1;
+    if(p[0] == '\0') p = NULL;
+    eq[0] = '\0';
+    opt = m_option_list_find(desc->fields,str);
+    if(!opt) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: %s doesn't have a %s parameter.\n",opt_name,obj_name,str);
+      return M_OPT_UNKNOWN;
+    }
+    r = m_option_parse(opt,str,p,NULL,M_CONFIG_FILE);
+    if(r < 0) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while parsing %s parameter %s (%s)\n",opt_name,obj_name,str,p);
+      eq[0] = '=';
+      return r;
+    }
+    if(dst) {
+      dst[0] = strdup(str);
+      dst[1] = p ? strdup(p) : NULL;
+    }
+    eq[0] = '=';
+  } else {
+    if((*nold) >= oldmax) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: %s has only %d params, so you can't give more than %d unnamed params.\n",
+	     opt_name,obj_name,oldmax,oldmax);
+      return M_OPT_OUT_OF_RANGE;
+    }
+    opt = &desc->fields[(*nold)];
+    r = m_option_parse(opt,opt->name,str,NULL,M_CONFIG_FILE);
+    if(r < 0) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while parsing %s parameter %s (%s)\n",opt_name,obj_name,opt->name,str);
+      return r;
+    }
+    if(dst) {
+      dst[0] = strdup(opt->name);
+      dst[1] = strdup(str);
+    }
+    (*nold)++;
+  }
+  return 1;
+}
+
+static int get_obj_params(char* opt_name, char* name,char* params,
+			  m_struct_t* desc,char separator, char*** _ret) {
+  int n = 0,nold = 0, nopts,r;
+  char* ptr,*last_ptr = params,*eq;
+  char** ret;
+
+  if(!strcmp(params,"help")) { // Help
+    char min[50],max[50];
+    if(!desc->fields) {
+      printf("%s doesn't have any options.\n\n",name);
+      return M_OPT_EXIT;
+    }
+    printf("\n Name                 Type            Min        Max\n\n");
+    for(n = 0 ; desc->fields[n].name ; n++) {
+      m_option_t* opt = &desc->fields[n];
+      if(opt->type->flags & M_OPT_TYPE_HAS_CHILD) continue;
+      if(opt->flags & M_OPT_MIN)
+	sprintf(min,"%-8.0f",opt->min);
+      else
+	strcpy(min,"No");
+      if(opt->flags & M_OPT_MAX)
+	sprintf(max,"%-8.0f",opt->max);
+      else
+	strcpy(max,"No");
+      printf(" %-20.20s %-15.15s %-10.10s %-10.10s\n",
+	     opt->name,
+	     opt->type->name,
+	     min,
+	     max);
+    }
+    printf("\n");
+    return M_OPT_EXIT;
+  }
+
+  for(nopts = 0 ; desc->fields[nopts].name ; nopts++)
+    /* NOP */;
+
+  // TODO : Check that each opt can be parsed
+  r = 1;
+  while(last_ptr && last_ptr[0] != '\0') {
+    ptr = strchr(last_ptr,separator);
+    if(!ptr) {
+      r = get_obj_param(opt_name,name,desc,last_ptr,&nold,nopts,NULL);
+      n++;
+      break;
+    }
+    if(ptr == last_ptr) { // Empty field, count it and go on
+      nold++;
+      last_ptr = ptr+1;
+      continue;
+    }
+    ptr[0] = '\0';
+    r = get_obj_param(opt_name,name,desc,last_ptr,&nold,nopts,NULL);
+    ptr[0] = separator;
+    if(r < 0) break;
+    n++;
+    last_ptr = ptr+1;
+  }
+  if(r < 0) return r;
+  if(!_ret) // Just test
+    return 1;
+
+  ret = malloc((n+2)*2*sizeof(char*));
+  n = nold = 0;
+  last_ptr = params;
+  
+  while(last_ptr && last_ptr[0] != '\0') {
+    ptr = strchr(last_ptr,separator);
+    if(!ptr) {
+      get_obj_param(opt_name,name,desc,last_ptr,&nold,nopts,&ret[n*2]);
+      n++;
+      break;
+    }
+    if(ptr == last_ptr) { // Empty field, count it and go on
+      last_ptr = ptr+1;
+      nold++;
+      continue;
+    }
+    ptr[0] = '\0';
+    get_obj_param(opt_name,name,desc,last_ptr,&nold,nopts,&ret[n*2]);
+    n++;
+    last_ptr = ptr+1;
+  }
+  ret[n*2] = ret[n*2+1] = NULL;  
+  *_ret = ret;
+  
+  return 1;
+}
+
+static int parse_obj_params(m_option_t* opt,char *name,
+			    char *param, void* dst, int src) {
+  char** opts;
+  int r;
+  m_obj_params_t* p = opt->priv;
+  m_struct_t* desc = p->desc;
+  char* cpy = strdup(param);
+  
+  // We need the object desc
+  if(!p)
+    return M_OPT_INVALID;
+  
+  r = get_obj_params(name,desc->name,cpy,desc,p->separator,&opts);
+  free(cpy);
+  if(r < 0)
+    return r;
+  if(!dst)
+    return 1;
+
+  for(r = 0 ; opts[r] ; r += 2)
+    m_struct_set(desc,dst,opts[r],opts[r+1]);
+
+  return 1;     
+}
+
+
+m_option_type_t m_option_type_obj_params = {
+  "Object params",
+  "",
+  0,
+  0,
+  parse_obj_params,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+};
+
+/// Some predefined types as a definition would be quite lengthy
+
+/// Span arguments
+static m_span_t m_span_params_dflts = { -1, -1 };
+static m_option_t m_span_params_fields[] = {
+  {"start", M_ST_OFF(m_span_t,start), CONF_TYPE_INT, M_OPT_MIN, 1 ,0, NULL},
+  {"end", M_ST_OFF(m_span_t,end), CONF_TYPE_INT, M_OPT_MIN , 1 ,0, NULL},
+  { NULL, NULL, 0, 0, 0, 0,  NULL }
+};
+static struct m_struct_st m_span_opts = {
+  "m_span",
+  sizeof(m_span_t),
+  &m_span_params_dflts,
+  m_span_params_fields
+};
+m_obj_params_t m_span_params_def = {
+  &m_span_opts,
+  '-'
+};
+
+static int parse_obj_settings(char* opt,char* str,m_obj_list_t* list,
+			      m_obj_settings_t **_ret, int ret_n) {
+  int r;
+  char *param,**plist = NULL;
+  m_struct_t* desc;
+  m_obj_settings_t *ret = _ret ? *_ret : NULL;
+  
+
+  // Now check that the object exists
+  param = strchr(str,'=');
+  if(param) {
+    param[0] = '\0';
+    param++;
+    if(strlen(param) <= 0)
+      param = NULL;
+  }
+
+
+  if(!find_obj_desc(str,list,&desc)) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: %s doesn't exist.\n",opt,str);
+    return M_OPT_INVALID;
+  }
+
+  if(param) {
+    if(!desc && _ret) {
+      plist = calloc(4,sizeof(char*));
+      plist[0] = strdup("_oldargs_");
+      plist[1] = strdup(param);
+    } else if(desc) {
+      r = get_obj_params(opt,str,param,desc,':',_ret ? &plist : NULL);
+      if(r < 0)
+	return r;
+    }
+  }
+  if(!_ret)
+    return 1;
+
+  ret = realloc(ret,(ret_n+2)*sizeof(m_obj_settings_t));
+  memset(&ret[ret_n],0,2*sizeof(m_obj_settings_t));
+  ret[ret_n].name = strdup(str);
+  ret[ret_n].attribs = plist;
+
+  *_ret = ret;
+  return 1;
+}
+
+static void free_obj_settings_list(void* dst);
+
+static int obj_settings_list_del(char *opt_name,char *param,void* dst, int src) {
+  char** str_list = NULL;
+  int r,i,idx_max = 0;
+  char* rem_id = "_removed_marker_";
+  m_option_t list_opt = {opt_name , NULL, CONF_TYPE_STRING_LIST,
+			   0, 0, 0, NULL };
+  m_obj_settings_t* obj_list = dst ? VAL(dst) : NULL;
+
+  if(dst && !obj_list) {
+    mp_msg(MSGT_CFGPARSER, MSGL_WARN, "Option %s: the list is empty.\n",opt_name);
+    return 1;
+  } else if(obj_list) {
+    for(idx_max = 0 ; obj_list[idx_max].name != NULL ; idx_max++)
+      /* NOP */;
+  }
+
+  r = m_option_parse(&list_opt,opt_name,param,&str_list,src);
+  if(r < 0 || !str_list)
+    return r;
+
+  for(r = 0 ; str_list[r] ; r++) {
+    int id;
+    char* endptr;
+    id = strtol(str_list[r],&endptr,0);
+    if(endptr == str_list[r]) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: invalid parameter. We need a list of integers which are the indices of the elements to remove.\n",opt_name);
+      m_option_free(&list_opt,&str_list);
+      return M_OPT_INVALID;
+    }
+    if(!obj_list) continue;
+    if(id >= idx_max || id < -idx_max) {
+      mp_msg(MSGT_CFGPARSER, MSGL_WARN, "Option %s: Index %d is out of range.\n",opt_name,id);
+      continue;
+    }
+    if(id < 0)
+      id = idx_max + id;
+    free(obj_list[id].name);
+    free_str_list(&(obj_list[id].attribs));
+    obj_list[id].name = rem_id;
+  }
+
+  if(!dst) {
+    m_option_free(&list_opt,&str_list);
+    return 1;
+  }
+
+  for(i = 0 ; obj_list[i].name ; i++) {
+    while(obj_list[i].name == rem_id) {
+      memmove(&obj_list[i],&obj_list[i+1],sizeof(m_obj_settings_t)*(idx_max - i));
+      idx_max--;
+    }
+  }
+  obj_list = realloc(obj_list,sizeof(m_obj_settings_t)*(idx_max+1));
+  VAL(dst) = obj_list;
+
+  return 1;
+}
+
+static int parse_obj_settings_list(m_option_t* opt,char *name,
+				   char *param, void* dst, int src) {
+  int n = 0,r,len = strlen(opt->name);
+  char *str;
+  char *ptr, *last_ptr;
+  m_obj_settings_t *res = NULL,*queue = NULL,*head = NULL;
+  int op = OP_NONE;
+
+  // We need the objects list
+  if(!opt->priv)
+    return M_OPT_INVALID;
+
+  if(opt->name[len-1] == '*' && ((int)strlen(name) > len - 1)) {
+    char* n = &name[len-1];
+    if(strcasecmp(n,"-add") == 0)
+      op = OP_ADD;
+    else if(strcasecmp(n,"-pre") == 0)
+      op = OP_PRE;
+    else if(strcasecmp(n,"-del") == 0)
+      op = OP_DEL;
+    else if(strcasecmp(n,"-clr") == 0)
+      op = OP_CLR;
+    else {
+      char prefix[len];
+      strncpy(prefix,opt->name,len-1);
+      prefix[len-1] = '\0';
+      mp_msg(MSGT_VFILTER,MSGL_ERR, "Option %s: unknown postfix %s\n"
+	     "Supported postfixes are:\n"
+	     "  %s-add\n"
+	     " Append the given list to the current list\n\n"
+	     "  %s-pre\n"
+	     " Prepend the given list to the current list\n\n"
+	     "  %s-del x,y,...\n"
+	     " Remove the given elements. Take the list element index (starting from 0).\n"
+	     " Negative index can be used (i.e. -1 is the last element)\n\n"
+	     "  %s-clr\n"
+	     " Clear the current list.\n",name,n,prefix,prefix,prefix,prefix);
+      
+      return M_OPT_UNKNOWN;
+    }
+  }
+
+  // Clear the list ??
+  if(op == OP_CLR) {
+    if(dst)
+      free_obj_settings_list(dst);
+    return 0;
+  }
+
+  if (param == NULL || strlen(param) == 0)
+    return M_OPT_MISSING_PARAM;
+
+  switch(op) {
+  case OP_ADD:
+    if(dst) head = VAL(dst);
+    break;
+  case OP_PRE:
+    if(dst) queue = VAL(dst);
+     break;
+  case OP_DEL:
+    return obj_settings_list_del(name,param,dst,src);
+  case OP_NONE:
+    if(dst && VAL(dst))
+      free_obj_settings_list(dst);
+    break;
+  default:
+    mp_msg(MSGT_VFILTER,MSGL_ERR, "Option %s: FIXME\n",name);
+    return M_OPT_UNKNOWN;
+  }
+
+  if(!strcmp(param,"help")) {
+    m_obj_list_t* ol = opt->priv;
+    for(n = 0 ; ol->list[n] ; n++)
+      mp_msg(MSGT_VFILTER,MSGL_INFO,"  %-15s: %s\n",
+	     M_ST_MB(char*,ol->list[n],ol->name_off),
+	     M_ST_MB(char*,ol->list[n],ol->info_off));
+    return M_OPT_EXIT;
+  }
+  ptr = str = strdup(param);
+
+  while(ptr[0] != '\0') {
+    last_ptr = ptr;
+    ptr = strchr(ptr,LIST_SEPARATOR);
+    if(!ptr) {
+      r = parse_obj_settings(name,last_ptr,opt->priv,dst ? &res : NULL,n);
+      if(r < 0) {
+	free(str);
+	return r;
+      }
+      n++;
+      break;
+    }
+    ptr[0] = '\0';
+    r = parse_obj_settings(name,last_ptr,opt->priv,dst ? &res : NULL,n);
+    if(r < 0) {
+      free(str);
+      return r;
+    }
+    ptr++;
+    n++;
+  }
+  free(str);
+  if(n == 0)
+    return M_OPT_INVALID;
+
+  if( ((opt->flags & M_OPT_MIN) && (n < opt->min)) || 
+      ((opt->flags & M_OPT_MAX) && (n > opt->max)) )
+    return M_OPT_OUT_OF_RANGE;
+  
+  if(dst) {
+    if(queue) {
+      int qsize;
+      for(qsize = 0 ; queue[qsize].name ; qsize++)
+	/* NOP */;
+      res = realloc(res,(qsize+n+1)*sizeof(m_obj_settings_t));
+      memcpy(&res[n],queue,(qsize+1)*sizeof(m_obj_settings_t));
+      n += qsize;
+      free(queue);
+    }
+    if(head) {
+      int hsize;
+      for(hsize = 0 ; head[hsize].name ; hsize++)
+	/* NOP */;
+      head = realloc(head,(hsize+n+1)*sizeof(m_obj_settings_t));
+      memcpy(&head[hsize],res,(n+1)*sizeof(m_obj_settings_t));
+      free(res);
+      res = head;
+    }      
+    VAL(dst) = res;
+  }
+  return 1;
+}
+
+static void free_obj_settings_list(void* dst) {
+  int n;
+  m_obj_settings_t *d;
+
+  if(!dst || !VAL(dst)) return;
+
+  d = VAL(dst);
+#ifndef NO_FREE
+  for(n = 0 ; d[n].name ; n++) {
+    free(d[n].name);
+    free_str_list(&(d[n].attribs));
+  }
+  free(d);
+#endif
+  VAL(dst) = NULL;
+}
+
+static void copy_obj_settings_list(m_option_t* opt,void* dst, void* src) {
+  m_obj_settings_t *d,*s;
+  int n;
+
+  if(!(dst && src))
+    return;
+
+  s = VAL(src);
+
+  if(VAL(dst))
+    free_obj_settings_list(dst);
+  if(!s) return;
+    
+    
+  
+  for(n = 0 ; s[n].name ; n++)
+    /* NOP */;
+  d = malloc((n+1)*sizeof(m_obj_settings_t));
+  for(n = 0 ; s[n].name ; n++) {
+    d[n].name = strdup(s[n].name);
+    d[n].attribs = NULL;
+    copy_str_list(NULL,&(d[n].attribs),&(s[n].attribs));
+  }
+  d[n].name = NULL;
+  d[n].attribs = NULL;
+  VAL(dst) = d;
+}
+
+m_option_type_t m_option_type_obj_settings_list = {
+  "Object settings list",
+  "",
+  sizeof(m_obj_settings_t*),
+  M_OPT_TYPE_DYNAMIC|M_OPT_TYPE_ALLOW_WILDCARD,
+  parse_obj_settings_list,
+  NULL,
+  copy_obj_settings_list,
+  copy_obj_settings_list,
+  copy_obj_settings_list,
+  free_obj_settings_list,
+};
+
+
+
+static int parse_obj_presets(m_option_t* opt,char *name,
+			    char *param, void* dst, int src) {
+  m_obj_presets_t* obj_p = (m_obj_presets_t*)opt->priv;
+  m_struct_t *in_desc,*out_desc;
+  int s,i;
+  unsigned char* pre = obj_p->presets;
+  char* pre_name = NULL;
+
+  if(!obj_p) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Presets need a pointer to a m_obj_presets_t in the priv field.\n",name);
+    return M_OPT_PARSER_ERR;
+  }
+
+  if(!param)
+    return M_OPT_MISSING_PARAM;
+
+  in_desc = obj_p->in_desc;
+  out_desc = obj_p->out_desc ? obj_p->out_desc : obj_p->in_desc;
+  s = in_desc->size;
+
+  if(!strcmp(param,"help")) {
+    mp_msg(MSGT_CFGPARSER, MSGL_INFO, "Available presets for %s->%s:",out_desc->name,name);
+    for(pre = obj_p->presets;(pre_name = M_ST_MB(char*,pre,obj_p->name_off)) ; 
+	pre +=  s) 
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, " %s",pre_name);
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "\n");
+    return M_OPT_EXIT;
+  }
+
+  for(pre_name = M_ST_MB(char*,pre,obj_p->name_off) ; pre_name ;
+      pre +=  s, pre_name = M_ST_MB(char*,pre,obj_p->name_off)) {
+    if(!strcmp(pre_name,param)) break;
+  }
+  if(!pre_name) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: There is no preset named %s\n"
+	   "Available presets are:",name,param);
+    for(pre = obj_p->presets;(pre_name = M_ST_MB(char*,pre,obj_p->name_off)) ; 
+	pre +=  s) 
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, " %s",pre_name);
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "\n");
+    return M_OPT_INVALID;
+  }
+
+  if(!dst) return 1;
+  
+  for(i = 0 ; in_desc->fields[i].name ; i++) {
+    m_option_t* out_opt = m_option_list_find(out_desc->fields,
+					     in_desc->fields[i].name);
+    if(!out_opt) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Unable to find the target option for field %s.\nPlease report this to the developers.\n",name,in_desc->fields[i].name);
+      return M_OPT_PARSER_ERR;
+    }
+    m_option_copy(out_opt,M_ST_MB_P(dst,out_opt->p),M_ST_MB_P(pre,in_desc->fields[i].p));
+  }
+  return 1;
+}
+
+
+m_option_type_t m_option_type_obj_presets = {
+  "Object presets",
+  "",
+  0,
+  0,
+  parse_obj_presets,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+};
+
+static int parse_custom_url(m_option_t* opt,char *name,
+			    char *url, void* dst, int src) {
+  int pos1, pos2, r, v6addr = 0;
+  char *ptr1=NULL, *ptr2=NULL, *ptr3=NULL, *ptr4=NULL;
+  m_struct_t* desc = opt->priv;
+  
+  if(!desc) {
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Custom URL needs a pointer to a m_struct_t in the priv field.\n",name);
+    return M_OPT_PARSER_ERR;
+  }
+
+  // extract the protocol
+  ptr1 = strstr(url, "://");
+  if( ptr1==NULL ) {
+    // Filename only
+    if(m_option_list_find(desc->fields,"filename")) {
+      m_struct_set(desc,dst,"filename",url);
+      return 1;
+    }
+    mp_msg(MSGT_CFGPARSER, MSGL_ERR,"Option %s: URL doesn't have a valid protocol!\n",name);
+    return M_OPT_INVALID;
+  }
+  pos1 = ptr1-url;
+  if(dst && m_option_list_find(desc->fields,"protocol")) {
+    ptr1[0] = '\0';
+    r = m_struct_set(desc,dst,"protocol",url);
+    ptr1[0] = ':';
+    if(r < 0) {
+      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while setting protocol.\n",name);
+      return r;
+    }
+  }
+
+  // jump the "://"
+  ptr1 += 3;
+  pos1 += 3;
+
+  // check if a username:password is given
+  ptr2 = strstr(ptr1, "@");
+  ptr3 = strstr(ptr1, "/");
+  if( ptr3!=NULL && ptr3<ptr2 ) {
+    // it isn't really a username but rather a part of the path
+    ptr2 = NULL;
+  }
+  if( ptr2!=NULL ) {
+    
+    // We got something, at least a username...
+    int len = ptr2-ptr1;
+    if(!m_option_list_find(desc->fields,"username")) {
+      mp_msg(MSGT_CFGPARSER, MSGL_WARN, "Option %s: This URL doesn't have a username part.\n",name);
+      // skip
+    } else {
+      ptr3 = strstr(ptr1, ":");
+      if( ptr3!=NULL && ptr3<ptr2 ) {
+	// We also have a password
+	int len2 = ptr2-ptr3-1;
+	if(!m_option_list_find(desc->fields,"password")) {
+	  mp_msg(MSGT_CFGPARSER, MSGL_WARN, "Option %s: This URL doesn't have a password part.\n",name);
+	  // skip
+	} else { // Username and password   
+	  if(dst) {
+	    ptr3[0] = '\0';
+	    r = m_struct_set(desc,dst,"username",ptr1);
+	    ptr3[0] = ':';
+	    if(r < 0) {
+	      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while setting username.\n",name);
+	      return r;
+	    }
+	    ptr2[0] = '\0';
+	    r = m_struct_set(desc,dst,"password",ptr3+1);
+	    ptr2[0] = '@';
+	    if(r < 0) {
+	      mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while setting password.\n",name);
+	      return r;
+	    }
+	  }
+	}
+      } else { // User name only
+	ptr2[0] = '\0';
+	r = m_struct_set(desc,dst,"username",ptr1);
+	ptr2[0] = '@';
+	if(r < 0) {
+	  mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while setting username.\n",name);
+	  return r;
+	}
+      }
+    }
+    ptr1 = ptr2+1;
+    pos1 = ptr1-url;
+  }
+
+  // before looking for a port number check if we have an IPv6 type numeric address
+  // in an IPv6 URL the numeric address should be inside square braces.
+  ptr2 = strstr(ptr1, "[");
+  ptr3 = strstr(ptr1, "]");
+  // If the [] is after the first it isn't the hostname
+  ptr4 = strstr(ptr1, "/");
+  if( ptr2!=NULL && ptr3!=NULL && (ptr2 < ptr3) && (!ptr4 || ptr4 > ptr3)) {
+    // we have an IPv6 numeric address
+    ptr1++;
+    pos1++;
+    ptr2 = ptr3;
+    v6addr = 1;
+  } else {
+    ptr2 = ptr1;  
+  }
+
+  // look if the port is given
+  ptr2 = strstr(ptr2, ":");
+  // If the : is after the first / it isn't the port
+  ptr3 = strstr(ptr1, "/");
+  if(ptr3 && ptr3 - ptr2 < 0) ptr2 = NULL;
+  if( ptr2==NULL ) {
+    // No port is given
+    // Look if a path is given
+    if( ptr3==NULL ) {
+      // No path/filename
+      // So we have an URL like http://www.hostname.com
+      pos2 = strlen(url);
+    } else {
+      // We have an URL like http://www.hostname.com/file.txt
+      pos2 = ptr3-url;
+    }
+  } else {
+    // We have an URL beginning like http://www.hostname.com:1212
+    // Get the port number
+    if(!m_option_list_find(desc->fields,"port")) {
+      mp_msg(MSGT_CFGPARSER, MSGL_WARN, "Option %s: This URL doesn't have a port part.\n",name);
+      // skip
+    } else {
+      if(dst) {
+	int p = atoi(ptr2+1);
+	char tmp[100];
+	snprintf(tmp,99,"%d",p);
+	r = m_struct_set(desc,dst,"port",tmp);
+	if(r < 0) {
+	  mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while setting port.\n",name);
+	  return r;
+	}
+      }
+    }
+    pos2 = ptr2-url;
+  }
+  if( v6addr ) pos2--;
+  // Get the hostname
+  if(pos2-pos1 > 0) {
+    if(!m_option_list_find(desc->fields,"hostname")) {
+      mp_msg(MSGT_CFGPARSER, MSGL_WARN, "Option %s: This URL doesn't have a hostname part.\n",name);
+      // skip
+    } else {
+      char tmp[pos2-pos1+1];
+      strncpy(tmp,ptr1, pos2-pos1);
+      tmp[pos2-pos1] = '\0';
+      r = m_struct_set(desc,dst,"hostname",tmp);
+      if(r < 0) {
+	mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while setting hostname.\n",name);
+	return r;
+      }
+    }
+  }
+  // Look if a path is given
+  ptr2 = strstr(ptr1, "/");
+  if( ptr2!=NULL ) {
+    // A path/filename is given
+    // check if it's not a trailing '/'
+    if( strlen(ptr2)>1 ) {
+      // copy the path/filename in the URL container
+      if(!m_option_list_find(desc->fields,"filename")) {
+	mp_msg(MSGT_CFGPARSER, MSGL_WARN, "Option %s: This URL doesn't have a hostname part.\n",name);
+	// skip
+      } else {
+	if(dst) {
+	  int l = strlen(ptr2+1) + 1;
+	  char* fname = ptr2+1;
+	  if(l > 1) {
+	    fname = malloc(l);
+	    url_unescape_string(fname,ptr2+1);
+	  }
+	  r = m_struct_set(desc,dst,"filename",fname);
+	  if(fname != ptr2+1)
+	    free(fname);
+	  if(r < 0) {
+	    mp_msg(MSGT_CFGPARSER, MSGL_ERR, "Option %s: Error while setting filename.\n",name);
+	    return r;
+	  }
+	}
+      }
+    }
+  }
+  return 1;
+}
+
+/// TODO : Write the other needed funcs for 'normal' options
+m_option_type_t m_option_type_custom_url = {
+  "Custom URL",
+  "",
+  0,
+  0,
+  parse_custom_url,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+};	
diff -urN MPlayer-1.0pre5.orig/mplayer.c MPlayer-1.0pre5/mplayer.c
--- MPlayer-1.0pre5.orig/mplayer.c	2004-07-14 16:25:47 +0700
+++ MPlayer-1.0pre5/mplayer.c	2004-08-08 10:36:04 +0700
@@ -1685,7 +1685,7 @@
   if (sh_video) {
     /* Assume FOURCC if all bytes >= 0x20 (' ') */
     if (sh_video->format >= 0x20202020)
-	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_FORMAT=%.4s\n", &sh_video->format);
+	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_FORMAT=%.4s\n", (char *)&sh_video->format);
     else
 	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_FORMAT=0x%08X\n", sh_video->format);
     mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_BITRATE=%d\n", sh_video->i_bps*8);
@@ -1699,7 +1699,7 @@
       mp_msg(MSGT_GLOBAL,MSGL_INFO, "ID_AUDIO_CODEC=%s\n", sh_audio->codec->name);
     /* Assume FOURCC if all bytes >= 0x20 (' ') */
     if (sh_audio->format >= 0x20202020)
-      mp_msg(MSGT_GLOBAL,MSGL_INFO, "ID_AUDIO_FORMAT=%.4s\n", &sh_audio->format);
+      mp_msg(MSGT_GLOBAL,MSGL_INFO, "ID_AUDIO_FORMAT=%.4s\n", (char *)&sh_audio->format);
     else
       mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_AUDIO_FORMAT=%d\n", sh_audio->format);
     mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_AUDIO_BITRATE=%d\n", sh_audio->i_bps*8);
@@ -3099,7 +3099,7 @@
 	{
 #ifdef USE_SUB
 	if (sh_video) {
-		mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_SUB_VISIBILITY=%ld\n", sub_visibility);
+		mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_SUB_VISIBILITY=%d\n", sub_visibility);
 	}
 #endif
 	} break;
@@ -3144,11 +3144,11 @@
 
 	case MP_CMD_GET_VO_FULLSCREEN : {
 	if(video_out && vo_config_count)
-		mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_VO_FULLSCREEN=%ld\n", vo_fs);
+		mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_VO_FULLSCREEN=%d\n", vo_fs);
 	} break;
     
     case MP_CMD_GET_PERCENT_POS : {
-	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_PERCENT_POSITION=%ld\n", demuxer_get_percent_pos(demuxer));
+	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_PERCENT_POSITION=%d\n", demuxer_get_percent_pos(demuxer));
     } break;
 
 #ifdef USE_DVDNAV
diff -urN MPlayer-1.0pre5.orig/mplayer.c.orig MPlayer-1.0pre5/mplayer.c.orig
--- MPlayer-1.0pre5.orig/mplayer.c.orig	1970-01-01 07:00:00 +0700
+++ MPlayer-1.0pre5/mplayer.c.orig	2004-07-14 16:25:47 +0700
@@ -0,0 +1,3804 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "config.h"
+
+#ifdef WIN32
+#define _UWIN 1  /*disable Non-underscored versions of non-ANSI functions as otherwise int eof would conflict with eof()*/
+#include <windows.h>
+#endif
+#include <string.h>
+#include <unistd.h>
+
+// #include <sys/mman.h>
+#include <sys/types.h>
+#ifndef __MINGW32__
+#include <sys/ioctl.h>
+#include <sys/wait.h>
+#else
+#define	SIGHUP	1	/* hangup */
+#define	SIGQUIT	3	/* quit */
+#define	SIGKILL	9	/* kill (cannot be caught or ignored) */
+#define	SIGBUS	10	/* bus error */
+extern int mp_input_win32_slave_cmd_func(int fd,char* dest,int size);
+#endif
+
+#include <sys/time.h>
+#include <sys/stat.h>
+
+#include <signal.h>
+#include <time.h>
+#include <fcntl.h>
+#include <limits.h>
+
+#include <errno.h>
+
+#include "version.h"
+
+#include "mp_msg.h"
+
+#define HELP_MP_DEFINE_STATIC
+#include "help_mp.h"
+
+#include "m_option.h"
+#include "m_config.h"
+
+#include "cfg-mplayer-def.h"
+
+#ifdef USE_SUB
+#include "subreader.h"
+#endif
+
+#include "libvo/video_out.h"
+
+#include "libvo/font_load.h"
+#include "libvo/sub.h"
+
+#ifdef HAVE_X11
+#include "libvo/x11_common.h"
+#endif
+
+#include "libao2/audio_out.h"
+#include "libao2/audio_plugin.h"
+
+#include "codec-cfg.h"
+
+#ifdef USE_DVDNAV
+#include <dvdnav.h>
+#endif
+
+#ifdef USE_EDL
+#include "edl.h"
+#endif
+
+#include "spudec.h"
+#include "vobsub.h"
+
+#include "osdep/getch2.h"
+#include "osdep/timer.h"
+
+#include "cpudetect.h"
+
+#ifdef HAVE_NEW_GUI
+#include "Gui/interface.h"
+#endif
+
+#include "input/input.h"
+
+int slave_mode=0;
+int verbose=0;
+int identify=0;
+int quiet=0;
+
+#define ABS(x) (((x)>=0)?(x):(-(x)))
+#define ROUND(x) ((int)((x)<0 ? (x)-0.5 : (x)+0.5))
+
+#ifdef HAVE_RTC
+#include <linux/rtc.h>
+#endif
+
+#ifdef USE_TV
+#include "libmpdemux/tv.h"
+#endif
+
+#ifdef HAS_DVBIN_SUPPORT
+#include "libmpdemux/dvbin.h"
+static int last_dvb_step = 1;
+#endif
+
+#ifdef HAVE_MATROSKA
+#include "libmpdemux/matroska.h"
+#endif
+
+//**************************************************************************//
+//             Playtree
+//**************************************************************************//
+#include "playtree.h"
+#include "playtreeparser.h"
+
+#ifdef HAVE_NEW_GUI
+extern int import_playtree_playlist_into_gui(play_tree_t* my_playtree, m_config_t* config);
+extern int import_initial_playtree_into_gui(play_tree_t* my_playtree, m_config_t* config, int enqueue);
+#endif
+
+play_tree_t* playtree;
+play_tree_iter_t* playtree_iter = NULL;
+
+#define PT_NEXT_ENTRY 1
+#define PT_PREV_ENTRY -1
+#define PT_NEXT_SRC 2
+#define PT_PREV_SRC -2
+#define PT_UP_NEXT 3
+#define PT_UP_PREV -3
+
+//**************************************************************************//
+//             Config
+//**************************************************************************//
+m_config_t* mconfig;
+
+extern play_tree_t*
+m_config_parse_mp_command_line(m_config_t *config, int argc, char **argv);
+extern int
+m_config_parse_config_file(m_config_t* config, char *conffile);
+
+//**************************************************************************//
+//             Config file
+//**************************************************************************//
+
+static int cfg_inc_verbose(m_option_t *conf){ ++verbose; return 0;}
+
+static int cfg_include(m_option_t *conf, char *filename){
+	return m_config_parse_config_file(mconfig, filename);
+}
+
+#include "get_path.c"
+
+//**************************************************************************//
+//             XScreensaver
+//**************************************************************************//
+
+#ifdef HAVE_X11
+void xscreensaver_heartbeat(void);
+#endif
+
+//**************************************************************************//
+//**************************************************************************//
+//             Input media streaming & demultiplexer:
+//**************************************************************************//
+
+static int max_framesize=0;
+
+#include "libmpdemux/stream.h"
+#include "libmpdemux/demuxer.h"
+#include "libmpdemux/stheader.h"
+//#include "parse_es.h"
+
+#include "libmpcodecs/dec_audio.h"
+#include "libmpcodecs/dec_video.h"
+#include "libmpcodecs/mp_image.h"
+#include "libmpcodecs/vf.h"
+
+extern void vf_list_plugins();
+
+//**************************************************************************//
+//**************************************************************************//
+
+// Common FIFO functions, and keyboard/event FIFO code
+#include "fifo.c"
+int noconsolecontrols=0;
+//**************************************************************************//
+
+vo_functions_t *video_out=NULL;
+ao_functions_t *audio_out=NULL;
+
+int fixed_vo=0;
+int eof=0;
+
+// benchmark:
+double video_time_usage=0;
+double vout_time_usage=0;
+static double audio_time_usage=0;
+static int total_time_usage_start=0;
+static int total_frame_cnt=0;
+static int drop_frame_cnt=0; // total number of dropped frames
+int benchmark=0;
+
+// options:
+       int auto_quality=0;
+static int output_quality=0;
+
+float playback_speed=1.0;
+
+int use_gui=0;
+
+#ifdef HAVE_NEW_GUI
+int enqueue=0;
+#endif
+
+#define MAX_OSD_LEVEL 3
+
+int osd_level=1;
+int osd_level_saved=-1;
+int osd_visible=100;
+
+// seek:
+static char *seek_to_sec=NULL;
+static off_t seek_to_byte=0;
+static off_t step_sec=0;
+static int loop_times=-1;
+static int loop_seek=0;
+
+// A/V sync:
+       int autosync=0; // 30 might be a good default value.
+
+// may be changed by GUI:  (FIXME!)
+float rel_seek_secs=0;
+int abs_seek_pos=0;
+
+// codecs:
+char **audio_codec_list=NULL; // override audio codec
+char **video_codec_list=NULL; // override video codec
+char **audio_fm_list=NULL;    // override audio codec family 
+char **video_fm_list=NULL;    // override video codec family 
+
+// streaming:
+int audio_id=-1;
+int video_id=-1;
+int dvdsub_id=-1;
+int vobsub_id=-1;
+char* audio_lang=NULL;
+char* dvdsub_lang=NULL;
+static char* spudec_ifo=NULL;
+char* filename=NULL; //"MI2-Trailer.avi";
+int forced_subs_only=0;
+
+// cache2:
+       int stream_cache_size=-1;
+#ifdef USE_STREAM_CACHE
+extern int cache_fill_status;
+#else
+#define cache_fill_status 0
+#endif
+
+// dump:
+static char *stream_dump_name="stream.dump";
+       int stream_dump_type=0;
+
+// A-V sync:
+static float default_max_pts_correction=-1;//0.01f;
+static float max_pts_correction=0;//default_max_pts_correction;
+static float c_total=0;
+       float audio_delay=0;
+
+static int softsleep=0;
+
+       float force_fps=0;
+static int force_srate=0;
+static int audio_output_format=0;
+       int frame_dropping=0; // option  0=no drop  1= drop vo  2= drop decode
+static int play_n_frames=-1;
+static int play_n_frames_mf=-1;
+
+// screen info:
+char** video_driver_list=NULL;
+char** audio_driver_list=NULL;
+
+extern char *vo_subdevice;
+extern char *ao_subdevice;
+
+// codec outfmt flags (defined in libmpcodecs/vd.c)
+extern int vo_flags;
+
+// sub:
+char *font_name=NULL;
+#ifdef HAVE_FONTCONFIG
+extern int font_fontconfig;
+#endif
+float font_factor=0.75;
+char **sub_name=NULL;
+float sub_delay=0;
+float sub_fps=0;
+int   sub_auto = 1;
+char *vobsub_name=NULL;
+/*DSP!!char *dsp=NULL;*/
+int   subcc_enabled=0;
+int suboverlap_enabled = 1;
+#ifdef USE_SUB
+sub_data* set_of_subtitles[MAX_SUBTITLE_FILES];
+int set_of_sub_size = 0;
+int set_of_sub_pos = -1;
+float sub_last_pts = -303;
+#endif
+
+static stream_t* stream=NULL;
+static demuxer_t *demuxer=NULL;
+static sh_audio_t *sh_audio=NULL;
+static sh_video_t *sh_video=NULL;
+
+char* current_module=NULL; // for debugging
+
+// also modified by Gui/mplayer/gtk/eq.c:
+int vo_gamma_gamma = 1000;
+int vo_gamma_brightness = 1000;
+int vo_gamma_contrast = 1000;
+int vo_gamma_saturation = 1000;
+int vo_gamma_hue = 1000;
+
+// ---
+
+#ifdef HAVE_MENU
+#include "m_struct.h"
+#include "libmenu/menu.h"
+extern void vf_menu_pause_update(struct vf_instance_s* vf);
+extern vf_info_t vf_info_menu;
+static vf_info_t* libmenu_vfs[] = {
+  &vf_info_menu,
+  NULL
+};
+static vf_instance_t* vf_menu = NULL;
+static int use_menu = 0;
+static char* menu_cfg = NULL;
+static char* menu_root = "main";
+#endif
+
+
+#ifdef HAVE_RTC
+static int nortc;
+static char* rtc_device;
+#endif
+
+#ifdef USE_EDL
+struct edl_record edl_records[ MAX_EDL_ENTRIES ];
+int num_edl_records = 0;
+FILE* edl_fd = NULL;
+edl_record_ptr next_edl_record = NULL;
+static char* edl_filename = NULL;
+static char* edl_output_filename = NULL;
+short edl_decision = 0;
+#endif
+
+static unsigned int inited_flags=0;
+#define INITED_VO 1
+#define INITED_AO 2
+#define INITED_GUI 4
+#define INITED_GETCH2 8
+#define INITED_SPUDEC 32
+#define INITED_STREAM 64
+#define INITED_INPUT    128
+#define INITED_VOBSUB  256
+#define INITED_DEMUXER 512
+#define INITED_ACODEC  1024
+#define INITED_VCODEC  2048
+#define INITED_ALL 0xFFFF
+
+static void uninit_player(unsigned int mask){
+  mask=inited_flags&mask;
+
+  mp_msg(MSGT_CPLAYER,MSGL_DBG2,"\n*** uninit(0x%X)\n",mask);
+
+  if(mask&INITED_ACODEC){
+    inited_flags&=~INITED_ACODEC;
+    current_module="uninit_acodec";
+    if(sh_audio) uninit_audio(sh_audio);
+    sh_audio=NULL;
+  }
+
+  if(mask&INITED_VCODEC){
+    inited_flags&=~INITED_VCODEC;
+    current_module="uninit_vcodec";
+    if(sh_video) uninit_video(sh_video);
+    sh_video=NULL;
+#ifdef HAVE_MENU
+    vf_menu=NULL;
+#endif
+  }
+ 
+  if(mask&INITED_DEMUXER){
+    inited_flags&=~INITED_DEMUXER;
+    current_module="free_demuxer";
+    if(demuxer){
+	stream=demuxer->stream;
+	free_demuxer(demuxer);
+    }
+    demuxer=NULL;
+  }
+
+  // kill the cache process:
+  if(mask&INITED_STREAM){
+    inited_flags&=~INITED_STREAM;
+    current_module="uninit_stream";
+    if(stream) free_stream(stream);
+    stream=NULL;
+  }
+
+  if(mask&INITED_VO){
+    inited_flags&=~INITED_VO;
+    current_module="uninit_vo";
+    video_out->uninit();
+    video_out=NULL;
+  }
+
+  // must be after libvo uninit, as few vo drivers (svgalib) has tty code
+  if(mask&INITED_GETCH2){
+    inited_flags&=~INITED_GETCH2;
+    current_module="uninit_getch2";
+    mp_msg(MSGT_CPLAYER,MSGL_DBG2,"\n[[[uninit getch2]]]\n");
+  // restore terminal:
+    getch2_disable();
+  }
+
+  if(mask&INITED_VOBSUB){
+    inited_flags&=~INITED_VOBSUB;
+    current_module="uninit_vobsub";
+    if(vo_vobsub) vobsub_close(vo_vobsub);
+    vo_vobsub=NULL;
+  }
+
+  if (mask&INITED_SPUDEC){
+    inited_flags&=~INITED_SPUDEC;
+    current_module="uninit_spudec";
+    spudec_free(vo_spudec);
+    vo_spudec=NULL;
+  }
+
+  if(mask&INITED_AO){
+    inited_flags&=~INITED_AO;
+    current_module="uninit_ao";
+    audio_out->uninit(eof?0:1); audio_out=NULL;
+  }
+
+#ifdef HAVE_NEW_GUI
+  if(mask&INITED_GUI){
+    inited_flags&=~INITED_GUI;
+    current_module="uninit_gui";
+    guiDone();
+  }
+#endif
+
+  if(mask&INITED_INPUT){
+    inited_flags&=~INITED_INPUT;
+    current_module="uninit_input";
+    mp_input_uninit();
+  }
+
+  current_module=NULL;
+}
+
+static void exit_player_with_rc(char* how, int rc){
+
+  uninit_player(INITED_ALL);
+#ifdef HAVE_X11
+#ifdef HAVE_NEW_GUI
+  if ( !use_gui )
+#endif
+  vo_uninit();	// close the X11 connection (if any opened)
+#endif
+
+  current_module="exit_player";
+
+  if(how) mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_Exiting,mp_gettext(how));
+  mp_msg(MSGT_CPLAYER,MSGL_DBG2,"max framesize was %d bytes\n",max_framesize);
+
+  exit(rc);
+}
+
+void exit_player(char* how){
+  exit_player_with_rc(how, 1);
+}
+
+static void exit_sighandler(int x){
+  static int sig_count=0;
+  ++sig_count;
+  if(sig_count==5 || (inited_flags==0 && sig_count>1)) exit(1);
+  if(sig_count>5){
+    // can't stop :(
+#ifndef __MINGW32__
+    kill(getpid(),SIGKILL);
+#endif
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_FATAL,"\n" MSGTR_IntBySignal,x,
+      current_module?current_module:mp_gettext("unknown")
+  );
+  if(sig_count==1)
+  switch(x){
+  case SIGINT:
+  case SIGQUIT:
+  case SIGTERM:
+  case SIGKILL:
+      break;  // killed from keyboard (^C) or killed [-9]
+  case SIGILL:
+#ifdef RUNTIME_CPUDETECT
+      mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_Exit_SIGILL_RTCpuSel);
+#else
+      mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_Exit_SIGILL);
+#endif
+  case SIGFPE:
+  case SIGSEGV:
+      mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_Exit_SIGSEGV_SIGFPE);
+  default:
+      mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_Exit_SIGCRASH);
+  }
+  exit_player(NULL);
+}
+
+//extern void write_avi_header_1(FILE *f,int fcc,float fps,int width,int height);
+
+extern void mp_input_register_options(m_config_t* cfg);
+
+#include "mixer.h"
+mixer_t mixer;
+
+#include "cfg-mplayer.h"
+
+void parse_cfgfiles( m_config_t* conf )
+{
+char *conffile;
+int conffile_fd;
+if (m_config_parse_config_file(conf, MPLAYER_CONFDIR "/mplayer.conf") < 0)
+  exit(1);
+if ((conffile = get_path("")) == NULL) {
+  mp_msg(MSGT_CPLAYER,MSGL_WARN,MSGTR_NoHomeDir);
+} else {
+#ifdef __MINGW32__
+  mkdir(conffile);
+#else
+  mkdir(conffile, 0777);
+#endif
+  free(conffile);
+  if ((conffile = get_path("config")) == NULL) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_GetpathProblem);
+  } else {
+    if ((conffile_fd = open(conffile, O_CREAT | O_EXCL | O_WRONLY, 0666)) != -1) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_CreatingCfgFile, conffile);
+      write(conffile_fd, default_config, strlen(default_config));
+      close(conffile_fd);
+    }
+    if (m_config_parse_config_file(conf, conffile) < 0)
+      exit(1);
+    free(conffile);
+  }
+}
+}
+
+void load_per_file_config (m_config_t* conf, const char *const file)
+{
+    char *confpath;
+    char cfg[strlen(file)+10];
+    struct stat st;
+    char *name;
+
+    sprintf (cfg, "%s.conf", file);
+    
+    if (!stat (cfg, &st))
+    {
+	mp_msg(MSGT_CPLAYER,MSGL_INFO,"Loading config '%s'\n", cfg);
+	m_config_parse_config_file (conf, cfg);
+	return;
+    }
+
+    if ((name = strrchr (cfg, '/')) == NULL)
+	name = cfg;
+    else
+	name++;
+
+    if ((confpath = get_path (name)) != NULL)
+    {
+	if (!stat (confpath, &st))
+	{
+	    mp_msg(MSGT_CPLAYER,MSGL_INFO,"Loading config '%s'\n", confpath);
+	    m_config_parse_config_file (conf, confpath);
+	}
+
+	free (confpath);
+    }
+}
+
+// When libmpdemux perform a blocking operation (network connection or cache filling)
+// if the operation fail we use this function to check if it was interrupted by the user.
+// The function return a new value for eof.
+static int libmpdemux_was_interrupted(int eof) {
+  mp_cmd_t* cmd;
+  if((cmd = mp_input_get_cmd(0,0)) != NULL) {
+       switch(cmd->id) {
+       case MP_CMD_QUIT:
+	 exit_player_with_rc(MSGTR_Exit_quit, 0);
+       case MP_CMD_PLAY_TREE_STEP: {
+	 eof = (cmd->args[0].v.i > 0) ? PT_NEXT_ENTRY : PT_PREV_ENTRY;
+       } break;
+       case MP_CMD_PLAY_TREE_UP_STEP: {
+	 eof = (cmd->args[0].v.i > 0) ? PT_UP_NEXT : PT_UP_PREV;
+       } break;	  
+       case MP_CMD_PLAY_ALT_SRC_STEP: {
+	 eof = (cmd->args[0].v.i > 0) ?  PT_NEXT_SRC : PT_PREV_SRC;
+       } break;
+       }
+       mp_cmd_free(cmd);
+  }
+  return eof;
+}
+
+#define mp_basename(s) (strrchr(s,'/')==NULL?(char*)s:(strrchr(s,'/')+1))
+
+int playtree_add_playlist(play_tree_t* entry)
+{
+  play_tree_add_bpf(entry,filename);
+
+#ifdef HAVE_NEW_GUI
+  if (use_gui) {
+    if (entry) {
+      import_playtree_playlist_into_gui(entry, mconfig);
+      play_tree_free_list(entry,1);
+    }
+  } else
+#endif
+  {
+  if(!entry) {      
+    entry = playtree_iter->tree;
+    if(play_tree_iter_step(playtree_iter,1,0) != PLAY_TREE_ITER_ENTRY) {
+        return PT_NEXT_ENTRY;
+    }
+    if(playtree_iter->tree == entry ) { // Loop with a single file
+      if(play_tree_iter_up_step(playtree_iter,1,0) != PLAY_TREE_ITER_ENTRY) {
+	return PT_NEXT_ENTRY;
+      }
+    }
+    play_tree_remove(entry,1,1);
+    return PT_NEXT_SRC;
+  }
+  play_tree_insert_entry(playtree_iter->tree,entry);
+  play_tree_set_params_from(entry,playtree_iter->tree);
+  entry = playtree_iter->tree;
+  if(play_tree_iter_step(playtree_iter,1,0) != PLAY_TREE_ITER_ENTRY) {
+    return PT_NEXT_ENTRY;
+  }      
+  play_tree_remove(entry,1,1);
+  }
+  return PT_NEXT_SRC;
+}
+
+static int play_tree_step = 1;
+
+#ifdef USE_SUB
+
+sub_data* subdata = NULL;
+
+void add_subtitles(char *filename, float fps, int silent)
+{
+    sub_data *subd;
+
+    if (filename == NULL) {
+	subd = (sub_data*)malloc(sizeof(sub_data));
+	subd->filename = strdup("none");
+	subd->subtitles = NULL;
+	subd->sub_uses_time = 1;
+	subd->sub_num = 0;
+	subd->sub_errs = 0;
+	set_of_subtitles[set_of_sub_size] = subd;
+	++set_of_sub_size;
+	return;
+    }
+
+    subd = sub_read_file(filename, fps);
+    if(!subd && !silent) 
+        mp_msg(MSGT_CPLAYER, MSGL_ERR, MSGTR_CantLoadSub, filename);
+    if (subd == NULL || set_of_sub_size >= MAX_SUBTITLE_FILES) return;
+    set_of_subtitles[set_of_sub_size] = subd;
+    ++set_of_sub_size;
+    printf("SUB: added subtitle file (%d): %s\n", set_of_sub_size, filename);
+}
+
+void update_set_of_subtitles()
+    // subdata was changed, set_of_sub... have to be updated.
+{
+    int i;
+    if (set_of_sub_size > 0 && subdata == NULL) { // *subdata was deleted
+        for (i = set_of_sub_pos + 1; i < set_of_sub_size; ++i)
+            set_of_subtitles[i-1] = set_of_subtitles[i];
+        set_of_subtitles[set_of_sub_size-1] = NULL;
+        --set_of_sub_size;
+        if (set_of_sub_size > 0) subdata = set_of_subtitles[set_of_sub_pos=0];
+    }
+    else if (set_of_sub_size > 0 && subdata != NULL) { // *subdata was changed
+        set_of_subtitles[set_of_sub_pos] = subdata;
+    }
+    else if (set_of_sub_size <= 0 && subdata != NULL) { // *subdata was added
+        set_of_subtitles[set_of_sub_pos=set_of_sub_size] = subdata;
+        ++set_of_sub_size;
+    }
+}
+#endif
+
+/*
+ * In Mac OS X the SDL-lib is built upon Cocoa. The easiest way to
+ * make it all work is to use the builtin SDL-bootstrap code, which 
+ * will be done automatically by replacing our main() if we include SDL.h.
+ */
+#if defined(SYS_DARWIN) && defined(HAVE_SDL)
+#include <SDL.h>
+#endif
+
+
+int main(int argc,char* argv[]){
+
+
+
+static demux_stream_t *d_audio=NULL;
+static demux_stream_t *d_video=NULL;
+static demux_stream_t *d_dvdsub=NULL;
+
+int file_format=DEMUXER_TYPE_UNKNOWN;
+
+int delay_corrected=1;
+
+// movie info:
+
+int osd_function=OSD_PLAY;
+int osd_last_pts=-303;
+int osd_show_av_delay = 0;
+int osd_show_text = 0;
+int osd_show_sub_delay = 0;
+int osd_show_sub_pos = 0;
+int osd_show_sub_visibility = 0;
+int osd_show_sub_alignment = 0;
+int osd_show_vobsub_changed = 0;
+int osd_show_sub_changed = 0;
+int osd_show_percentage = 0;
+int osd_show_tv_channel = 25;
+int osd_show_ontop = 0;
+int osd_show_framedropping = 0;
+
+int rtc_fd=-1;
+
+//float a_frame=0;    // Audio
+
+int i;
+char *tmp;
+
+int gui_no_filename=0;
+
+
+  srand((int) time(NULL)); 
+
+  mp_msg_init();
+  mp_msg_set_level(MSGL_STATUS);
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "MPlayer " VERSION " (C) 2000-2004 MPlayer Team\n\n");
+  /* Test for cpu capabilities (and corresponding OS support) for optimizing */
+  GetCpuCaps(&gCpuCaps);
+#ifdef ARCH_X86
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"CPUflags:  MMX: %d MMX2: %d 3DNow: %d 3DNow2: %d SSE: %d SSE2: %d\n",
+      gCpuCaps.hasMMX,gCpuCaps.hasMMX2,
+      gCpuCaps.has3DNow, gCpuCaps.has3DNowExt,
+      gCpuCaps.hasSSE, gCpuCaps.hasSSE2);
+#ifdef RUNTIME_CPUDETECT
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_CompiledWithRuntimeDetection);
+#else
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_CompiledWithCPUExtensions);
+#ifdef HAVE_MMX
+  mp_msg(MSGT_CPLAYER,MSGL_INFO," MMX");
+#endif
+#ifdef HAVE_MMX2
+  mp_msg(MSGT_CPLAYER,MSGL_INFO," MMX2");
+#endif
+#ifdef HAVE_3DNOW
+  mp_msg(MSGT_CPLAYER,MSGL_INFO," 3DNow");
+#endif
+#ifdef HAVE_3DNOWEX
+  mp_msg(MSGT_CPLAYER,MSGL_INFO," 3DNowEx");
+#endif
+#ifdef HAVE_SSE
+  mp_msg(MSGT_CPLAYER,MSGL_INFO," SSE");
+#endif
+#ifdef HAVE_SSE2
+  mp_msg(MSGT_CPLAYER,MSGL_INFO," SSE2");
+#endif
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"\n\n");
+#endif
+#endif
+
+#if defined(WIN32) && defined(USE_WIN32DLL)
+{  /*make our codec dirs available for LoadLibraryA()*/
+  char tmppath[MAX_PATH*2 + 1];
+  char win32path[MAX_PATH];
+  char realpath[MAX_PATH];
+#ifdef __CYGWIN__
+  cygwin_conv_to_full_win32_path(WIN32_PATH,win32path);
+  strcpy(tmppath,win32path);
+#ifdef USE_REALCODECS
+  cygwin_conv_to_full_win32_path(REALCODEC_PATH,realpath);
+  sprintf(tmppath,"%s;%s",win32path,realpath);
+#endif /*USE_REALCODECS*/
+#else
+  if(!strstr(WIN32_PATH,":")){
+    GetModuleFileNameA(NULL, win32path, MAX_PATH);
+    strcpy(win32path + strlen(win32path) - strlen("mplayer.exe"), WIN32_PATH);
+  }
+  else strcpy(win32path,WIN32_PATH);
+  strcpy(tmppath,win32path);
+#ifdef USE_REALCODECS
+  if(!strstr(REALCODEC_PATH,":")){
+    GetModuleFileNameA(NULL, realpath, MAX_PATH);
+    strcpy(realpath + strlen(realpath) - strlen("mplayer.exe"), REALCODEC_PATH);
+  }
+  else strcpy(realpath,REALCODEC_PATH);
+  sprintf(tmppath,"%s;%s",win32path,realpath);
+#endif /*USE_REALCODECS*/
+#endif /*__CYGWIN__*/
+  SetEnvironmentVariableA("PATH", tmppath);
+}
+#endif /*WIN32 && USE_WIN32DLL*/
+
+#ifdef USE_TV
+  tv_param_immediate = 1;
+#endif
+
+  if ( argv[0] )
+    if(!strcmp(argv[0],"gmplayer") ||
+      (strrchr(argv[0],'/') && !strcmp(strrchr(argv[0],'/'),"/gmplayer") ) )
+          use_gui=1;
+
+    mconfig = m_config_new();
+    m_config_register_options(mconfig,mplayer_opts);
+    // TODO : add something to let modules register their options
+    mp_input_register_options(mconfig);
+    parse_cfgfiles(mconfig);
+
+#ifdef HAVE_NEW_GUI
+    if ( use_gui ) cfg_read();
+#endif
+
+    playtree = m_config_parse_mp_command_line(mconfig, argc, argv);
+    if(playtree == NULL)
+      exit(1);
+
+    playtree = play_tree_cleanup(playtree);
+    if(playtree) {
+      playtree_iter = play_tree_iter_new(playtree,mconfig);
+      if(playtree_iter) {  
+	if(play_tree_iter_step(playtree_iter,0,0) != PLAY_TREE_ITER_ENTRY) {
+	  play_tree_iter_free(playtree_iter);
+	  playtree_iter = NULL;
+	}
+	filename = play_tree_iter_get_file(playtree_iter,1);
+      }
+    }
+	
+#ifndef HAVE_NEW_GUI
+    if(use_gui){
+      mp_msg(MSGT_CPLAYER,MSGL_WARN,MSGTR_NoGui);
+      use_gui=0;
+    }
+#else
+    if(use_gui && !vo_init()){
+      mp_msg(MSGT_CPLAYER,MSGL_WARN,MSGTR_GuiNeedsX);
+      use_gui=0;
+    }
+    if (use_gui && playtree_iter){
+      char cwd[PATH_MAX+2];
+      // Remove Playtree and Playtree-Iter from memory as its not used by gui
+      play_tree_iter_free(playtree_iter);
+      playtree_iter=NULL;
+      
+      if (getcwd(cwd, PATH_MAX) != (char *)NULL)
+      {
+	  strcat(cwd, "/");
+          // Prefix relative paths with current working directory
+          play_tree_add_bpf(playtree, cwd);
+      }      
+      // Import initital playtree into gui
+      import_initial_playtree_into_gui(playtree, mconfig, enqueue);
+    }
+#endif
+
+    if(video_driver_list && strcmp(video_driver_list[0],"help")==0){
+      list_video_out();
+      exit(0);
+    }
+
+    if(audio_driver_list && strcmp(audio_driver_list[0],"help")==0){
+      list_audio_out();
+      exit(0);
+    }
+
+// check codec.conf
+if(!codecs_file || !parse_codec_cfg(codecs_file)){
+  if(!parse_codec_cfg(get_path("codecs.conf"))){
+    if(!parse_codec_cfg(MPLAYER_CONFDIR "/codecs.conf")){
+      if(!parse_codec_cfg(NULL)){
+	mp_msg(MSGT_CPLAYER,MSGL_HINT,MSGTR_CopyCodecsConf);
+	exit(0);
+      }
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_BuiltinCodecsConf);
+    }
+  }
+}
+
+#if 0
+    if(video_codec_list){
+	int i;
+	video_codec=video_codec_list[0];
+	for(i=0;video_codec_list[i];i++)
+	    printf("vc#%d: '%s'\n",i,video_codec_list[i]);
+    }
+#endif
+    if(audio_codec_list && strcmp(audio_codec_list[0],"help")==0){
+      mp_msg(MSGT_CPLAYER, MSGL_INFO, MSGTR_AvailableAudioCodecs);
+      list_codecs(1);
+      printf("\n");
+      exit(0);
+    }
+    if(video_codec_list && strcmp(video_codec_list[0],"help")==0){
+      mp_msg(MSGT_CPLAYER, MSGL_INFO, MSGTR_AvailableVideoCodecs);
+      list_codecs(0);
+      printf("\n");
+      exit(0);
+    }
+    if(video_fm_list && strcmp(video_fm_list[0],"help")==0){
+      vfm_help();
+      printf("\n");
+      exit(0);
+    }
+    if(audio_fm_list && strcmp(audio_fm_list[0],"help")==0){
+      afm_help();
+      printf("\n");
+      exit(0);
+    }
+#ifdef HAVE_X11
+    if(vo_fstype_list && strcmp(vo_fstype_list[0],"help")==0){
+      fstype_help();
+      printf("\n");
+      exit(0);
+    }
+#endif
+
+#ifdef USE_EDL
+ {
+   FILE* fd;
+   char line[ 100 ];
+   float start, stop, duration;
+   int action;
+   int next_edl_array_index = 0;
+   int lineCount = 0;
+   next_edl_record = edl_records;
+   if( edl_filename ) {
+     if( ( fd = fopen( edl_filename, "r" ) ) == NULL ) {
+       printf( "Error opening EDL file [%s]!\n", edl_filename );
+       next_edl_record->next = NULL;
+     } else {
+       while( fgets( line, 99, fd ) != NULL ) {
+	 lineCount++;
+	 if( ( sscanf( line, "%f %f %d", &start, &stop, &action ) ) == 0 ) {
+	   printf( "Invalid EDL line: [%s]\n", line );
+	 } else {
+	   if( next_edl_array_index > 0 ) {
+	     edl_records[ next_edl_array_index-1 ].next = &edl_records[ next_edl_array_index ];
+	     if( start <= edl_records[ next_edl_array_index-1 ].stop_sec ) {
+	       printf( "Invalid EDL line [%d]: [%s]\n", lineCount, line );
+	       printf( "Last stop position was [%f]; next start is [%f]. Entries must be in chronological order and cannot overlap. Discarding EDL entry.\n", edl_records[ next_edl_array_index-1 ].stop_sec, start );
+	       continue;
+	     }
+	   }
+	   if( stop <= start ) {
+	     printf( "Invalid EDL line [%d]: [%s]\n", lineCount, line );
+	     printf( "Stop time must follow start time. Discarding EDL entry.\n" );
+	     continue;
+	   }
+	   edl_records[ next_edl_array_index ].action = action;
+	   if( action == EDL_MUTE ) {
+	     edl_records[ next_edl_array_index ].length_sec = 0;
+	     edl_records[ next_edl_array_index ].start_sec = start;
+	     edl_records[ next_edl_array_index ].stop_sec = start;
+	     next_edl_array_index++;
+	     if( next_edl_array_index >= MAX_EDL_ENTRIES-1 ) {
+	       break;
+	     }
+	     edl_records[ next_edl_array_index-1 ].next = &edl_records[ next_edl_array_index ];
+	     edl_records[ next_edl_array_index ].action = EDL_MUTE;
+	     edl_records[ next_edl_array_index ].length_sec = 0;
+	     edl_records[ next_edl_array_index ].start_sec = stop;
+	     edl_records[ next_edl_array_index ].stop_sec = stop;
+	   } else {
+	     edl_records[ next_edl_array_index ].length_sec = stop - start;
+	     edl_records[ next_edl_array_index ].start_sec = start;
+	     edl_records[ next_edl_array_index ].stop_sec = stop;
+	   }
+	   next_edl_array_index++;
+	   if( next_edl_array_index >= MAX_EDL_ENTRIES-1 ) {
+	     break;
+	   }
+	 }
+       }
+       if( next_edl_array_index > 0 ) {
+	 edl_records[ next_edl_array_index-1 ].next = &edl_records[ next_edl_array_index ];
+       }
+       edl_records[ next_edl_array_index ].start_sec = -1;
+       edl_records[ next_edl_array_index ].next = NULL;
+       num_edl_records = ( next_edl_array_index );
+     }
+     fclose( fd );
+   } else {
+     next_edl_record->next = NULL;
+   }
+   if( edl_output_filename ) {
+     if( edl_filename ) {
+       printf( "Sorry; EDL mode and EDL output mode are mutually exclusive! Disabling all EDL functions.\n" );
+       edl_output_filename = NULL;
+       edl_filename = NULL;
+       next_edl_record->next = NULL;
+     } else {
+       if( ( edl_fd = fopen( edl_output_filename, "w" ) ) == NULL ) {
+	 printf( "Error opening file [%s] for writing!\n", edl_output_filename );
+	 edl_output_filename = NULL;
+	 next_edl_record->next = NULL;
+       }
+     }
+   }
+#ifdef DEBUG_EDL
+ {
+   printf( "EDL Records:\n" );
+   if( next_edl_record->next != NULL ) {
+     while( next_edl_record->next != NULL ) {
+       printf( "EDL: start [%f], stop [%f], action [%d]\n", next_edl_record->start_sec, next_edl_record->stop_sec, next_edl_record->action );
+       next_edl_record = next_edl_record->next;
+     }
+     next_edl_record = edl_records;
+   }
+ }
+#endif
+ }
+#endif
+
+    if(!filename){
+      if(!use_gui){
+	// no file/vcd/dvd -> show HELP:
+	mp_msg(MSGT_CPLAYER, MSGL_INFO, help_text);
+	exit(0);
+      } else gui_no_filename=1;
+    }
+
+    // Many users forget to include command line in bugreports...
+    if(verbose>0){
+      mp_msg(MSGT_CPLAYER, MSGL_INFO, "CommandLine:");
+      for(i=1;i<argc;i++)printf(" '%s'",argv[i]);
+      printf("\n");
+    }
+
+    mp_msg_set_level(verbose+MSGL_STATUS);
+
+//------ load global data first ------
+
+// check font
+#ifdef USE_OSD
+#ifdef HAVE_FREETYPE
+  init_freetype();
+#endif
+#ifdef HAVE_FONTCONFIG
+  if(!font_fontconfig)
+  {
+#endif
+  if(font_name){
+       vo_font=read_font_desc(font_name,font_factor,verbose>1);
+       if(!vo_font) mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CantLoadFont,font_name);
+  } else {
+      // try default:
+       vo_font=read_font_desc(get_path("font/font.desc"),font_factor,verbose>1);
+       if(!vo_font)
+       vo_font=read_font_desc(MPLAYER_DATADIR "/font/font.desc",font_factor,verbose>1);
+  }
+#ifdef HAVE_FONTCONFIG
+  }
+#endif
+#endif
+  vo_init_osd();
+
+#ifdef HAVE_RTC
+  if(!nortc)
+  {
+    // seteuid(0); /* Can't hurt to try to get root here */
+    if ((rtc_fd = open(rtc_device ? rtc_device : "/dev/rtc", O_RDONLY)) < 0)
+	mp_msg(MSGT_CPLAYER, MSGL_WARN, "Failed to open %s: %s (it should be readable by the user.)\n",
+	    rtc_device ? rtc_device : "/dev/rtc", strerror(errno));
+     else {
+	unsigned long irqp = 1024; /* 512 seemed OK. 128 is jerky. */
+
+	if (ioctl(rtc_fd, RTC_IRQP_SET, irqp) < 0) {
+    	    mp_msg(MSGT_CPLAYER, MSGL_WARN, "Linux RTC init error in ioctl (rtc_irqp_set %lu): %s\n", irqp, strerror(errno));
+	    mp_msg(MSGT_CPLAYER, MSGL_HINT, "Try adding \"echo %lu > /proc/sys/dev/rtc/max-user-freq\" to your system startup scripts.\n", irqp);
+   	    close (rtc_fd);
+    	    rtc_fd = -1;
+	} else if (ioctl(rtc_fd, RTC_PIE_ON, 0) < 0) {
+	    /* variable only by the root */
+    	    mp_msg(MSGT_CPLAYER, MSGL_ERR, "Linux RTC init error in ioctl (rtc_pie_on): %s\n", strerror(errno));
+    	    close (rtc_fd);
+	    rtc_fd = -1;
+	} else
+	    mp_msg(MSGT_CPLAYER, MSGL_INFO, MSGTR_UsingRTCTiming, irqp);
+    }
+  }
+#ifdef HAVE_NEW_GUI
+// breaks DGA and SVGAlib and VESA drivers:  --A'rpi
+// and now ? -- Pontscho
+    if(use_gui) setuid( getuid() ); // strongly test, please check this.
+#endif
+    if(rtc_fd<0)
+#endif
+    mp_msg(MSGT_CPLAYER, MSGL_INFO, "Using %s timing\n",softsleep?"software":"usleep()");
+
+#ifdef USE_TERMCAP
+  if ( !use_gui ) load_termcap(NULL); // load key-codes
+#endif
+
+// ========== Init keyboard FIFO (connection to libvo) ============
+
+// Init input system
+current_module = "init_input";
+mp_input_init();
+#ifndef HAVE_NO_POSIX_SELECT
+make_pipe(&keyb_fifo_get,&keyb_fifo_put);
+
+if(keyb_fifo_get > 0)
+  mp_input_add_key_fd(keyb_fifo_get,1,NULL,NULL);
+#else
+  mp_input_add_key_fd(-1,0,mplayer_get_key,NULL);
+#endif
+if(slave_mode)
+#ifndef __MINGW32__
+   mp_input_add_cmd_fd(0,1,NULL,NULL);
+#else
+  mp_input_add_cmd_fd(0,0,mp_input_win32_slave_cmd_func,NULL);
+#endif
+else if(!noconsolecontrols)
+#ifndef HAVE_NO_POSIX_SELECT
+  mp_input_add_key_fd(0,1,NULL,NULL);
+#else
+  mp_input_add_key_fd(0,0,NULL,NULL);
+#endif
+
+inited_flags|=INITED_INPUT;
+current_module = NULL;
+
+#ifdef HAVE_MENU
+ if(use_menu) {
+   if(menu_cfg && menu_init(menu_cfg))
+     mp_msg(MSGT_CPLAYER,MSGL_INFO,"Menu inited: %s\n", menu_cfg);
+   else {
+     menu_cfg = get_path("menu.conf");
+     if(menu_init(menu_cfg))
+       mp_msg(MSGT_CPLAYER,MSGL_INFO,"Menu inited: %s\n", menu_cfg);
+     else {
+       if(menu_init(MPLAYER_CONFDIR "/menu.conf"))
+         mp_msg(MSGT_CPLAYER,MSGL_INFO,"Menu inited: %s\n", MPLAYER_CONFDIR"/menu.conf");
+       else {
+         mp_msg(MSGT_CPLAYER,MSGL_INFO,"Menu init failed\n");
+         use_menu = 0;
+       }
+     }
+   }
+ }
+#endif
+  
+
+
+  //========= Catch terminate signals: ================
+  // terminate requests:
+  signal(SIGTERM,exit_sighandler); // kill
+  signal(SIGHUP,exit_sighandler);  // kill -HUP  /  xterm closed
+
+  signal(SIGINT,exit_sighandler);  // Interrupt from keyboard
+
+  signal(SIGQUIT,exit_sighandler); // Quit from keyboard
+#ifdef ENABLE_SIGHANDLER
+  // fatal errors:
+  signal(SIGBUS,exit_sighandler);  // bus error
+  signal(SIGSEGV,exit_sighandler); // segfault
+  signal(SIGILL,exit_sighandler);  // illegal instruction
+  signal(SIGFPE,exit_sighandler);  // floating point exc.
+  signal(SIGABRT,exit_sighandler); // abort()
+#endif
+
+#ifdef HAVE_NEW_GUI
+  if(use_gui){
+       guiInit();
+       inited_flags|=INITED_GUI;
+       guiGetEvent( guiCEvent,(char *)((gui_no_filename) ? 0 : 1) );
+  }
+#endif
+
+// ******************* Now, let's see the per-file stuff ********************
+
+play_next_file:
+
+  if (filename) load_per_file_config (mconfig, filename);
+
+// We must enable getch2 here to be able to interrupt network connection
+// or cache filling
+if(!noconsolecontrols && !slave_mode){
+  if(inited_flags&INITED_GETCH2)
+    mp_msg(MSGT_CPLAYER,MSGL_WARN,"WARNING: getch2_init called twice!\n");
+  else
+    getch2_enable();  // prepare stdin for hotkeys...
+  inited_flags|=INITED_GETCH2;
+  mp_msg(MSGT_CPLAYER,MSGL_DBG2,"\n[[[init getch2]]]\n");
+}
+
+// =================== GUI idle loop (STOP state) ===========================
+#ifdef HAVE_NEW_GUI
+    if ( use_gui ) {
+      file_format=DEMUXER_TYPE_UNKNOWN;
+      guiGetEvent( guiSetDefaults,0 );
+      while ( guiIntfStruct.Playing != 1 )
+       {
+        mp_cmd_t* cmd;                                                                                   
+	usec_sleep(20000);
+	guiEventHandling();
+	guiGetEvent( guiReDraw,NULL );
+	if ( (cmd = mp_input_get_cmd(0,0)) != NULL) guiGetEvent( guiIEvent,(char *)cmd->id );
+       } 
+      guiGetEvent( guiSetParameters,NULL );
+      if ( guiIntfStruct.StreamType == STREAMTYPE_STREAM )
+       {
+        play_tree_t * entry = play_tree_new();
+        play_tree_add_file( entry,guiIntfStruct.Filename );
+        if ( playtree ) play_tree_free_list( playtree->child,1 );
+         else playtree=play_tree_new();
+        play_tree_set_child( playtree,entry );
+        if(playtree)
+	 {
+	  playtree_iter = play_tree_iter_new(playtree,mconfig);
+	  if(playtree_iter)
+	   {
+	    if(play_tree_iter_step(playtree_iter,0,0) != PLAY_TREE_ITER_ENTRY)
+	     {
+	      play_tree_iter_free(playtree_iter);
+	      playtree_iter = NULL;
+	     }
+	    filename = play_tree_iter_get_file(playtree_iter,1);
+	   }
+         }
+       } 
+    }
+#endif
+//---------------------------------------------------------------------------
+
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,"\n");
+    if(filename) mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_Playing, filename);
+
+//==================== Open VOB-Sub ============================
+
+    current_module="vobsub";
+    if (vobsub_name){
+      vo_vobsub=vobsub_open(vobsub_name,spudec_ifo,1,&vo_spudec);
+      if(vo_vobsub==NULL)
+        mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CantLoadSub,vobsub_name);
+    }else if(sub_auto && filename && (strlen(filename)>=5)){
+      /* try to autodetect vobsub from movie filename ::atmos */
+      char *buf = malloc((strlen(filename)-3) * sizeof(char));
+      memset(buf,0,strlen(filename)-3); // make sure string is terminated
+      strncpy(buf, filename, strlen(filename)-4); 
+      vo_vobsub=vobsub_open(buf,spudec_ifo,0,&vo_spudec);
+      free(buf);
+    }
+    if(vo_vobsub){
+      sub_auto=0; // don't do autosub for textsubs if vobsub found
+      inited_flags|=INITED_VOBSUB;
+      vobsub_set_from_lang(vo_vobsub, dvdsub_lang);
+      // check if vobsub requested only to display forced subtitles
+      forced_subs_only=vobsub_get_forced_subs_flag(vo_vobsub);
+    }
+
+//============ Open & Sync STREAM --- fork cache2 ====================
+
+  stream=NULL;
+  demuxer=NULL;
+  if (d_audio) {
+    //free_demuxer_stream(d_audio);
+    d_audio=NULL;
+  }
+  if (d_video) {
+    //free_demuxer_stream(d_video);
+    d_video=NULL;
+  }
+  sh_audio=NULL;
+  sh_video=NULL;
+
+  current_module="open_stream";
+  stream=open_stream(filename,0,&file_format);
+  if(!stream) { // error...
+    eof = libmpdemux_was_interrupted(PT_NEXT_ENTRY);
+    goto goto_next_file;
+  }
+  inited_flags|=INITED_STREAM;
+
+#ifdef HAVE_NEW_GUI
+  if ( use_gui ) guiGetEvent( guiSetStream,(char *)stream );
+#endif
+
+  if(file_format == DEMUXER_TYPE_PLAYLIST) {
+    play_tree_t* entry;
+    // Handle playlist
+    current_module="handle_playlist";
+    mp_msg(MSGT_CPLAYER,MSGL_V,"Parsing playlist %s...\n",filename);
+    entry = parse_playtree(stream,0);
+    eof=playtree_add_playlist(entry);
+    goto goto_next_file;
+  }
+  stream->start_pos+=seek_to_byte;
+
+if(stream_dump_type==5){
+  unsigned char buf[4096];
+  int len;
+  FILE *f;
+  current_module="dumpstream";
+  if(stream->type==STREAMTYPE_STREAM && stream->fd<0){
+    mp_msg(MSGT_CPLAYER,MSGL_FATAL,"Cannot dump this stream - no 'fd' available\n");
+    exit_player(MSGTR_Exit_error);
+  }
+  stream_reset(stream);
+  stream_seek(stream,stream->start_pos);
+  f=fopen(stream_dump_name,"wb");
+  if(!f){
+    mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_CantOpenDumpfile);
+    exit_player(MSGTR_Exit_error);
+  }
+  while(!stream->eof){
+      len=stream_read(stream,buf,4096);
+      if(len>0) {
+        if(fwrite(buf,len,1,f) != 1) {
+          mp_msg(MSGT_MENCODER,MSGL_FATAL,MSGTR_ErrorWritingFile,stream_dump_name);
+          exit_player(MSGTR_Exit_error);
+        }
+      }
+  }
+  if(fclose(f)) {
+    mp_msg(MSGT_MENCODER,MSGL_FATAL,MSGTR_ErrorWritingFile,stream_dump_name);
+    exit_player(MSGTR_Exit_error);
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_CoreDumped);
+  exit_player_with_rc(MSGTR_Exit_eof, 0);
+}
+
+#ifdef USE_DVDREAD
+if(stream->type==STREAMTYPE_DVD){
+  current_module="dvd lang->id";
+  if(audio_id==-1) audio_id=dvd_aid_from_lang(stream,audio_lang);
+  if(dvdsub_lang && dvdsub_id==-1) dvdsub_id=dvd_sid_from_lang(stream,dvdsub_lang);
+  current_module=NULL;
+}
+#endif
+
+#ifdef USE_DVDNAV
+  if (stream->type==STREAMTYPE_DVDNAV) stream_cache_size=0;	// must disable caching...
+#endif
+
+// CACHE2: initial prefill: 20%  later: 5%  (should be set by -cacheopts)
+#ifdef HAS_DVBIN_SUPPORT
+goto_enable_cache:
+#endif
+if(stream_cache_size>0){
+  current_module="enable_cache";
+  if(!stream_enable_cache(stream,stream_cache_size*1024,stream_cache_size*1024/5,stream_cache_size*1024/20))
+    if((eof = libmpdemux_was_interrupted(PT_NEXT_ENTRY))) goto goto_next_file;
+}
+
+//============ Open DEMUXERS --- DETECT file type =======================
+current_module="demux_open";
+
+demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename);
+
+// HACK to get MOV Reference Files working
+
+if (demuxer && demuxer->type==DEMUXER_TYPE_PLAYLIST)
+{ 
+  unsigned char* playlist_entry;
+  play_tree_t *list = NULL, *entry = NULL;
+
+  current_module="handle_demux_playlist";
+  while (ds_get_packet(demuxer->video,&playlist_entry)>0)
+  {	 
+    char *temp, *bname;
+    
+    mp_msg(MSGT_CPLAYER,MSGL_V,"Adding file %s to element entry\n",playlist_entry);
+
+    bname=mp_basename(playlist_entry);
+    if ((strlen(bname)>10) && !strncmp(bname,"qt",2) && !strncmp(bname+3,"gateQT",6))
+        continue;
+
+    if (!strncmp(bname,mp_basename(filename),strlen(bname))) // ignoring self-reference
+        continue;
+
+    entry = play_tree_new();
+    
+    if (filename && !strcmp(mp_basename(playlist_entry),playlist_entry)) // add reference path of current file
+    {
+      temp=malloc((strlen(filename)-strlen(mp_basename(filename))+strlen(playlist_entry)+1)*sizeof(char));
+      if (temp)
+      {
+	strncpy(temp, filename, strlen(filename)-strlen(mp_basename(filename)));
+	temp[strlen(filename)-strlen(mp_basename(filename))]='\0';
+	strcat(temp, playlist_entry);
+	play_tree_add_file(entry,temp);
+	mp_msg(MSGT_CPLAYER,MSGL_V,"Resolving reference to %s\n",temp);
+	free(temp);
+      }
+    }
+    else
+      play_tree_add_file(entry,playlist_entry);
+    
+    if(!list)
+      list = entry;
+    else
+      play_tree_append_entry(list,entry);
+  }
+  free_demuxer(demuxer);
+  demuxer = NULL;
+
+  if (list)
+  {
+    entry = play_tree_new();
+    play_tree_set_child(entry,list);
+    eof=playtree_add_playlist(entry);
+    goto goto_next_file;
+  }
+}
+
+if(!demuxer) 
+{
+#if 0
+  play_tree_t* entry;
+  // Handle playlist
+  current_module="handle_playlist";
+  switch(stream->type){
+  case STREAMTYPE_VCD:
+  case STREAMTYPE_DVD:
+  case STREAMTYPE_DVDNAV:
+  case STREAMTYPE_CDDA:
+  case STREAMTYPE_VCDBINCUE:
+    // don't try to parse raw media as playlist, it's unlikely
+    goto goto_next_file;
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"Falling back on trying to parse playlist %s...\n",filename);
+  stream_reset(stream);
+  stream_seek(stream,stream->start_pos);
+  entry = parse_playtree(stream,0);
+  if(!entry)
+    mp_msg(MSGT_DEMUXER,MSGL_ERR,MSGTR_FormatNotRecognized);
+  else
+    eof=playtree_add_playlist(entry);
+#endif
+  goto goto_next_file;
+}
+inited_flags|=INITED_DEMUXER;
+
+current_module="demux_open2";
+
+//file_format=demuxer->file_format;
+
+d_audio=demuxer->audio;
+d_video=demuxer->video;
+d_dvdsub=demuxer->sub;
+
+// DUMP STREAMS:
+if((stream_dump_type)&&(stream_dump_type<4)){
+  FILE *f;
+  demux_stream_t *ds=NULL;
+  current_module="dump";
+  // select stream to dump
+  switch(stream_dump_type){
+  case 1: ds=d_audio;break;
+  case 2: ds=d_video;break;
+  case 3: ds=d_dvdsub;break;
+  }
+  if(!ds){        
+      mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_DumpSelectedStreamMissing);
+      exit_player(MSGTR_Exit_error);
+  }
+  // disable other streams:
+  if(d_audio && d_audio!=ds) {ds_free_packs(d_audio); d_audio->id=-2; }
+  if(d_video && d_video!=ds) {ds_free_packs(d_video); d_video->id=-2; }
+  if(d_dvdsub && d_dvdsub!=ds) {ds_free_packs(d_dvdsub); d_dvdsub->id=-2; }
+  // let's dump it!
+  f=fopen(stream_dump_name,"wb");
+  if(!f){
+    mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_CantOpenDumpfile);
+    exit_player(MSGTR_Exit_error);
+  }
+  while(!ds->eof){
+    unsigned char* start;
+    int in_size=ds_get_packet(ds,&start);
+    if( (demuxer->file_format==DEMUXER_TYPE_AVI || demuxer->file_format==DEMUXER_TYPE_ASF || demuxer->file_format==DEMUXER_TYPE_MOV)
+	&& stream_dump_type==2) fwrite(&in_size,1,4,f);
+    if(in_size>0) fwrite(start,in_size,1,f);
+  }
+  fclose(f);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_CoreDumped);
+  exit_player_with_rc(MSGTR_Exit_eof, 0);
+}
+
+sh_audio=d_audio->sh;
+sh_video=d_video->sh;
+
+if(sh_video){
+
+  current_module="video_read_properties";
+  if(!video_read_properties(sh_video)) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CannotReadVideoProperties);
+    sh_video=d_video->sh=NULL;
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_V,"[V] filefmt:%d  fourcc:0x%X  size:%dx%d  fps:%5.2f  ftime:=%6.4f\n",
+	   demuxer->file_format,sh_video->format, sh_video->disp_w,sh_video->disp_h,
+	   sh_video->fps,sh_video->frametime
+	   );
+
+    /* need to set fps here for output encoders to pick it up in their init */
+    if(force_fps){
+      sh_video->fps=force_fps;
+      sh_video->frametime=1.0f/sh_video->fps;
+    }
+    vo_fps = sh_video->fps;
+#ifdef HAVE_X11
+    vo_mouse_timer_const=(int)sh_video->fps;
+#endif
+
+    if(!sh_video->fps && !force_fps){
+      mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_FPSnotspecified);
+      sh_video=d_video->sh=NULL;
+    }
+  }
+
+}
+
+fflush(stdout);
+
+if(!sh_video && !sh_audio){
+    mp_msg(MSGT_CPLAYER,MSGL_FATAL, MSGTR_NoStreamFound);
+#ifdef HAS_DVBIN_SUPPORT
+	if((stream->type == STREAMTYPE_DVB) && stream->priv)
+	{
+	  dvb_priv_t *priv = (dvb_priv_t*) stream->priv;
+	  if(priv->is_on)
+	  {
+		int dir;
+		int v = last_dvb_step;
+		if(v > 0)
+			dir = DVB_CHANNEL_HIGHER;
+		else
+			dir = DVB_CHANNEL_LOWER;
+			
+		if(dvb_step_channel(priv, dir))
+		{
+	  		uninit_player(INITED_ALL-(INITED_STREAM|INITED_INPUT));
+			cache_uninit(stream);
+			goto goto_enable_cache;
+		}
+	  }
+	}
+#endif	
+    goto goto_next_file; // exit_player(MSGTR_Exit_error);
+}
+
+/* display clip info */
+demux_info_print(demuxer);
+
+//================== Read SUBTITLES (DVD & TEXT) ==========================
+if(d_dvdsub->id >= 0 && vo_spudec==NULL && sh_video){
+
+if (spudec_ifo) {
+  unsigned int palette[16], width, height;
+  current_module="spudec_init_vobsub";
+  if (vobsub_parse_ifo(NULL,spudec_ifo, palette, &width, &height, 1, -1, NULL) >= 0)
+    vo_spudec=spudec_new_scaled(palette, width, height);
+}
+
+#ifdef USE_DVDNAV
+if (vo_spudec==NULL && stream->type==STREAMTYPE_DVDNAV) {
+  current_module="spudec_init_dvdnav";
+  vo_spudec=spudec_new_scaled(dvdnav_stream_get_palette((dvdnav_priv_t*)(stream->priv)),
+			    sh_video->disp_w, sh_video->disp_h);
+}
+#endif
+
+#ifdef USE_DVDREAD
+if (vo_spudec==NULL && stream->type==STREAMTYPE_DVD) {
+  current_module="spudec_init_dvdread";
+  vo_spudec=spudec_new_scaled(((dvd_priv_t *)(stream->priv))->cur_pgc->palette,
+			    sh_video->disp_w, sh_video->disp_h);
+}
+#endif
+
+#ifdef HAVE_MATROSKA
+if ((vo_spudec == NULL) && (demuxer->type == DEMUXER_TYPE_MATROSKA) &&
+    (d_dvdsub->sh != NULL) && (((mkv_sh_sub_t *)d_dvdsub->sh)->type == 'v')) {
+  mkv_sh_sub_t *mkv_sh_sub = (mkv_sh_sub_t *)d_dvdsub->sh;
+  current_module = "spudec_init_matroska";
+  vo_spudec =
+    spudec_new_scaled_vobsub(mkv_sh_sub->palette, mkv_sh_sub->colors,
+                             mkv_sh_sub->custom_colors, mkv_sh_sub->width,
+                             mkv_sh_sub->height);
+  forced_subs_only = mkv_sh_sub->forced_subs_only;
+}
+#endif
+
+if (vo_spudec==NULL) {
+  current_module="spudec_init_normal";
+  vo_spudec=spudec_new_scaled(NULL, sh_video->disp_w, sh_video->disp_h);
+  spudec_set_font_factor(vo_spudec,font_factor);
+}
+
+if (vo_spudec!=NULL)
+  inited_flags|=INITED_SPUDEC;
+
+}
+
+// Apply current settings for forced subs
+if (vo_spudec!=NULL)
+  spudec_set_forced_subs_only(vo_spudec,forced_subs_only);
+
+#ifdef USE_SUB
+if(sh_video) {
+// after reading video params we should load subtitles because
+// we know fps so now we can adjust subtitles time to ~6 seconds AST
+// check .sub
+  current_module="read_subtitles_file";
+  if(sub_name){
+    for (i = 0; sub_name[i] != NULL; ++i) 
+        add_subtitles (sub_name[i], sh_video->fps, 0); 
+  } 
+  if(sub_auto) { // auto load sub file ...
+    char *psub = get_path( "sub/" );
+    char **tmp = sub_filenames((psub ? psub : ""), filename);
+    char **tmp2 = tmp;
+    while (*tmp2)
+        add_subtitles (*tmp2++, sh_video->fps, 0);
+    free(tmp);
+    if (set_of_sub_size == 0)
+        add_subtitles (get_path("default.sub"), sh_video->fps, 1);
+    if (set_of_sub_size > 0)
+        add_subtitles (NULL, sh_video->fps, 1);
+  }
+  if (set_of_sub_size > 0)  {
+      //osd_show_sub_changed = sh_video->fps;
+      subdata = set_of_subtitles[set_of_sub_pos=0];
+  
+      if(stream_dump_type==3) list_sub_file(subdata);
+      if(stream_dump_type==4) dump_mpsub(subdata, sh_video->fps);
+      if(stream_dump_type==6) dump_srt(subdata, sh_video->fps);
+      if(stream_dump_type==7) dump_microdvd(subdata, sh_video->fps);
+      if(stream_dump_type==8) dump_jacosub(subdata, sh_video->fps);
+      if(stream_dump_type==9) dump_sami(subdata, sh_video->fps);
+  }
+}
+#endif
+
+//================== Init AUDIO (codec) ==========================
+if(sh_audio){
+  // Go through the codec.conf and find the best codec...
+  current_module="init_audio_codec";
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+  if(!init_best_audio_codec(sh_audio,audio_codec_list,audio_fm_list)){
+    sh_audio=d_audio->sh=NULL; // failed to init :(
+  } else
+    inited_flags|=INITED_ACODEC;
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+}
+
+if(identify) {
+  mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_FILENAME=%s\n", filename);
+  if (sh_video) {
+    /* Assume FOURCC if all bytes >= 0x20 (' ') */
+    if (sh_video->format >= 0x20202020)
+	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_FORMAT=%.4s\n", &sh_video->format);
+    else
+	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_FORMAT=0x%08X\n", sh_video->format);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_BITRATE=%d\n", sh_video->i_bps*8);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_WIDTH=%d\n", sh_video->disp_w);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_HEIGHT=%d\n", sh_video->disp_h);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_FPS=%5.3f\n", sh_video->fps);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_VIDEO_ASPECT=%1.4f\n", sh_video->aspect);
+  }
+  if (sh_audio) {
+    if (sh_audio->codec)
+      mp_msg(MSGT_GLOBAL,MSGL_INFO, "ID_AUDIO_CODEC=%s\n", sh_audio->codec->name);
+    /* Assume FOURCC if all bytes >= 0x20 (' ') */
+    if (sh_audio->format >= 0x20202020)
+      mp_msg(MSGT_GLOBAL,MSGL_INFO, "ID_AUDIO_FORMAT=%.4s\n", &sh_audio->format);
+    else
+      mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_AUDIO_FORMAT=%d\n", sh_audio->format);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_AUDIO_BITRATE=%d\n", sh_audio->i_bps*8);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_AUDIO_RATE=%d\n", sh_audio->samplerate);
+    mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_AUDIO_NCH=%d\n", sh_audio->channels);
+  }
+  mp_msg(MSGT_GLOBAL,MSGL_INFO,"ID_LENGTH=%ld\n", demuxer_get_time_length(demuxer));
+}
+
+if(!sh_video) goto main; // audio-only
+
+//================== Init VIDEO (codec & libvo) ==========================
+if(!fixed_vo || !(inited_flags&INITED_VO)){
+current_module="preinit_libvo";
+
+vo_config_count=0;
+//if((video_out->preinit(vo_subdevice))!=0){
+if(!(video_out=init_best_video_out(video_driver_list))){
+    mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_ErrorInitializingVODevice);
+    goto goto_next_file; // exit_player(MSGTR_Exit_error);
+}
+sh_video->video_out=video_out;
+inited_flags|=INITED_VO;
+}
+
+current_module="init_video_filters";
+{
+  char* vf_arg[] = { "_oldargs_", (char*)video_out , NULL };
+  sh_video->vfilter=(void*)vf_open_filter(NULL,"vo",vf_arg);
+}
+#ifdef HAVE_MENU
+if(use_menu) {
+  char* vf_arg[] = { "_oldargs_", menu_root, NULL };
+  vf_menu = vf_open_plugin(libmenu_vfs,sh_video->vfilter,"menu",vf_arg);
+  if(!vf_menu) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,"Can't open libmenu video filter with root menu %s\n",menu_root);
+    use_menu = 0;
+  }
+}
+if(vf_menu)
+  sh_video->vfilter=(void*)append_filters(vf_menu);
+else
+#endif
+sh_video->vfilter=(void*)append_filters(sh_video->vfilter);
+
+current_module="init_video_codec";
+
+mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+init_best_video_codec(sh_video,video_codec_list,video_fm_list);
+mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+
+if(!sh_video->inited){
+    if(!fixed_vo) uninit_player(INITED_VO);
+    if(!sh_audio) goto goto_next_file;
+    sh_video = d_video->sh = NULL;
+    goto main; // exit_player(MSGTR_Exit_error);
+}
+
+inited_flags|=INITED_VCODEC;
+
+if(auto_quality>0){
+    // Auto quality option enabled
+    output_quality=get_video_quality_max(sh_video);
+    if(auto_quality>output_quality) auto_quality=output_quality;
+    else output_quality=auto_quality;
+    mp_msg(MSGT_CPLAYER,MSGL_V,"AutoQ: setting quality to %d\n",output_quality);
+    set_video_quality(sh_video,output_quality);
+}
+
+// ========== Init display (sh_video->disp_w*sh_video->disp_h/out_fmt) ============
+
+current_module="init_vo";
+    if (sh_video)
+    {
+        if (vo_gamma_gamma != 1000)
+          set_video_colors (sh_video, "gamma", vo_gamma_gamma);
+	if (vo_gamma_brightness != 1000)
+	    set_video_colors(sh_video, "brightness", vo_gamma_brightness);
+	if (vo_gamma_contrast != 1000)
+	    set_video_colors(sh_video, "contrast", vo_gamma_contrast);
+	if (vo_gamma_saturation != 1000)
+	    set_video_colors(sh_video, "saturation", vo_gamma_saturation);
+	if (vo_gamma_hue != 1000)
+	    set_video_colors(sh_video, "hue", vo_gamma_hue);
+    }
+
+   if(vo_flags & 0x08 && vo_spudec)
+      spudec_set_hw_spu(vo_spudec,video_out);
+
+#ifdef HAVE_FREETYPE
+   force_load_font = 1;
+#endif
+
+//================== MAIN: ==========================
+main:
+current_module="main";
+
+// If there is no video OSD has to be disabled.
+// In case of playing a playtree we have to restore the
+// old OSD level after playing one or more audio-only files.
+if(!sh_video && osd_level >= 0) { // save OSD level only once
+    osd_level_saved = osd_level;
+    osd_level = 0;
+} else if (osd_level_saved > -1) { // if there is a saved OSD level, restore it
+    osd_level = osd_level_saved;
+    osd_level_saved = -1;
+}
+
+fflush(stdout);
+
+#ifdef HAVE_NEW_GUI
+   if ( use_gui )
+    {
+     if ( sh_audio ) guiIntfStruct.AudioType=sh_audio->channels; else guiIntfStruct.AudioType=0;
+     if ( !sh_video && sh_audio ) guiGetEvent( guiSetAudioOnly,(char *)1 ); else guiGetEvent( guiSetAudioOnly,(char *)0 );
+     guiGetEvent( guiSetFileFormat,(char *)demuxer->file_format );
+     if ( guiGetEvent( guiSetValues,(char *)sh_video ) ) goto goto_next_file;
+     guiGetEvent( guiSetDemuxer,(char *)demuxer );
+    }
+#endif
+
+{
+//int frame_corr_num=0;   //
+//float v_frame=0;    // Video
+float time_frame=0; // Timer
+//float num_frames=0;      // number of frames played
+int grab_frames=0;
+char osd_text_buffer[64];
+char osd_show_text_buffer[64];
+int drop_frame=0;     // current dropping status
+int dropped_frames=0; // how many frames dropped since last non-dropped frame
+int too_slow_frame_cnt=0;
+int too_fast_frame_cnt=0;
+// for auto-quality:
+float AV_delay=0; // average of A-V timestamp differences
+double vdecode_time;
+unsigned int lastframeout_ts=0;
+/*float time_frame_corr_avg=0;*/ /* unused */
+
+float next_frame_time=0;
+int frame_time_remaining=0; // flag
+int blit_frame=0;
+
+osd_text_buffer[0]=0;
+
+//================ SETUP AUDIO ==========================
+
+if(sh_audio){
+  //const ao_info_t *info=audio_out->info;
+  current_module="af_preinit";
+  ao_data.samplerate=force_srate?force_srate:sh_audio->samplerate*playback_speed;
+  ao_data.channels=audio_output_channels?audio_output_channels:sh_audio->channels;
+  ao_data.format=audio_output_format?audio_output_format:sh_audio->sample_format;
+#if 1
+  if(!preinit_audio_filters(sh_audio,
+        // input:
+        (int)(sh_audio->samplerate*playback_speed),
+	sh_audio->channels, sh_audio->sample_format, sh_audio->samplesize,
+	// output:
+	&ao_data.samplerate, &ao_data.channels, &ao_data.format,
+	audio_out_format_bits(ao_data.format)/8)){
+      mp_msg(MSGT_CPLAYER,MSGL_ERR,"Error at audio filter chain pre-init!\n");
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,"AF_pre: %dHz %dch %s\n",
+      ao_data.samplerate, ao_data.channels,
+      audio_out_format_name(ao_data.format));
+  }
+#endif  
+  current_module="ao2_init";
+  if(!(audio_out=init_best_audio_out(audio_driver_list,
+      (ao_plugin_cfg.plugin_list!=NULL), // plugin flag
+      force_srate?force_srate:ao_data.samplerate,
+      audio_output_channels?audio_output_channels:ao_data.channels,
+      audio_output_format?audio_output_format:ao_data.format,0))){
+    // FAILED:
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CannotInitAO);
+    uninit_player(INITED_ACODEC); // close codec
+    sh_audio=d_audio->sh=NULL; // -> nosound
+  } else {
+    // SUCCESS:
+    inited_flags|=INITED_AO;
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,"AO: [%s] %dHz %dch %s (%d bps)\n",
+      audio_out->info->short_name,
+      ao_data.samplerate, ao_data.channels,
+      audio_out_format_name(ao_data.format),
+      audio_out_format_bits(ao_data.format)/8 );
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_AODescription_AOAuthor,
+      audio_out->info->name, audio_out->info->author);
+    if(strlen(audio_out->info->comment) > 0)
+      mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_AOComment, audio_out->info->comment);
+    // init audio filters:
+#if 1
+    current_module="af_init";
+    if(!init_audio_filters(sh_audio, 
+        (int)(sh_audio->samplerate*playback_speed),
+	sh_audio->channels, sh_audio->sample_format, sh_audio->samplesize,
+	ao_data.samplerate, ao_data.channels, ao_data.format,
+	audio_out_format_bits(ao_data.format)/8, /* ao_data.bps, */
+	ao_data.outburst*4, ao_data.buffersize)){
+      mp_msg(MSGT_CPLAYER,MSGL_ERR,"Couldn't find matching filter / ao format!\n");
+//      mp_msg(MSGT_CPLAYER,MSGL_ERR,"Couldn't find matching filter / ao format! -> NOSOUND\n");
+//      uninit_player(INITED_ACODEC|INITED_AO); // close codec & ao
+//      sh_audio=d_audio->sh=NULL; // -> nosound
+    }
+#endif
+  }
+  mixer.audio_out = audio_out;
+  mixer.afilter = sh_audio ? sh_audio->afilter : NULL;
+  mixer.volstep = 3;
+}
+
+current_module="av_init";
+
+if(sh_video) sh_video->timer=0;
+if(sh_audio) sh_audio->delay=-audio_delay;
+
+if(!sh_audio){
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_NoSound);
+  mp_msg(MSGT_CPLAYER,MSGL_V,"Freeing %d unused audio chunks\n",d_audio->packs);
+  ds_free_packs(d_audio); // free buffered chunks
+  d_audio->id=-2;         // do not read audio chunks
+  //uninit_player(INITED_AO); // close device
+}
+if(!sh_video){
+   mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_Video_NoVideo);
+   mp_msg(MSGT_CPLAYER,MSGL_V,"Freeing %d unused video chunks\n",d_video->packs);
+   ds_free_packs(d_video);
+   d_video->id=-2;
+   //if(!fixed_vo) uninit_player(INITED_VO);
+}
+
+if (!sh_video && !sh_audio)
+    goto goto_next_file;
+
+//if(demuxer->file_format!=DEMUXER_TYPE_AVI) pts_from_bps=0; // it must be 0 for mpeg/asf!
+if(force_fps && sh_video){
+  vo_fps = sh_video->fps=force_fps;
+  sh_video->frametime=1.0f/sh_video->fps;
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_FPSforced,sh_video->fps,sh_video->frametime);
+}
+
+//==================== START PLAYING =======================
+
+if(loop_times>1) loop_times--; else
+if(loop_times==1) loop_times = -1;
+
+mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_StartPlaying);fflush(stdout);
+
+InitTimer();
+
+#ifdef USE_DVDNAV
+if (stream->type==STREAMTYPE_DVDNAV) {
+  dvdnav_stream_fullstart((dvdnav_priv_t *)stream->priv);
+}
+#endif
+
+total_time_usage_start=GetTimer();
+audio_time_usage=0; video_time_usage=0; vout_time_usage=0;
+total_frame_cnt=0; drop_frame_cnt=0; // fix for multifile fps benchmark
+play_n_frames=play_n_frames_mf;
+
+if(play_n_frames==0){
+  eof=PT_NEXT_ENTRY; goto goto_next_file;
+}
+
+while(!eof){
+    float aq_sleep_time=0;
+
+    if(play_n_frames>=0){
+      --play_n_frames;
+      if(play_n_frames<0) eof = PT_NEXT_ENTRY;
+    }
+
+/*========================== PLAY AUDIO ============================*/
+
+while(sh_audio){
+  unsigned int t;
+  double tt;
+  int playsize;
+
+  current_module="play_audio";
+  
+  ao_data.pts=((sh_video?sh_video->timer:0)+sh_audio->delay)*90000.0;
+  playsize=audio_out->get_space();
+  
+  // handle audio-only case:
+  if(!playsize && !sh_video) {  // buffer is full, do not block here!!!
+    usec_sleep(10000); // Wait a tick before retry
+    continue;
+  }
+  
+  if(playsize>MAX_OUTBURST) playsize=MAX_OUTBURST; // we shouldn't exceed it!
+
+  // Fill buffer if needed:
+  current_module="decode_audio";   // Enter AUDIO decoder module
+  t=GetTimer();
+  while(sh_audio->a_out_buffer_len<playsize && !d_audio->eof){
+    int ret=decode_audio(sh_audio,&sh_audio->a_out_buffer[sh_audio->a_out_buffer_len],
+        playsize-sh_audio->a_out_buffer_len,sh_audio->a_out_buffer_size-sh_audio->a_out_buffer_len);
+    if(ret<=0) break; // EOF?
+    sh_audio->a_out_buffer_len+=ret;
+  }
+  t=GetTimer()-t;
+  tt = t*0.000001f; audio_time_usage+=tt;
+  if(playsize>sh_audio->a_out_buffer_len) playsize=sh_audio->a_out_buffer_len;
+
+  // play audio:  
+  current_module="play_audio";
+  playsize=audio_out->play(sh_audio->a_out_buffer,playsize,0);
+
+  if(playsize>0){
+      sh_audio->a_out_buffer_len-=playsize;
+      memmove(sh_audio->a_out_buffer,&sh_audio->a_out_buffer[playsize],sh_audio->a_out_buffer_len);
+      sh_audio->delay+=playback_speed*playsize/((float)((ao_data.bps && sh_audio->afilter) ?
+          ao_data.bps : sh_audio->o_bps));
+  }
+
+  break;
+} // while(sh_audio)
+
+if(!sh_video) {
+  // handle audio-only case:
+  if(!quiet) {
+      //
+      // convert time to HH:MM:SS.F format
+      //
+      long tenths = 10 * sh_audio->delay-audio_out->get_delay();
+      int hh = (tenths / 36000) % 100;
+      int mm = (tenths / 600) % 60;
+      int ss = (tenths /  10) % 60;
+      int f1 = tenths % 10;
+      char hhmmssf[16]; // only really need 11, but just in case...
+      sprintf( hhmmssf, "%2d:%2d:%2d.%1d", hh, mm, ss, f1);
+      if (0 == hh) {
+        hhmmssf[1] = ' ';
+        hhmmssf[2] = ' ';
+      }
+      // uncomment the next three lines to show leading zero ten-hours
+      // else if (' ' == hhmmssf[0]) {
+      //   hhmmssf[0] = '0';
+      // }
+      if ((0 == hh) && (0 == mm)) {
+        hhmmssf[4] = ' ';
+        hhmmssf[5] = ' ';
+      }
+      else if ((' ' == hhmmssf[3]) && (' ' != hhmmssf[2])) {
+        hhmmssf[3] = '0';
+      }
+      if ((' ' == hhmmssf[6]) && (' ' != hhmmssf[5])) {
+        hhmmssf[6] = '0';
+      }
+             mp_msg(MSGT_AVSYNC,MSGL_STATUS,"A:  %s %4.1f%% %d%%   \r"
+		    ,hhmmssf
+		    ,(sh_audio->delay>0.5)?100.0*audio_time_usage/(double)sh_audio->delay:0
+		    ,cache_fill_status
+		    );
+  }
+  if(d_audio->eof) eof = PT_NEXT_ENTRY;
+
+} else {
+
+/*========================== PLAY VIDEO ============================*/
+
+  float frame_time=next_frame_time;
+
+  vo_pts=sh_video->timer*90000.0;
+  vo_fps=sh_video->fps;
+
+  if(!frame_time_remaining){
+    //--------------------  Decode a frame: -----------------------
+    vdecode_time=video_time_usage;
+    while(1)
+    {   unsigned char* start=NULL;
+	int in_size;
+	// get it!
+	current_module="video_read_frame";
+        in_size=video_read_frame(sh_video,&next_frame_time,&start,force_fps);
+	if(in_size<0){ eof=1; break; }
+	if(in_size>max_framesize) max_framesize=in_size; // stats
+	sh_video->timer+=frame_time;
+	if(sh_audio) sh_audio->delay-=frame_time;
+	time_frame+=frame_time;  // for nosound
+	// check for frame-drop:
+	current_module="check_framedrop";
+	if(sh_audio && !d_audio->eof){
+	    float delay=playback_speed*audio_out->get_delay();
+	    float d=delay-sh_audio->delay;
+	    // we should avoid dropping to many frames in sequence unless we
+	    // are too late. and we allow 100ms A-V delay here:
+	    if(d<-dropped_frames*frame_time-0.100){
+		drop_frame=frame_dropping;
+		++drop_frame_cnt;
+		++dropped_frames;
+	    } else {
+		drop_frame=dropped_frames=0;
+	    }
+	    ++total_frame_cnt;
+	}
+	// decode:
+	current_module="decode_video";
+//	printf("Decode! %p  %d  \n",start,in_size);
+	blit_frame=decode_video(sh_video,start,in_size,drop_frame);
+	break;
+    }
+    vdecode_time=video_time_usage-vdecode_time;
+    //------------------------ frame decoded. --------------------
+
+    mp_dbg(MSGT_AVSYNC,MSGL_DBG2,"*** ftime=%5.3f ***\n",frame_time);
+
+    if(sh_video->vf_inited<0){
+	mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_NotInitializeVOPorVO);
+	eof=1; goto goto_next_file;
+    }
+
+  }
+
+// ==========================================================================
+    
+//    current_module="draw_osd";
+//    if(vo_config_count) video_out->draw_osd();
+
+#ifdef HAVE_NEW_GUI
+    if(use_gui) guiEventHandling();
+#endif
+
+    current_module="calc_sleep_time";
+
+#if 0
+{	// debug frame dropping code
+	  float delay=audio_out->get_delay();
+	  mp_msg(MSGT_AVSYNC,MSGL_V,"\r[V] %5.3f [A] %5.3f => {%5.3f}  (%5.3f) [%d]   \n",
+	      sh_video->timer,sh_audio->timer-delay,
+	      sh_video->timer-(sh_audio->timer-delay),
+	      delay,drop_frame);
+}
+#endif
+
+    if(drop_frame && !frame_time_remaining && !autosync){
+      /*
+       * Note: time_frame should not be forced to 0 in autosync mode.
+       * It is used as a cumulative counter to predict and correct the
+       * delay measurements from the audio driver.  time_frame is already
+       * < 0, so the "time to sleep" code does not actually sleep.  Also,
+       * blit_frame is already 0 because drop_frame was true when
+       * decode_video was called (which causes it to set blit_frame to 0.)
+       * When autosync==0, the default behavior is still completely unchanged.
+       */
+
+      time_frame=0;	// don't sleep!
+      blit_frame=0;	// don't display!
+      
+    } else {
+
+      // It's time to sleep...
+      
+      frame_time_remaining=0;
+      time_frame-=GetRelativeTime(); // reset timer
+
+      if(sh_audio && !d_audio->eof){
+	  float delay=playback_speed*audio_out->get_delay();
+	  mp_dbg(MSGT_AVSYNC,MSGL_DBG2,"delay=%f\n",delay);
+
+	  if (autosync){
+	    /*
+	     * Adjust this raw delay value by calculating the expected
+	     * delay for this frame and generating a new value which is
+	     * weighted between the two.  The higher autosync is, the
+	     * closer to the delay value gets to that which "-nosound"
+	     * would have used, and the longer it will take for A/V
+	     * sync to settle at the right value (but it eventually will.)
+	     * This settling time is very short for values below 100.
+	     */
+	    float predicted = sh_audio->delay+time_frame;
+	    float difference = delay - predicted;
+	    delay = predicted + difference / (float)autosync;
+	  }
+
+          time_frame=delay-sh_audio->delay;
+
+	// delay = amount of audio buffered in soundcard/driver
+	if(delay>0.25) delay=0.25; else
+	if(delay<0.10) delay=0.10;
+	if(time_frame>delay*0.6){
+	    // sleep time too big - may cause audio drops (buffer underrun)
+	    frame_time_remaining=1;
+	    time_frame=delay*0.5;
+	}
+
+      } else {
+
+          // NOSOUND:
+          if( (time_frame<-3*frame_time || time_frame>3*frame_time) || benchmark)
+	      time_frame=0;
+	  
+      }
+
+//      if(verbose>1)printf("sleep: %5.3f  a:%6.3f  v:%6.3f  \n",time_frame,sh_audio->timer,sh_video->timer);
+
+      aq_sleep_time+=time_frame;
+
+    }	// !drop_frame
+    
+//============================== SLEEP: ===================================
+
+time_frame/=playback_speed;
+
+// flag 256 means: libvo driver does its timing (dvb card)
+if(time_frame>0.001 && !(vo_flags&256)){
+
+#ifdef HAVE_RTC
+    if(rtc_fd>=0){
+	// -------- RTC -----------
+	current_module="sleep_rtc";
+        while (time_frame > 0.000) {
+	    unsigned long rtc_ts;
+	    if (read (rtc_fd, &rtc_ts, sizeof(rtc_ts)) <= 0)
+		    mp_msg(MSGT_CPLAYER, MSGL_ERR, "Linux RTC read error: %s\n", strerror(errno));
+    	    time_frame-=GetRelativeTime();
+	}
+    } else
+#endif
+    {
+	// -------- USLEEP + SOFTSLEEP -----------
+	float min=softsleep?0.021:0.005;
+	current_module="sleep_usleep";
+        while(time_frame>min){
+          if(time_frame<=0.020)
+             usec_sleep(0); // sleeps 1 clock tick (10ms)!
+          else
+             usec_sleep(1000000*(time_frame-0.020));
+          time_frame-=GetRelativeTime();
+        }
+	if(softsleep){
+	    current_module="sleep_soft";
+	    if(time_frame<0) mp_msg(MSGT_AVSYNC, MSGL_WARN, "Warning! Softsleep underflow!\n");
+	    while(time_frame>0) time_frame-=GetRelativeTime(); // burn the CPU
+	}
+    }
+
+}
+
+//if(!frame_time_remaining){	// should we display the frame now?
+
+//====================== FLIP PAGE (VIDEO BLT): =========================
+
+        current_module="vo_check_events";
+	if(vo_config_count) video_out->check_events();
+
+        current_module="flip_page";
+        if (!frame_time_remaining) {
+         if(blit_frame){
+	   unsigned int t2=GetTimer();
+	   double tt;
+	   float j;
+#define	FRAME_LAG_WARN	0.2
+	   j = ((float)t2 - lastframeout_ts) / 1000000;
+	   lastframeout_ts = GetTimer();
+	   if (j < frame_time + frame_time * -FRAME_LAG_WARN)
+		too_fast_frame_cnt++;
+		/* printf ("PANIC: too fast frame (%.3f)!\n", j); */
+	   else if (j > frame_time + frame_time * FRAME_LAG_WARN)
+		too_slow_frame_cnt++;
+		/* printf ("PANIC: too slow frame (%.3f)!\n", j); */
+
+	   if(vo_config_count) video_out->flip_page();
+//        usec_sleep(50000); // test only!
+	   t2=GetTimer()-t2;
+	   tt = t2*0.000001f;
+	   vout_time_usage+=tt;
+	 } else {
+             /*
+	     Well, no blitting is needed, but some devices (such as yuv4mpeg) must output frame
+             otherwise A/V desync will occur. -- Alvieboy
+	     */
+	    if (vo_config_count)
+		video_out->control(VOCTRL_DUPLICATE_FRAME, NULL);
+         }
+        }
+//====================== A-V TIMESTAMP CORRECTION: =========================
+
+  current_module="av_sync";
+
+  if(sh_audio){
+    float a_pts=0;
+    float v_pts=0;
+
+    // unplayed bytes in our and soundcard/dma buffer:
+    float delay=playback_speed*audio_out->get_delay()+(float)sh_audio->a_buffer_len/(float)sh_audio->o_bps;
+
+    if (autosync){
+      /*
+       * If autosync is enabled, the value for delay must be calculated
+       * a bit differently.  It is set only to the difference between
+       * the audio and video timers.  Any attempt to include the real
+       * or corrected delay causes the pts_correction code below to
+       * try to correct for the changes in delay which autosync is
+       * trying to measure.  This keeps the two from competing, but still
+       * allows the code to correct for PTS drift *only*.  (Using a delay
+       * value here, even a "corrected" one, would be incompatible with
+       * autosync mode.)
+       */
+      delay=sh_audio->delay;
+      delay+=(float)sh_audio->a_buffer_len/(float)sh_audio->o_bps;
+    }
+
+#if 0
+    if(pts_from_bps){
+	// PTS = sample_no / samplerate
+        unsigned int samples=
+//	  (sh_audio->audio.dwSampleSize)?
+//          ((ds_tell(d_audio)-sh_audio->a_in_buffer_len)/sh_audio->audio.dwSampleSize) :
+          ds_tell_block(d_audio); // <- used for VBR audio
+	samples+=sh_audio->audio.dwStart; // offset
+        a_pts=samples*(float)sh_audio->audio.dwScale/(float)sh_audio->audio.dwRate;
+	delay_corrected=1;
+	a_pts-=(sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps;
+    } else 
+#endif
+    {
+      // PTS = (last timestamp) + (bytes after last timestamp)/(bytes per sec)
+      a_pts=d_audio->pts;
+      if(!delay_corrected) if(a_pts) delay_corrected=1;
+#if 0
+      printf("\n#X# pts=%5.3f ds_pts=%5.3f buff=%5.3f total=%5.3f\n",
+          a_pts,
+	  ds_tell_pts(d_audio)/(float)sh_audio->i_bps,
+	  -sh_audio->a_in_buffer_len/(float)sh_audio->i_bps,
+	  a_pts+(ds_tell_pts(d_audio)-sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps);
+#endif	  
+      a_pts+=(ds_tell_pts(d_audio)-sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps;
+    }
+    v_pts=sh_video ? sh_video->pts : d_video->pts;
+
+      mp_dbg(MSGT_AVSYNC,MSGL_DBG2,"### A:%8.3f (%8.3f)  V:%8.3f  A-V:%7.4f  \n",a_pts,a_pts-audio_delay-delay,v_pts,(a_pts-delay-audio_delay)-v_pts);
+
+      if(delay_corrected){
+	static int drop_message=0;
+        float x;
+	AV_delay=(a_pts-delay-audio_delay)-v_pts;
+	if(AV_delay>0.5 && drop_frame_cnt>50 && drop_message==0){
+	  ++drop_message;
+	  mp_msg(MSGT_AVSYNC,MSGL_WARN,MSGTR_SystemTooSlow);
+	}
+        x=AV_delay*0.1f;
+        if(x<-max_pts_correction) x=-max_pts_correction; else
+        if(x> max_pts_correction) x= max_pts_correction;
+        if(default_max_pts_correction>=0)
+          max_pts_correction=default_max_pts_correction;
+        else
+          max_pts_correction=sh_video->frametime*0.10; // +-10% of time
+	if(!frame_time_remaining){ sh_audio->delay+=x; c_total+=x;} // correction
+        if(!quiet) mp_msg(MSGT_AVSYNC,MSGL_STATUS,"A:%6.1f V:%6.1f A-V:%7.3f ct:%7.3f  %3d/%3d  %2d%% %2d%% %4.1f%% %d %d %d%%\r",
+	  a_pts-audio_delay-delay,v_pts,AV_delay,c_total,
+          (int)sh_video->num_frames,(int)sh_video->num_frames_decoded,
+          (sh_video->timer>0.5)?(int)(100.0*video_time_usage*playback_speed/(double)sh_video->timer):0,
+          (sh_video->timer>0.5)?(int)(100.0*vout_time_usage*playback_speed/(double)sh_video->timer):0,
+          (sh_video->timer>0.5)?(100.0*audio_time_usage*playback_speed/(double)sh_video->timer):0
+          ,drop_frame_cnt
+	  ,output_quality
+	  ,cache_fill_status
+        );
+        fflush(stdout);
+      }
+    
+  } else {
+    // No audio:
+    
+    if(!quiet)
+      mp_msg(MSGT_AVSYNC,MSGL_STATUS,"V:%6.1f  %3d  %2d%% %2d%% %4.1f%% %d %d %d%%\r",sh_video->pts,
+        (int)sh_video->num_frames,
+        (sh_video->timer>0.5)?(int)(100.0*video_time_usage/(double)sh_video->timer):0,
+        (sh_video->timer>0.5)?(int)(100.0*vout_time_usage/(double)sh_video->timer):0,
+        (sh_video->timer>0.5)?(100.0*audio_time_usage/(double)sh_video->timer):0
+          ,drop_frame_cnt
+	  ,output_quality
+	  ,cache_fill_status
+        );
+
+      fflush(stdout);
+
+  }
+
+//============================ Auto QUALITY ============================
+
+/*Output quality adjustments:*/
+if(auto_quality>0){
+  current_module="autoq";
+//  float total=0.000001f * (GetTimer()-aq_total_time);
+//  if(output_quality<auto_quality && aq_sleep_time>0.05f*total)
+  if(output_quality<auto_quality && aq_sleep_time>0)
+      ++output_quality;
+  else
+//  if(output_quality>0 && aq_sleep_time<-0.05f*total)
+  if(output_quality>1 && aq_sleep_time<0)
+      --output_quality;
+  else
+  if(output_quality>0 && aq_sleep_time<-0.050f) // 50ms
+      output_quality=0;
+//  printf("total: %8.6f  sleep: %8.6f  q: %d\n",(0.000001f*aq_total_time),aq_sleep_time,output_quality);
+  set_video_quality(sh_video,output_quality);
+}
+
+} // end if(sh_video)
+
+//============================ Handle PAUSE ===============================
+
+  current_module="pause";
+
+#ifdef USE_OSD
+  if(osd_visible){
+    if (!--osd_visible){
+       vo_osd_progbar_type=-1; // disable
+       vo_osd_changed(OSDTYPE_PROGBAR);
+       if (osd_function != OSD_PAUSE)
+	   osd_function = OSD_PLAY;
+    }
+  }
+#endif
+
+  if(osd_function==OSD_PAUSE){
+    mp_cmd_t* cmd;
+      if(!quiet) {
+	mp_msg(MSGT_CPLAYER,MSGL_STATUS,MSGTR_Paused);
+	fflush(stdout);
+      }
+#ifdef HAVE_NEW_GUI
+      if(use_gui) guiGetEvent( guiCEvent,(char *)guiSetPause );
+#endif
+      if (video_out && sh_video && vo_config_count)
+	 video_out->control(VOCTRL_PAUSE, NULL);
+
+      if (audio_out && sh_audio)
+         audio_out->pause();	// pause audio, keep data if possible
+
+      while( (cmd = mp_input_get_cmd(20,1)) == NULL) {
+	     if(sh_video && video_out && vo_config_count) video_out->check_events();
+#ifdef HAVE_NEW_GUI
+             if(use_gui){
+		guiEventHandling();
+		guiGetEvent( guiReDraw,NULL );
+		if(guiIntfStruct.Playing!=2 || (rel_seek_secs || abs_seek_pos)) break;
+             }
+#endif
+#ifdef HAVE_MENU
+	     if(vf_menu)
+	       vf_menu_pause_update(vf_menu);
+#endif
+             usec_sleep(20000);
+         }
+      mp_cmd_free(cmd);
+         osd_function=OSD_PLAY;
+      if (audio_out && sh_audio)
+        audio_out->resume();	// resume audio
+      if (video_out && sh_video && vo_config_count)
+        video_out->control(VOCTRL_RESUME, NULL);	// resume video
+      (void)GetRelativeTime();	// keep TF around FT in next cycle
+#ifdef HAVE_NEW_GUI
+      if (use_gui) 
+       {
+        if ( guiIntfStruct.Playing == guiSetStop ) goto goto_next_file;
+        guiGetEvent( guiCEvent,(char *)guiSetPlay );
+       }
+#endif
+  }
+
+// handle -sstep
+if(step_sec>0) {
+	osd_function=OSD_FFW;
+	rel_seek_secs+=step_sec;
+}
+
+#ifdef USE_DVDNAV
+if (stream->type==STREAMTYPE_DVDNAV && dvd_nav_still)
+    dvdnav_stream_sleeping((dvdnav_priv_t*)stream->priv);
+#endif
+
+//================= EDL =========================================
+
+#ifdef USE_EDL
+ if( next_edl_record->next ) { // Are we (still?) doing EDL?
+  if ( !sh_video ) {
+    mp_msg( MSGT_CPLAYER, MSGL_ERR, "Cannot use edit list without video. EDL disabled.\n" );
+    next_edl_record->next = NULL;
+  } else {
+   if( sh_video->pts >= next_edl_record->start_sec ) {
+     if( next_edl_record->action == EDL_SKIP ) {
+       osd_function = OSD_FFW;
+       abs_seek_pos = 0;
+       rel_seek_secs = next_edl_record->length_sec;
+#ifdef DEBUG_EDL
+       printf( "\nEDL_SKIP: start [%f], stop [%f], length [%f]\n", next_edl_record->start_sec, next_edl_record->stop_sec, next_edl_record->length_sec );
+#endif
+       edl_decision = 1;
+       next_edl_record = next_edl_record->next;
+     } else if( next_edl_record->action == EDL_MUTE ) {
+       mixer_mute(&mixer);
+#ifdef DEBUG_EDL
+       printf( "\nEDL_MUTE: [%f]\n", next_edl_record->start_sec );
+#endif
+       edl_decision = 1;
+       next_edl_record = next_edl_record->next;
+     }
+   }
+  }
+ }
+#endif
+
+//================= Keyboard events, SEEKing ====================
+
+  current_module="key_events";
+
+{
+  mp_cmd_t* cmd;
+  int brk_cmd = 0;
+  while( !brk_cmd && (cmd = mp_input_get_cmd(0,0)) != NULL) {
+    switch(cmd->id) {
+    case MP_CMD_SEEK : {
+      int v,abs;
+      osd_show_percentage = 25;
+      v = cmd->args[0].v.i;
+      abs = (cmd->nargs > 1) ? cmd->args[1].v.i : 0;
+      if(abs==2) { /* Absolute seek to a specific timestamp in seconds */
+        abs_seek_pos = 1;
+	if(sh_video)
+	  osd_function= (v > sh_video->timer) ? OSD_FFW : OSD_REW;
+	rel_seek_secs = v;
+      }
+      else if(abs) { /* Absolute seek by percentage */
+	abs_seek_pos = 3;
+	if(sh_video)
+	  osd_function= (v > sh_video->timer) ? OSD_FFW : OSD_REW;
+	rel_seek_secs = v/100.0;
+      }
+      else {
+	rel_seek_secs+= v;
+	osd_function= (v > 0) ? OSD_FFW : OSD_REW;
+      }
+      brk_cmd = 1;
+    } break;
+#ifdef USE_EDL
+    case MP_CMD_EDL_MARK:
+      if( edl_fd ) {
+	float v = sh_video->pts;
+	fprintf( edl_fd, "%f %f %d\n", v-2, v, 0 );
+      }
+      break;
+#endif
+    case MP_CMD_AUDIO_DELAY : {
+      float v = cmd->args[0].v.f;
+      audio_delay += v;
+      osd_show_av_delay = 9;
+      if(sh_audio) sh_audio->delay+= v;
+    } break;
+    case MP_CMD_PAUSE : {
+      osd_function=OSD_PAUSE;
+      brk_cmd = 1;
+    } break;
+    case MP_CMD_QUIT : {
+      exit_player_with_rc(MSGTR_Exit_quit, 0);
+    }
+    case MP_CMD_GRAB_FRAMES : {
+      grab_frames=2;
+    } break;
+    case MP_CMD_PLAY_TREE_STEP : {
+      int n = cmd->args[0].v.i == 0 ? 1 : cmd->args[0].v.i;
+      int force = cmd->args[1].v.i;
+
+#ifdef HAVE_NEW_GUI
+     if (use_gui) {
+	int i=0;
+        if (n>0)
+	  for (i=0;i<n;i++)
+	    mplNext();
+        else
+	  for (i=0;i<-1*n;i++)
+	    mplPrev();
+     } else
+#endif
+     {
+      if(!force && playtree_iter) {
+	play_tree_iter_t* i = play_tree_iter_new_copy(playtree_iter);
+	
+	if(play_tree_iter_step(i,n,0) == PLAY_TREE_ITER_ENTRY)
+	  eof = (n > 0) ? PT_NEXT_ENTRY : PT_PREV_ENTRY;
+	play_tree_iter_free(i);
+      } else
+	eof = (n > 0) ? PT_NEXT_ENTRY : PT_PREV_ENTRY;
+      if(eof)
+	play_tree_step = n;
+      brk_cmd = 1;
+     }
+    } break;
+    case MP_CMD_PLAY_TREE_UP_STEP : {
+      int n = cmd->args[0].v.i > 0 ? 1 : -1;
+      int force = cmd->args[1].v.i;
+
+      if(!force && playtree_iter) {
+	play_tree_iter_t* i = play_tree_iter_new_copy(playtree_iter);
+	if(play_tree_iter_up_step(i,n,0) == PLAY_TREE_ITER_ENTRY)
+	  eof = (n > 0) ? PT_UP_NEXT : PT_UP_PREV;
+	play_tree_iter_free(i);
+      } else
+	eof = (n > 0) ? PT_UP_NEXT : PT_UP_PREV;
+      brk_cmd = 1;
+    } break;
+    case MP_CMD_PLAY_ALT_SRC_STEP : {
+      if(playtree_iter && playtree_iter->num_files > 1) {
+	int v = cmd->args[0].v.i;
+	if(v > 0 && playtree_iter->file < playtree_iter->num_files)
+	  eof = PT_NEXT_SRC;
+	else if(v < 0 && playtree_iter->file > 1)
+	  eof = PT_PREV_SRC;
+      }
+      brk_cmd = 1;
+    } break;
+    case MP_CMD_SUB_DELAY : {
+#ifdef USE_SUB
+    if (sh_video) {
+      int abs= cmd->args[1].v.i;
+      float v = cmd->args[0].v.f;
+      if(abs)
+	sub_delay = v;
+      else
+	sub_delay += v;
+      osd_show_sub_delay = 9; // show the subdelay in OSD
+    }
+#endif
+    } break;
+    case MP_CMD_SUB_STEP : {
+#ifdef USE_SUB
+    if (sh_video) {
+      int movement = cmd->args[0].v.i;
+      step_sub(subdata, sh_video->pts, movement);
+      osd_show_sub_delay = 9; // show the subdelay in OSD
+    }
+#endif
+    } break;
+    case MP_CMD_OSD :  {
+#ifdef USE_OSD
+      if(sh_video) {
+	int v = cmd->args[0].v.i;
+	if(v < 0)
+	  osd_level=(osd_level+1)%(MAX_OSD_LEVEL+1);
+	else
+	  osd_level= v > MAX_OSD_LEVEL ? MAX_OSD_LEVEL : v;
+      }
+#endif
+    } break;
+    case MP_CMD_OSD_SHOW_TEXT :  {
+#ifdef USE_OSD
+      if(osd_level && sh_video){
+	osd_show_text=sh_video->fps; // 1 sec
+        strncpy(osd_show_text_buffer, cmd->args[0].v.s, 64);
+      }
+#endif
+    } break;
+    case MP_CMD_VOLUME :  {
+      int v = cmd->args[0].v.i;
+
+		// start change for absolute volume value
+		int abs = (cmd->nargs > 1) ? cmd->args[1].v.i : 0;
+		
+		if( abs )
+		{
+			mixer_setvolume(&mixer, (float)v, (float)v );
+		} else {
+      if(v > 0)
+	mixer_incvolume(&mixer);
+      else
+	mixer_decvolume(&mixer);
+		}
+	  
+#ifdef USE_OSD
+      if(osd_level && sh_video){
+        float vol;
+	osd_visible=sh_video->fps; // 1 sec
+	vo_osd_progbar_type=OSD_VOLUME;
+	mixer_getbothvolume(&mixer, &vol);
+	vo_osd_progbar_value=(vol*256.0)/100.0;
+	vo_osd_changed(OSDTYPE_PROGBAR);
+      }
+#endif
+    } break;
+    case MP_CMD_MUTE:
+      mixer_mute(&mixer);
+      break;
+    case MP_CMD_LOADFILE : {
+      play_tree_t* e = play_tree_new();
+      play_tree_add_file(e,cmd->args[0].v.s);
+
+      // Go back to the start point
+      while(play_tree_iter_up_step(playtree_iter,0,1) != PLAY_TREE_ITER_END)
+	/* NOP */;
+      play_tree_free_list(playtree->child,1);
+      play_tree_set_child(playtree,e);
+      play_tree_iter_step(playtree_iter,0,0);
+      eof = PT_NEXT_SRC;
+      brk_cmd = 1;
+    } break;
+    case MP_CMD_LOADLIST : {
+      play_tree_t* e = parse_playlist_file(cmd->args[0].v.s);
+      if(!e)
+	mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_PlaylistLoadUnable,cmd->args[0].v.s);
+      else {
+	// Go back to the start point
+	while(play_tree_iter_up_step(playtree_iter,0,1) != PLAY_TREE_ITER_END)
+	  /* NOP */;
+	play_tree_free_list(playtree->child,1);
+	play_tree_set_child(playtree,e);
+	play_tree_iter_step(playtree_iter,0,0);
+	eof = PT_NEXT_SRC;	
+      }
+      brk_cmd = 1;
+    } break;
+    case MP_CMD_GAMMA :  {
+      int v = cmd->args[0].v.i, abs = cmd->args[1].v.i;
+
+      if (!sh_video)
+	break;
+
+      if (vo_gamma_gamma == 1000)
+      {
+	vo_gamma_gamma = 0;
+	get_video_colors (sh_video, "gamma", &vo_gamma_gamma);
+      }
+
+      if (abs)
+        vo_gamma_gamma = v;
+      else
+        vo_gamma_gamma += v;
+
+      if (vo_gamma_gamma > 100)
+        vo_gamma_gamma = 100;
+      else if (vo_gamma_gamma < -100)
+        vo_gamma_gamma = -100;
+      set_video_colors(sh_video, "gamma", vo_gamma_gamma);
+#ifdef USE_OSD
+       if(osd_level){
+	 osd_visible=sh_video->fps; // 1 sec
+	 vo_osd_progbar_type=OSD_BRIGHTNESS;
+	 vo_osd_progbar_value=(vo_gamma_gamma<<7)/100 + 128;
+	 vo_osd_changed(OSDTYPE_PROGBAR);
+       }
+#endif // USE_OSD
+    } break;
+    case MP_CMD_BRIGHTNESS :  {
+      int v = cmd->args[0].v.i, abs = cmd->args[1].v.i;
+      
+      if (!sh_video)
+	break;
+      
+      if (vo_gamma_brightness == 1000)
+      {
+	vo_gamma_brightness = 0;
+	get_video_colors(sh_video, "brightness", &vo_gamma_brightness);
+      }
+
+      if (abs)
+        vo_gamma_brightness = v;
+      else
+        vo_gamma_brightness += v;
+
+      if (vo_gamma_brightness > 100)
+        vo_gamma_brightness = 100;
+      else if (vo_gamma_brightness < -100)
+        vo_gamma_brightness = -100;
+      if(set_video_colors(sh_video, "brightness", vo_gamma_brightness)){
+#ifdef USE_OSD
+       if(osd_level){
+	 osd_visible=sh_video->fps; // 1 sec
+	 vo_osd_progbar_type=OSD_BRIGHTNESS;
+	 vo_osd_progbar_value=(vo_gamma_brightness<<7)/100 + 128;
+	 vo_osd_changed(OSDTYPE_PROGBAR);
+       }
+#endif // USE_OSD
+      }
+    } break;
+    case MP_CMD_CONTRAST :  {
+      int v = cmd->args[0].v.i, abs = cmd->args[1].v.i;
+
+      if (!sh_video)
+	break;
+      
+      if (vo_gamma_contrast == 1000)
+      {
+	vo_gamma_contrast = 0;
+	get_video_colors(sh_video, "contrast", &vo_gamma_contrast);
+      }
+     
+      if (abs)
+        vo_gamma_contrast = v;
+      else
+        vo_gamma_contrast += v;
+
+      if (vo_gamma_contrast > 100)
+        vo_gamma_contrast = 100;
+      else if (vo_gamma_contrast < -100)
+        vo_gamma_contrast = -100;
+      if(set_video_colors(sh_video, "contrast", vo_gamma_contrast)){
+#ifdef USE_OSD
+       if(osd_level){
+	 osd_visible=sh_video->fps; // 1 sec
+	 vo_osd_progbar_type=OSD_CONTRAST;
+	 vo_osd_progbar_value=(vo_gamma_contrast<<7)/100 + 128;
+	 vo_osd_changed(OSDTYPE_PROGBAR);
+       }
+#endif // USE_OSD
+      }
+    } break;
+    case MP_CMD_SATURATION :  {
+      int v = cmd->args[0].v.i, abs = cmd->args[1].v.i;
+
+      if (!sh_video)
+	break;
+      
+      if (vo_gamma_saturation == 1000)
+      {
+	vo_gamma_saturation = 0;
+	get_video_colors(sh_video, "saturation", &vo_gamma_saturation);
+      }
+
+      if (abs)
+        vo_gamma_saturation = v;
+      else
+        vo_gamma_saturation += v;
+
+      if (vo_gamma_saturation > 100)
+        vo_gamma_saturation = 100;
+      else if (vo_gamma_saturation < -100)
+        vo_gamma_saturation = -100;
+      if(set_video_colors(sh_video, "saturation", vo_gamma_saturation)){
+#ifdef USE_OSD
+       if(osd_level){
+	 osd_visible=sh_video->fps; // 1 sec
+	 vo_osd_progbar_type=OSD_SATURATION;
+	 vo_osd_progbar_value=(vo_gamma_saturation<<7)/100 + 128;
+	 vo_osd_changed(OSDTYPE_PROGBAR);
+       }
+#endif // USE_OSD
+      }
+    } break;
+    case MP_CMD_HUE :  {
+      int v = cmd->args[0].v.i, abs = cmd->args[1].v.i;
+
+      if (!sh_video)
+	break;
+      
+      if (vo_gamma_hue == 1000)
+      {
+	vo_gamma_hue = 0;
+	get_video_colors(sh_video, "hue", &vo_gamma_hue);
+      }
+     
+      if (abs)
+        vo_gamma_hue = v;
+      else
+        vo_gamma_hue += v;
+
+      if (vo_gamma_hue > 100)
+        vo_gamma_hue = 100;
+      else if (vo_gamma_hue < -100)
+        vo_gamma_hue = -100;
+      if(set_video_colors(sh_video, "hue", vo_gamma_hue)){
+#ifdef USE_OSD
+       if(osd_level){
+	 osd_visible=sh_video->fps; // 1 sec
+	 vo_osd_progbar_type=OSD_HUE;
+	 vo_osd_progbar_value=(vo_gamma_hue<<7)/100 + 128;
+	 vo_osd_changed(OSDTYPE_PROGBAR);
+       }
+#endif // USE_OSD
+      }
+    } break;
+    case MP_CMD_FRAMEDROPPING :  {
+      int v = cmd->args[0].v.i;
+      if(v < 0){
+	frame_dropping = (frame_dropping+1)%3;
+#ifdef USE_OSD
+       osd_show_framedropping=10;
+       vo_osd_changed(OSDTYPE_SUBTITLE);
+#endif
+      }
+      else
+	frame_dropping = v > 2 ? 2 : v;
+    } break;
+#ifdef USE_TV
+    case MP_CMD_TV_SET_FREQ :  {
+      if (file_format == DEMUXER_TYPE_TV)
+        tv_set_freq((tvi_handle_t*)(demuxer->priv), cmd->args[0].v.f * 16.0);
+    } break;
+    case MP_CMD_TV_SET_NORM :  {
+      if (file_format == DEMUXER_TYPE_TV)
+        tv_set_norm((tvi_handle_t*)(demuxer->priv), cmd->args[0].v.s);
+    } break;
+    case MP_CMD_TV_SET_BRIGHTNESS :  {
+      if (file_format == DEMUXER_TYPE_TV)
+        tv_set_color_options((tvi_handle_t*)(demuxer->priv), TV_COLOR_BRIGHTNESS, cmd->args[0].v.i);
+    } break;
+    case MP_CMD_TV_SET_HUE :  {
+      if (file_format == DEMUXER_TYPE_TV)
+        tv_set_color_options((tvi_handle_t*)(demuxer->priv), TV_COLOR_HUE, cmd->args[0].v.i);
+    } break;
+    case MP_CMD_TV_SET_SATURATION :  {
+      if (file_format == DEMUXER_TYPE_TV)
+        tv_set_color_options((tvi_handle_t*)(demuxer->priv), TV_COLOR_SATURATION, cmd->args[0].v.i);
+    } break;
+    case MP_CMD_TV_SET_CONTRAST :  {
+      if (file_format == DEMUXER_TYPE_TV)
+        tv_set_color_options((tvi_handle_t*)(demuxer->priv), TV_COLOR_CONTRAST, cmd->args[0].v.i);
+    } break;
+    case MP_CMD_TV_STEP_CHANNEL :  {
+      if (file_format == DEMUXER_TYPE_TV) {
+	int v = cmd->args[0].v.i;
+	if(v > 0){
+	  tv_step_channel((tvi_handle_t*)(demuxer->priv), TV_CHANNEL_HIGHER);
+#ifdef USE_OSD
+	  if (tv_channel_list) {
+	    osd_show_tv_channel = sh_video->fps;
+	    vo_osd_changed(OSDTYPE_SUBTITLE);
+	  }
+#endif
+	} else {
+	  tv_step_channel((tvi_handle_t*)(demuxer->priv), TV_CHANNEL_LOWER);
+#ifdef USE_OSD
+	  if (tv_channel_list) {
+	    osd_show_tv_channel = sh_video->fps;
+	    vo_osd_changed(OSDTYPE_SUBTITLE);
+	  }
+#endif
+	}
+      }
+    } 
+#ifdef HAS_DVBIN_SUPPORT
+	if((stream->type == STREAMTYPE_DVB) && stream->priv)
+	{
+	  dvb_priv_t *priv = (dvb_priv_t*) stream->priv;
+	  if(priv->is_on)
+	  {
+		int dir;
+		int v = cmd->args[0].v.i;
+	    
+		last_dvb_step = v;	
+		if(v > 0)
+			dir = DVB_CHANNEL_HIGHER;
+		else
+			dir = DVB_CHANNEL_LOWER;
+			
+			
+		if(dvb_step_channel(priv, dir))
+		{
+	  		uninit_player(INITED_ALL-(INITED_STREAM|INITED_INPUT));
+			cache_uninit(stream);
+			goto goto_enable_cache;
+		}
+	  }
+	}
+#endif	
+    break;
+    case MP_CMD_TV_SET_CHANNEL :  {
+      if (file_format == DEMUXER_TYPE_TV) {
+	tv_set_channel((tvi_handle_t*)(demuxer->priv), cmd->args[0].v.s);
+#ifdef USE_OSD
+	if (tv_channel_list) {
+		osd_show_tv_channel = sh_video->fps;
+		vo_osd_changed(OSDTYPE_SUBTITLE);
+	}
+#endif
+      }
+    } break;
+#ifdef HAS_DVBIN_SUPPORT	
+  case MP_CMD_DVB_SET_CHANNEL:  
+  {
+	if((stream->type == STREAMTYPE_DVB) && stream->priv)
+	{
+	  dvb_priv_t *priv = (dvb_priv_t*) stream->priv;
+	  if(priv->is_on)
+	  {
+		if(priv->list->current <= cmd->args[0].v.i)
+		    last_dvb_step = 1;
+		else
+		    last_dvb_step = -1;
+
+  		if(dvb_set_channel(priv, cmd->args[1].v.i, cmd->args[0].v.i))
+		{
+	  	  uninit_player(INITED_ALL-(INITED_STREAM|INITED_INPUT));
+		  cache_uninit(stream);
+		  goto goto_enable_cache;
+		}
+	  }
+	}
+  }
+#endif	
+    case MP_CMD_TV_LAST_CHANNEL :  {
+      if (file_format == DEMUXER_TYPE_TV) {
+	tv_last_channel((tvi_handle_t*)(demuxer->priv));
+#ifdef USE_OSD
+	if (tv_channel_list) {
+		osd_show_tv_channel = sh_video->fps;
+		vo_osd_changed(OSDTYPE_SUBTITLE);
+	}
+#endif
+      }
+    } break;
+    case MP_CMD_TV_STEP_NORM :  {
+      if (file_format == DEMUXER_TYPE_TV)
+	tv_step_norm((tvi_handle_t*)(demuxer->priv));
+    } break;
+    case MP_CMD_TV_STEP_CHANNEL_LIST :  {
+      if (file_format == DEMUXER_TYPE_TV)
+	tv_step_chanlist((tvi_handle_t*)(demuxer->priv));
+    } break;
+#endif
+    case MP_CMD_VO_FULLSCREEN:
+    {
+#ifdef HAVE_NEW_GUI
+     if ( use_gui ) guiGetEvent( guiIEvent,(char *)MP_CMD_GUI_FULLSCREEN );
+      else
+#endif
+	if(video_out && vo_config_count) video_out->control(VOCTRL_FULLSCREEN, 0);
+    } break;
+    case MP_CMD_VO_ONTOP:
+    {
+     if(video_out && vo_config_count) {
+       video_out->control(VOCTRL_ONTOP, 0);
+#ifdef USE_OSD
+       osd_show_ontop=10;
+       vo_osd_changed(OSDTYPE_SUBTITLE);
+#endif
+     }
+
+    } break;
+    case MP_CMD_PANSCAN : {
+      if ( !video_out ) break;
+      if ( video_out->control( VOCTRL_GET_PANSCAN,NULL ) == VO_TRUE )
+       {
+        int abs= cmd->args[1].v.i;
+        float v = cmd->args[0].v.f;
+        float res;
+        if(abs) res = v;
+          else res = vo_panscan+v;
+        vo_panscan = res > 1 ? 1 : res < 0 ? 0 : res;
+        video_out->control( VOCTRL_SET_PANSCAN,NULL );
+#ifdef USE_OSD
+        if(osd_level && sh_video){
+	  osd_visible=sh_video->fps; // 1 sec
+	  vo_osd_progbar_type=OSD_PANSCAN;
+	  vo_osd_progbar_value=vo_panscan*256;
+	  vo_osd_changed(OSDTYPE_PROGBAR);
+#ifdef HAVE_FREETYPE
+	  if (subtitle_autoscale == 2 || subtitle_autoscale == 3)
+	    // force scaling font to movie width or diagonal
+	    force_load_font = 1;
+#endif
+        }
+#endif
+       }
+    } break;
+    case MP_CMD_SUB_POS:
+    {
+#ifdef USE_SUB
+      if (sh_video) {
+        int v;
+	v = cmd->args[0].v.i;
+    
+	sub_pos+=v;
+	if(sub_pos >100) sub_pos=100;
+	if(sub_pos <0) sub_pos=0;
+	vo_osd_changed(OSDTYPE_SUBTITLE);
+        osd_show_sub_pos = 9;
+      }
+#endif
+    } break;
+    case MP_CMD_SUB_ALIGNMENT:
+    {
+#ifdef USE_SUB
+      if (sh_video) {
+    	if (cmd->nargs >= 1)
+    	    sub_alignment = cmd->args[0].v.i;
+    	else
+            sub_alignment = (sub_alignment+1) % 3;
+	osd_show_sub_alignment = 9;
+	vo_osd_changed(OSDTYPE_SUBTITLE);
+      }
+#endif
+    } break;
+    case MP_CMD_SUB_VISIBILITY:
+    {
+#ifdef USE_SUB
+      if (sh_video) {
+	sub_visibility=1-sub_visibility;
+	osd_show_sub_visibility = 9; // show state of subtitle visibility in OSD
+	vo_osd_changed(OSDTYPE_SUBTITLE);
+      }
+#endif
+    } break;
+    case MP_CMD_GET_SUB_VISIBILITY:
+	{
+#ifdef USE_SUB
+	if (sh_video) {
+		mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_SUB_VISIBILITY=%ld\n", sub_visibility);
+	}
+#endif
+	} break;
+    case MP_CMD_VOBSUB_LANG:
+    if (vo_vobsub)
+    {
+	int new_id = vobsub_id + 1;
+	if (vobsub_id < 0)
+	    new_id = 0;
+	if ((unsigned int) new_id >= vobsub_get_indexes_count(vo_vobsub))
+	    new_id = -1;
+        if(new_id != vobsub_id)
+	    osd_show_vobsub_changed = 9;
+	vobsub_id = new_id;
+    }
+#ifdef USE_SUB  
+    else if (set_of_sub_size > 0){ //change subtitle file  
+        set_of_sub_pos = (set_of_sub_pos + 1) % set_of_sub_size;
+        subdata = set_of_subtitles[set_of_sub_pos];
+        osd_show_sub_changed = sh_video->fps;
+        vo_sub = NULL;
+        vo_osd_changed(OSDTYPE_SUBTITLE); 
+    }
+#endif
+        break;
+    case MP_CMD_SUB_FORCED_ONLY:
+      if (vo_spudec) {
+	forced_subs_only = forced_subs_only ? 0 : ~0; // toggle state
+	spudec_set_forced_subs_only(vo_spudec,forced_subs_only);
+      }    
+      break;
+    case MP_CMD_SCREENSHOT :
+      if(vo_config_count) video_out->control(VOCTRL_SCREENSHOT, NULL);
+      break;
+    case MP_CMD_VF_CHANGE_RECTANGLE:
+	set_rectangle(sh_video, cmd->args[0].v.i, cmd->args[1].v.i);
+	break;
+	
+    case MP_CMD_GET_TIME_LENGTH : {
+	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_LENGTH=%ld\n", demuxer_get_time_length(demuxer));
+    } break;
+
+	case MP_CMD_GET_VO_FULLSCREEN : {
+	if(video_out && vo_config_count)
+		mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_VO_FULLSCREEN=%ld\n", vo_fs);
+	} break;
+    
+    case MP_CMD_GET_PERCENT_POS : {
+	mp_msg(MSGT_GLOBAL,MSGL_INFO,"ANS_PERCENT_POSITION=%ld\n", demuxer_get_percent_pos(demuxer));
+    } break;
+
+#ifdef USE_DVDNAV
+    case MP_CMD_DVDNAV_EVENT: {
+      dvdnav_priv_t * dvdnav_priv = (dvdnav_priv_t*)(stream->priv);
+      dvdnav_event_t * dvdnav_event = (dvdnav_event_t *)(cmd->args[0].v.v);
+
+      /* ignore these events if we're not in dvd_nav mode */
+      if (stream->type != STREAMTYPE_DVDNAV) break;
+
+      if (!dvdnav_event) {
+        printf("DVDNAV Event NULL?!\n");
+        break;
+      }
+
+      //printf("mplayer: got event: %d\n",dvdnav_event->event);
+
+      switch (dvdnav_event->event) {
+      case DVDNAV_BLOCK_OK: {
+          /* be silent about this one */
+                break;
+          }
+      case DVDNAV_HIGHLIGHT: {
+          dvdnav_highlight_event_t *hevent = (dvdnav_highlight_event_t*)(dvdnav_event->details);
+          if (!hevent) {
+                printf("DVDNAV Event: Highlight event broken\n");
+                break;
+          }
+
+          if (hevent->display && hevent->buttonN>0)
+          {
+                //dvdnav_priv->seen_root_menu=1; /* if we got a highlight, we're on a menu */
+                sprintf( dvd_nav_text, "Highlight button %d (%u,%u)-(%u,%u) PTS %d (now is %5.2f)",
+                     hevent->buttonN,
+                     hevent->sx,hevent->sy,
+                     hevent->ex,hevent->ey,
+                     hevent->pts, d_video->pts);
+                printf("DVDNAV Event: %s\n",dvd_nav_text);
+                //osd_show_dvd_nav_delay = 60;
+
+                osd_show_dvd_nav_highlight=1;
+                osd_show_dvd_nav_sx=hevent->sx;
+                osd_show_dvd_nav_ex=hevent->ex;
+                osd_show_dvd_nav_sy=hevent->sy;
+                osd_show_dvd_nav_ey=hevent->ey;
+          }
+          else {
+                  osd_show_dvd_nav_highlight=0;
+                  printf("DVDNAV Event: Highlight Hide\n");
+          }
+        break;
+        }
+      case DVDNAV_STILL_FRAME: {
+          dvdnav_still_event_t *still_event = (dvdnav_still_event_t*)(dvdnav_event->details);
+
+          printf( "######################################## DVDNAV Event: Still Frame: %d sec(s)\n", still_event->length );
+          while (dvdnav_stream_sleeping(dvdnav_priv)) {
+            usec_sleep(1000); /* 1ms */
+          }
+          dvdnav_stream_sleep(dvdnav_priv,still_event->length);
+        break;
+        }
+      case DVDNAV_STOP: {
+          printf( "DVDNAV Event: Nav Stop\n" );
+        break;
+        }
+      case DVDNAV_NOP: {
+        printf("DVDNAV Event: Nav NOP\n");
+        break;
+        }
+      case DVDNAV_SPU_STREAM_CHANGE: {
+#if DVDNAVVERSION > 012
+        dvdnav_spu_stream_change_event_t *stream_change = (dvdnav_spu_stream_change_event_t*)(dvdnav_event->details);
+
+        printf("DVDNAV Event: Nav SPU Stream Change: phys: %d/%d/%d logical: %d\n",
+                stream_change->physical_wide,
+                stream_change->physical_letterbox,
+                stream_change->physical_pan_scan,
+                stream_change->logical);
+
+        if (vo_spudec && dvdsub_id!=stream_change->physical_wide) {
+                mp_msg(MSGT_INPUT,MSGL_DBG2,"d_dvdsub->id change: was %d is now %d\n",
+                        d_dvdsub->id,stream_change->physical_wide);
+                // FIXME: need a better way to change SPU id
+                d_dvdsub->id=dvdsub_id=stream_change->physical_wide;
+                if (vo_spudec) spudec_reset(vo_spudec);
+        }
+#else
+        dvdnav_stream_change_event_t *stream_change = (dvdnav_stream_change_event_t*)(dvdnav_event->details);
+
+        printf("DVDNAV Event: Nav SPU Stream Change: phys: %d logical: %d\n",
+                stream_change->physical,
+                stream_change->logical);
+
+        if (vo_spudec && dvdsub_id!=stream_change->physical) {
+                mp_msg(MSGT_INPUT,MSGL_DBG2,"d_dvdsub->id change: was %d is now %d\n",
+                        d_dvdsub->id,stream_change->physical);
+                // FIXME: need a better way to change SPU id
+                d_dvdsub->id=dvdsub_id=stream_change->physical;
+                if (vo_spudec) spudec_reset(vo_spudec);
+        }
+#endif
+        break;
+        }
+      case DVDNAV_AUDIO_STREAM_CHANGE: {
+        int aid_temp;
+#if DVDNAVVERSION > 012
+        dvdnav_audio_stream_change_event_t *stream_change = (dvdnav_audio_stream_change_event_t*)(dvdnav_event->details);
+#else
+        dvdnav_stream_change_event_t *stream_change = (dvdnav_stream_change_event_t*)(dvdnav_event->details);
+#endif
+
+        printf("DVDNAV Event: Nav Audio Stream Change: phys: %d logical: %d\n",
+                stream_change->physical,
+                stream_change->logical);
+
+        aid_temp=stream_change->physical;
+        if (aid_temp>=0) aid_temp+=128; // FIXME: is this sane?
+        if (d_audio && audio_id!=aid_temp) {
+                mp_msg(MSGT_INPUT,MSGL_DBG2,"d_audio->id change: was %d is now %d\n",
+                        d_audio->id,aid_temp);
+                // FIXME: need a bettery way to change audio stream id
+                d_audio->id=dvdsub_id=aid_temp;
+                if(sh_audio) resync_audio_stream(sh_audio);
+        }
+
+        break;
+      }
+      case DVDNAV_VTS_CHANGE: {
+        printf("DVDNAV Event: Nav VTS Change\n");
+        break;
+        }
+      case DVDNAV_CELL_CHANGE: {
+        dvdnav_cell_change_event_t *cell_change = (dvdnav_cell_change_event_t*)(dvdnav_event->details);
+        cell_playback_t * cell_playback = cell_change->new_cell;
+
+        printf("DVDNAV Event: Nav Cell Change\n");
+        osd_show_dvd_nav_highlight=0; /* screen changed, disable menu */
+        /*
+        printf("new still time: %d\n",cell_playback->still_time);
+        printf("new cell_cmd_nr: %d\n",cell_playback->cell_cmd_nr);
+        printf("new playback_time: %02d:%02d:%02d.%02d\n",
+                        cell_playback->playback_time.hour,
+                        cell_playback->playback_time.minute,
+                        cell_playback->playback_time.second,
+                        cell_playback->playback_time.frame_u);
+
+        */
+        //rel_seek_secs=1; // not really: we can't seek, but it'll reset the muxer
+        //abs_seek_pos=0;
+        break;
+        }
+      case DVDNAV_NAV_PACKET: {
+        // printf("DVDNAV Event: Nav Packet\n");
+        break;
+        }
+      case DVDNAV_SPU_CLUT_CHANGE: {
+        uint32_t * new_clut = (uint32_t *)(dvdnav_event->details);
+
+        printf("DVDNAV Event: Nav SPU CLUT Change\n");
+        // send new palette to SPU decoder
+        if (vo_spudec) spudec_update_palette(vo_spudec,new_clut);
+
+        break;
+        }
+      case DVDNAV_SEEK_DONE: {
+        printf("DVDNAV Event: Nav Seek Done\n");
+        break;
+        }
+      }
+
+      // free the dvdnav event
+      free(dvdnav_event->details);
+      free(dvdnav_event);
+      cmd->args[0].v.v=NULL;
+    }
+    case MP_CMD_DVDNAV: {
+      dvdnav_priv_t * dvdnav_priv=(dvdnav_priv_t*)stream->priv;
+
+      /* ignore these events if we're not in dvd_nav mode */
+      if (stream->type != STREAMTYPE_DVDNAV) break;
+
+      switch (cmd->args[0].v.i) {
+        case MP_CMD_DVDNAV_UP:
+          dvdnav_upper_button_select(dvdnav_priv->dvdnav);
+          break;
+        case MP_CMD_DVDNAV_DOWN:
+          dvdnav_lower_button_select(dvdnav_priv->dvdnav);
+          break;
+        case MP_CMD_DVDNAV_LEFT:
+          dvdnav_left_button_select(dvdnav_priv->dvdnav);
+          break;
+        case MP_CMD_DVDNAV_RIGHT:
+          dvdnav_right_button_select(dvdnav_priv->dvdnav);
+          break;
+        case MP_CMD_DVDNAV_MENU:
+          printf("Menu call\n");
+          dvdnav_menu_call(dvdnav_priv->dvdnav,DVD_MENU_Root);
+          break;
+        case MP_CMD_DVDNAV_SELECT:
+          dvdnav_button_activate(dvdnav_priv->dvdnav);
+          break;
+        default:
+          mp_msg(MSGT_CPLAYER, MSGL_V, "Weird DVD Nav cmd %d\n",cmd->args[0].v.i);
+          break;
+      }
+      break;
+    }
+#endif
+    default : {
+#ifdef HAVE_NEW_GUI
+      if ( ( use_gui )&&( cmd->id > MP_CMD_GUI_EVENTS ) ) guiGetEvent( guiIEvent,(char *)cmd->id );
+       else
+#endif
+      mp_msg(MSGT_CPLAYER, MSGL_V, "Received unknown cmd %s\n",cmd->name);
+    }
+    }
+    mp_cmd_free(cmd);
+  }
+}
+
+  if (seek_to_sec) {
+    int a,b; float d;
+    
+    if (sscanf(seek_to_sec, "%d:%d:%f", &a,&b,&d)==3)
+	rel_seek_secs += 3600*a +60*b +d ;
+    else if (sscanf(seek_to_sec, "%d:%f", &a, &d)==2)
+	rel_seek_secs += 60*a +d;
+    else if (sscanf(seek_to_sec, "%f", &d)==1)
+	rel_seek_secs += d;
+
+     seek_to_sec = NULL;
+  }
+  
+  /* Looping. */
+  if(eof==1 && loop_times>=0) {
+    int l = loop_times;
+    play_tree_iter_step(playtree_iter,0,0);
+    loop_times = l;
+    mp_msg(MSGT_CPLAYER,MSGL_V,"loop_times = %d, eof = %d\n", loop_times,eof);
+
+    if(loop_times>1) loop_times--; else
+    if(loop_times==1) loop_times=-1;
+    play_n_frames=play_n_frames_mf;
+    eof=0;
+    abs_seek_pos=3; rel_seek_secs=0; // seek to start of movie (0%)
+    loop_seek = 1;
+  }
+
+if(rel_seek_secs || abs_seek_pos){
+  current_module="seek";
+  if(demux_seek(demuxer,rel_seek_secs,abs_seek_pos)){
+      // success:
+      /* FIXME there should be real seeking for vobsub */
+      if(sh_video) sh_video->pts=d_video->pts;
+      if (vo_vobsub)
+	//vobsub_reset(vo_vobsub);
+	vobsub_seek(vo_vobsub,sh_video->pts);
+#if 0
+      if(sh_video && d_video->packs == 0)
+	ds_fill_buffer(d_video);
+      if(sh_audio){
+	if(d_audio->packs == 0)
+	  ds_fill_buffer(d_audio);
+	if(verbose>0){
+	    float a_pts=d_audio->pts;
+            a_pts+=(ds_tell_pts(d_audio)-sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps;
+	    mp_msg(MSGT_AVSYNC,MSGL_V,"SEEK: A: %5.3f  V: %5.3f  A-V: %5.3f   \n",a_pts,d_video->pts,a_pts-d_video->pts);
+	}
+        mp_msg(MSGT_AVSYNC,MSGL_STATUS,"A:%6.1f  V:%6.1f  A-V:%7.3f  ct: ?   \r",d_audio->pts,d_video->pts,0.0f);
+      } else {
+        mp_msg(MSGT_AVSYNC,MSGL_STATUS,"A: ---   V:%6.1f   \r",d_video->pts);
+      }
+#endif
+      fflush(stdout);
+
+      if(sh_video){
+	 current_module="seek_video_reset";
+         resync_video_stream(sh_video);
+         if(vo_config_count) video_out->control(VOCTRL_RESET,NULL);
+      }
+      
+      if(sh_audio){
+        current_module="seek_audio_reset";
+        audio_out->reset(); // stop audio, throwing away buffered data
+      }
+#ifdef USE_OSD
+        // Set OSD:
+      if(osd_level && !loop_seek){
+#ifdef USE_EDL
+	if( !edl_decision ) {
+#else
+	  if( 1 ) { // Let the compiler optimize this out
+#endif
+	  int len=((demuxer->movi_end-demuxer->movi_start)>>8);
+	  if (len>0 && sh_video){
+	    osd_visible=sh_video->fps; // 1 sec
+	    vo_osd_progbar_type=0;
+	    vo_osd_progbar_value=(demuxer->filepos-demuxer->movi_start)/len;
+	    vo_osd_changed(OSDTYPE_PROGBAR);
+	  }
+	}
+      }
+#endif
+      if(sh_video) {
+	c_total=0;
+	max_pts_correction=0.1;
+	osd_visible=sh_video->fps; // to rewert to PLAY pointer after 1 sec
+	audio_time_usage=0; video_time_usage=0; vout_time_usage=0;
+	drop_frame_cnt=0;
+	too_slow_frame_cnt=0;
+	too_fast_frame_cnt=0;
+
+        if(vo_spudec) spudec_reset(vo_spudec);
+      }
+  }
+#ifdef USE_EDL
+      {
+	int x;
+	if( !edl_decision ) {
+	  for( x = 0; x < num_edl_records; x++ ) { // FIXME: do binary search
+	    // Find first EDL entry where start follows current time
+	    if( edl_records[ x ].start_sec >= sh_video->pts && edl_records[ x ].action != EDL_MUTE ) {
+	      next_edl_record = &edl_records[ x ];
+	      break;
+	    }
+	  }
+	} else {
+	  edl_decision = 0;
+	}
+      }
+#endif
+  rel_seek_secs=0;
+  abs_seek_pos=0;
+  frame_time_remaining=0;
+  current_module=NULL;
+  loop_seek=0;
+}
+
+#ifdef HAVE_NEW_GUI
+      if(use_gui){
+        guiEventHandling();
+	if(demuxer->file_format==DEMUXER_TYPE_AVI && sh_video && sh_video->video.dwLength>2){
+	  // get pos from frame number / total frames
+	  guiIntfStruct.Position=(float)d_video->pack_no*100.0f/sh_video->video.dwLength;
+	} else {
+	 off_t len = ( demuxer->movi_end - demuxer->movi_start );
+	 off_t pos = ( demuxer->file_format == DEMUXER_TYPE_AUDIO?stream->pos:demuxer->filepos );
+	 guiIntfStruct.Position=(len <= 0? 0.0f : ( pos - demuxer->movi_start ) * 100.0f / len );
+	}
+	if ( sh_video ) guiIntfStruct.TimeSec=sh_video->pts;
+	  else if ( sh_audio ) guiIntfStruct.TimeSec=sh_audio->delay;
+	guiIntfStruct.LengthInSec=demuxer_get_time_length(demuxer);
+	guiGetEvent( guiReDraw,NULL );
+	guiGetEvent( guiSetVolume,NULL );
+	if(guiIntfStruct.Playing==0) break; // STOP
+	if(guiIntfStruct.Playing==2) osd_function=OSD_PAUSE;
+        if ( guiIntfStruct.DiskChanged || guiIntfStruct.NewPlay ) goto goto_next_file;
+#ifdef USE_DVDREAD
+        if ( stream->type == STREAMTYPE_DVD )
+	 {
+	  dvd_priv_t * dvdp = stream->priv;
+	  guiIntfStruct.DVD.current_chapter=dvd_chapter_from_cell(dvdp,guiIntfStruct.DVD.current_title-1, dvdp->cur_cell)+1;
+	 }
+#endif
+      }
+#endif
+
+
+//================= Update OSD ====================
+#ifdef USE_OSD
+  if(osd_level>=1 && sh_video){
+      int pts=sh_video->pts;
+      char osd_text_tmp[64];
+      if(pts==osd_last_pts-1) ++pts; else osd_last_pts=pts;
+      vo_osd_text=osd_text_buffer;
+#ifdef USE_DVDNAV
+      if (osd_show_dvd_nav_delay) {
+          snprintf(osd_text_tmp, 63, "DVDNAV: %s", dvd_nav_text);
+          osd_show_dvd_nav_delay--;
+      } else
+#endif
+#ifdef USE_TV
+      if (osd_show_tv_channel && tv_channel_list) {
+	  snprintf(osd_text_tmp, 63, "Channel: %s", tv_channel_current->name);
+	  osd_show_tv_channel--;
+      } else
+#endif
+      if (osd_show_text) {
+	  snprintf(osd_text_tmp, 63, "%s", osd_show_text_buffer);
+	  osd_show_text--;
+      } else
+      if (osd_show_sub_visibility) {
+	  snprintf(osd_text_tmp, 63, "Subtitles: %sabled", sub_visibility?"en":"dis");
+	  osd_show_sub_visibility--;
+      } else
+      if (osd_show_vobsub_changed) {
+	  const char *language = "none";
+	  if (vo_vobsub && vobsub_id >= 0)
+	      language = vobsub_get_id(vo_vobsub, (unsigned int) vobsub_id);
+	  snprintf(osd_text_tmp, 63, "Subtitles: (%d) %s", vobsub_id, language ? language : "unknown");
+	  osd_show_vobsub_changed--;
+      } else
+#ifdef USE_SUB
+      if (osd_show_sub_changed) {
+	  char *tmp2;
+          tmp = subdata->filename;
+	  if ((tmp2 = strrchr(tmp, '/'))) {
+	      tmp = tmp2+1;
+	  }
+	  snprintf(osd_text_tmp, 63, "Sub: (%d) %s%s", 
+                                  set_of_sub_pos + 1,
+                                  strlen(tmp) < 20 ? "" : "...",
+                                  strlen(tmp) < 20 ? tmp : tmp+strlen(tmp)-19);
+	  osd_show_sub_changed--;
+      } else
+#endif
+      if (osd_show_sub_delay) {
+	  snprintf(osd_text_tmp, 63, "Sub delay: %d ms", ROUND(sub_delay*1000));
+	  osd_show_sub_delay--;
+      } else
+      if (osd_show_sub_pos) {
+         snprintf(osd_text_tmp, 63, "Sub position: %d/100", sub_pos);
+         osd_show_sub_pos--;
+      } else
+      if (osd_show_sub_alignment) {
+         snprintf(osd_text_tmp, 63, "Sub alignment: %s",
+	    (sub_alignment == 2 ? "bottom" :
+	    (sub_alignment == 1 ? "center" : "top")));
+         osd_show_sub_alignment--;
+      } else
+      if (osd_show_av_delay) {
+	  snprintf(osd_text_tmp, 63, "A-V delay: %d ms", ROUND(audio_delay*1000));
+	  osd_show_av_delay--;
+      } else if (osd_show_ontop) {
+	  snprintf(osd_text_tmp, 63, "Stay on top: %sabled", vo_ontop?"en":"dis");
+	  osd_show_ontop--;
+      } else if (osd_show_framedropping) {
+	  snprintf(osd_text_tmp, 63, "Framedropping: %s",
+	     (frame_dropping == 1 ? "on" :
+	     (frame_dropping == 2 ? "hard"  : "off")));
+	  osd_show_framedropping--;
+      } else if(osd_level>=2) {
+          int len = demuxer_get_time_length(demuxer);
+          int percentage = -1;
+          char percentage_text[10];
+          if (osd_show_percentage) {
+            percentage = demuxer_get_percent_pos(demuxer);
+            osd_show_percentage--;
+          }
+          if (percentage >= 0)
+            snprintf(percentage_text, 9, " (%d%%)", percentage);
+	  else
+	    percentage_text[0] = 0;
+          if (osd_level == 3) 
+            snprintf(osd_text_tmp, 63, "%c %02d:%02d:%02d / %02d:%02d:%02d%s",osd_function,pts/3600,(pts/60)%60,pts%60,len/3600,(len/60)%60,len%60,percentage_text);
+          else
+            snprintf(osd_text_tmp, 63, "%c %02d:%02d:%02d%s",osd_function,pts/3600,(pts/60)%60,pts%60,percentage_text);
+      } else osd_text_tmp[0]=0;
+      
+      if(strcmp(vo_osd_text, osd_text_tmp)) {
+	      strncpy(vo_osd_text, osd_text_tmp, 63);
+	      vo_osd_changed(OSDTYPE_OSD);
+      }
+  } else {
+      if(vo_osd_text) {
+      vo_osd_text=NULL;
+	  vo_osd_changed(OSDTYPE_OSD);
+      }
+  }
+//  for(i=1;i<=11;i++) osd_text_buffer[10+i]=i;osd_text_buffer[10+i]=0;
+//  vo_osd_text=osd_text_buffer;
+#endif
+  
+#ifdef USE_SUB
+  // find sub
+  if(subdata && sh_video->pts>0){
+      float pts=sh_video->pts;
+      if(sub_fps==0) sub_fps=sh_video->fps;
+      current_module="find_sub";
+      if (pts > sub_last_pts || pts < sub_last_pts-1.0 ) {
+         find_sub(subdata, (pts+sub_delay) * 
+				 (subdata->sub_uses_time ? 100. : sub_fps)); 
+	 // FIXME! frame counter...
+         sub_last_pts = pts;
+      }
+      current_module=NULL;
+  }
+#endif
+
+#ifdef HAVE_X11
+if (stop_xscreensaver && sh_video) {
+  current_module="stop_xscreensaver";
+  xscreensaver_heartbeat();
+  current_module=NULL;
+}
+#endif
+  
+  // DVD sub:
+if(vo_config_count && vo_spudec) {
+  unsigned char* packet=NULL;
+  int len,timestamp;
+  current_module="spudec";
+  spudec_heartbeat(vo_spudec,90000*sh_video->timer);
+    // Get a sub packet from the dvd or a vobsub and make a timestamp relative to sh_video->timer
+  while(1) {
+    // Vobsub
+    len = 0;
+    if(vo_vobsub) {
+      if(sh_video->pts+sub_delay>=0) {
+	// The + next_frame_time is there because we'll display the sub at the next frame
+	len = vobsub_get_packet(vo_vobsub,sh_video->pts+sub_delay+next_frame_time,(void**)&packet,&timestamp);
+	if(len > 0) {
+	  timestamp -= (sh_video->pts + sub_delay - sh_video->timer)*90000;
+	  mp_dbg(MSGT_CPLAYER,MSGL_V,"\rVOB sub: len=%d v_pts=%5.3f v_timer=%5.3f sub=%5.3f ts=%d \n",len,sh_video->pts,sh_video->timer,timestamp / 90000.0,timestamp);
+	}
+      }
+    } else {
+      // DVD sub
+      len = ds_get_packet_sub(d_dvdsub,(unsigned char**)&packet);
+      if(len > 0) {
+	float x = d_dvdsub->pts - sh_video->pts;
+	if (x < -10 || x > 10) // prevent missing subs on pts reset
+	  timestamp = 90000*(sh_video->timer + d_dvdsub->pts + sub_delay - sh_video->pts);
+	else timestamp = 90000*(sh_video->timer + sub_delay);
+	mp_dbg(MSGT_CPLAYER,MSGL_V,"\rDVD sub: len=%d  v_pts=%5.3f  s_pts=%5.3f  ts=%d \n",len,sh_video->pts,d_dvdsub->pts,timestamp);
+      }
+    }
+      if(len<=0 || !packet) break;
+      if(timestamp < 0) timestamp = 0;
+      else spudec_assemble(vo_spudec,packet,len,timestamp);
+  }
+  
+  /* detect wether the sub has changed or not */
+  if(spudec_changed(vo_spudec))
+    vo_osd_changed(OSDTYPE_SPU);
+  current_module=NULL;
+}
+  
+} // while(!eof)
+
+mp_msg(MSGT_GLOBAL,MSGL_V,"EOF code: %d  \n",eof);
+
+}
+
+goto_next_file:  // don't jump here after ao/vo/getch initialization!
+
+mp_msg(MSGT_CPLAYER,MSGL_INFO,"\n");
+
+if(benchmark){
+  double tot=video_time_usage+vout_time_usage+audio_time_usage;
+  double total_time_usage;
+  total_time_usage_start=GetTimer()-total_time_usage_start;
+  total_time_usage = (float)total_time_usage_start*0.000001;
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"\nBENCHMARKs: VC:%8.3fs VO:%8.3fs A:%8.3fs Sys:%8.3fs = %8.3fs\n",
+	 video_time_usage,vout_time_usage,audio_time_usage,
+	 total_time_usage-tot,total_time_usage);
+  if(total_time_usage>0.0)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,"BENCHMARK%%: VC:%8.4f%% VO:%8.4f%% A:%8.4f%% Sys:%8.4f%% = %8.4f%%\n",
+	   100.0*video_time_usage/total_time_usage,
+	   100.0*vout_time_usage/total_time_usage,
+	   100.0*audio_time_usage/total_time_usage,
+	   100.0*(total_time_usage-tot)/total_time_usage,
+	   100.0);
+  if(total_frame_cnt && frame_dropping)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,"BENCHMARKn: disp: %d (%3.2f fps)  drop: %d (%d%%)  total: %d (%3.2f fps)\n",
+	total_frame_cnt-drop_frame_cnt,
+	(total_time_usage>0.5)?((total_frame_cnt-drop_frame_cnt)/total_time_usage):0,
+	drop_frame_cnt,
+	100*drop_frame_cnt/total_frame_cnt,
+	total_frame_cnt,
+	(total_time_usage>0.5)?(total_frame_cnt/total_time_usage):0);
+  
+}
+
+// time to uninit all, except global stuff:
+uninit_player(INITED_ALL-(INITED_GUI+INITED_INPUT+(fixed_vo?INITED_VO:0)));
+
+#ifdef USE_SUB  
+  if ( set_of_sub_size > 0 ) 
+   {
+    current_module="sub_free";
+    for (i = 0; i < set_of_sub_size; ++i)
+        sub_free( set_of_subtitles[i] );
+    set_of_sub_size = 0;
+    vo_sub=NULL;
+    subdata=NULL;
+   }
+#endif
+
+if(eof == PT_NEXT_ENTRY || eof == PT_PREV_ENTRY) {
+  eof = eof == PT_NEXT_ENTRY ? 1 : -1;
+  if(play_tree_iter_step(playtree_iter,play_tree_step,0) == PLAY_TREE_ITER_ENTRY) {
+    eof = 1;
+  } else {
+    play_tree_iter_free(playtree_iter);
+    playtree_iter = NULL;
+  }
+  play_tree_step = 1;
+} else if (eof == PT_UP_NEXT || eof == PT_UP_PREV) {
+  eof = eof == PT_UP_NEXT ? 1 : -1;
+  if ( playtree_iter ) {
+    if(play_tree_iter_up_step(playtree_iter,eof,0) == PLAY_TREE_ITER_ENTRY) {
+     eof = 1;
+    } else {
+      play_tree_iter_free(playtree_iter);
+      playtree_iter = NULL;
+    }
+   }
+} else { // NEXT PREV SRC
+     eof = eof == PT_PREV_SRC ? -1 : 1;
+}
+
+if(eof == 0) eof = 1;
+
+while(playtree_iter != NULL) {
+  filename = play_tree_iter_get_file(playtree_iter,eof);
+  if(filename == NULL) {
+    if( play_tree_iter_step(playtree_iter,eof,0) != PLAY_TREE_ITER_ENTRY) {
+      play_tree_iter_free(playtree_iter);
+      playtree_iter = NULL;
+    };
+  } else
+    break;
+} 
+
+#ifdef HAVE_NEW_GUI
+ if( use_gui && !playtree_iter ) 
+  {
+#ifdef USE_DVDREAD
+   if ( !guiIntfStruct.DiskChanged ) 
+#endif
+   mplEnd();
+  }	
+#endif
+
+if(use_gui || playtree_iter != NULL){
+
+  eof = 0;
+  goto play_next_file;
+}
+
+#ifdef HAVE_FREETYPE
+current_module="uninit_font";
+if (vo_font) free_font_desc(vo_font);
+vo_font = NULL;
+done_freetype();
+#endif
+
+exit_player_with_rc(MSGTR_Exit_eof, 0);
+
+return 1;
+}
