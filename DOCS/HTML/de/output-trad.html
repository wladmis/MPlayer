<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>8.2. Videoausgabegeräte für traditionelle Grafikkarten</title><link rel="stylesheet" href="default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="MPlayer - Movie Player"><link rel="up" href="video.html" title="Kapitel 8. Videoausgabegeräte"><link rel="prev" href="mtrr.html" title="8.1. MTRR einrichten"><link rel="next" href="mpeg_decoders.html" title="8.3. MPEG-Dekoderkarten"><link rel="preface" href="howtoread.html" title="Wie diese Dokumentation gelesen werden soll"><link rel="chapter" href="intro.html" title="Kapitel 1. Einführung"><link rel="chapter" href="install.html" title="Kapitel 2. Installation"><link rel="chapter" href="usage.html" title="Kapitel 3. Gebrauch"><link rel="chapter" href="cd-dvd.html" title="Kapitel 4. CD/DVD Nutzung"><link rel="chapter" href="faq.html" title="Kapitel 5. Häufig gestellte Fragen"><link rel="chapter" href="containers.html" title="Kapitel 6. Containerformate"><link rel="chapter" href="codecs.html" title="Kapitel 7. Codecs"><link rel="chapter" href="video.html" title="Kapitel 8. Videoausgabegeräte"><link rel="chapter" href="audio.html" title="Kapitel 9. Audioausgabegeräte"><link rel="chapter" href="tv.html" title="Kapitel 10. TV"><link rel="chapter" href="radio.html" title="Kapitel 11. Radio"><link rel="chapter" href="ports.html" title="Kapitel 12. Portierungen"><link rel="chapter" href="mencoder.html" title="Kapitel 13. Allgemeiner Gebrauch von MEncoder"><link rel="chapter" href="encoding-guide.html" title="Kapitel 14. Encodieren mit MEncoder"><link rel="appendix" href="bugreports.html" title="Anhang A. Wie Fehler (Bugs) berichtet werden"><link rel="appendix" href="bugs.html" title="Anhang B. Bekannte Fehler"><link rel="appendix" href="skin.html" title="Anhang C. MPlayers Skinformat"><link rel="appendix" href="history.html" title="Anhang D. Geschichte"><link rel="subsection" href="output-trad.html#xv" title="8.2.1. Xv"><link rel="subsection" href="output-trad.html#dga" title="8.2.2. DGA"><link rel="subsection" href="output-trad.html#sdl" title="8.2.3. SDL"><link rel="subsection" href="output-trad.html#svgalib" title="8.2.4. SVGAlib"><link rel="subsection" href="output-trad.html#fbdev" title="8.2.5. Framebuffer-Ausgabe (FBdev)"><link rel="subsection" href="output-trad.html#mga_vid" title="8.2.6. Matrox-Framebuffer (mga_vid)"><link rel="subsection" href="output-trad.html#tdfxfb" title="8.2.7. 3dfx-YUV-Unterstützung (tdfxfb)"><link rel="subsection" href="output-trad.html#opengl" title="8.2.8. OpenGL-Ausgabe"><link rel="subsection" href="output-trad.html#aalib" title="8.2.9. AAlib - Ausgabe im Textmodus"><link rel="subsection" href="output-trad.html#caca" title="8.2.10. libcaca - Color ASCII Art-Bibliothek"><link rel="subsection" href="output-trad.html#vesa" title="8.2.11. VESA-Ausgabe über das VESA-BIOS"><link rel="subsection" href="output-trad.html#x11" title="8.2.12. X11"><link rel="subsection" href="output-trad.html#vidix" title="8.2.13. VIDIX"><link rel="subsection" href="output-trad.html#directfb" title="8.2.14. DirectFB"><link rel="subsection" href="output-trad.html#dfbmga" title="8.2.15. DirectFB/Matrox (dfbmga)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8.2. Videoausgabegeräte für traditionelle Grafikkarten</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="mtrr.html">Zurück</a> </td><th width="60%" align="center">Kapitel 8. Videoausgabegeräte</th><td width="20%" align="right"> <a accesskey="n" href="mpeg_decoders.html">Weiter</a></td></tr></table><hr></div><div class="sect1" lang="de"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="output-trad"></a>8.2. Videoausgabegeräte für traditionelle Grafikkarten</h2></div></div></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="xv"></a>8.2.1. Xv</h3></div></div></div><p>
  Mit XFree86 4.0.2 oder neueren Versionen kannst du die Hardware-YUV-Routinen
  deiner Grafikkarte mit Hilfe der XVideo-Erweiterungen benutzen. Das ist die
  Technik, die <tt class="option">-vo xv</tt> benutzt. Dieser Treiber unterstützt
  darüber hinaus die Anpassung von Helligkeit/Kontrast/Sättigung etc
  (es sei denn, du benutzt den alten und langsamen DirectShow DivX-Codec,
  welcher diese Anpassungen unabhängig vom Videoausgabetreiber unterstützt).
  Schau in der Manpage nach.
</p><p>
  Um Xv zum Laufen zu bringen, musst du auf die folgenden Punkte achten:

</p><div class="orderedlist"><ol type="1"><li><p>
  Du musst XFree86 4.0.2 oder eine neuere Version verwenden, da die
  älteren Versionen XVideo noch nicht kannten.
  </p></li><li><p>
  Deine Grafikkarte muss Hardware-Unterstützung für YUV bieten, was alle
  modernen Karten tun.
  </p></li><li><p>
  X muss die XVideo-Erweiterung auch tatsächlich laden, was zu
  Meldungen ähnlich der folgenden führt:

  </p><pre class="programlisting">(II) Loading extension XVideo</pre><p>

  in <tt class="filename">/var/log/XFree86.0.log</tt>

	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Anmerkung</h3><p>
  Diese Meldung besagt nur, dass die XFree86-Erweiterung
  geladen wird. Bei einer guten Installation sollte das immer der Fall
  sein. Das heißt allerdings noch nicht, dass die
  <span class="bold"><strong>XVideo-Unterstützung der Grafikkarte</strong></span>
  auch geladen wurde!
	</p></div><p>
  </p></li><li><p>
  Deine Karte muss unter Linux Xv-Unterstützung haben. Du kannst dich
  dessen mit <span><strong class="command">xvinfo</strong></span> vergewissern, das Teil der
  XFree86-Distribution ist. Es sollte einen längeren Text ausgeben,
  der ungefähr so aussieht:

</p><pre class="screen">
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
(...)
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
(...etc...)</pre><p>
  Damit <span class="application">MPlayer</span> Xv benutzen kann, müssen die
  Pixelformate YUY2 packed und YV12 planar unterstützt werden.
  </p></li><li><p>
  Stelle als letztes sicher, dass <span class="application">MPlayer</span> mit
  Unterstützung für Xv compiliert wurde. <span><strong class="command">configure</strong></span> gibt eine
  entsprechende Meldung aus.
  Führe den Befehl <span><strong class="command">mplayer -vo help | grep xv </strong></span> aus.
  Wurde Unterstützung für Xv eingebaut, sollte eine ähnliche Meldung
  wie diese erscheinen:
  </p><pre class="screen">xv      X11/Xv</pre><p>
  </p></li></ol></div><p>
</p><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="tdfx"></a>8.2.1.1. 3dfx-Karten</h4></div></div></div><p>
  Ältere 3dfx-Treiber hatten bekanntermaßen Probleme mit der
  XVideo-Beschleuningung, die entweder YUY2 oder YV12 nicht unterstützte.
  Stelle sicher, dass du XFree86 Version 4.2.0 oder neuer verwendest, da diese
  Versionen mit YV12 und YUY2 keine Probleme haben. Vorherige Versionen, auch
  4.1.0, sind <span class="bold"><strong>bei Verwendung von YV12 abgestürzt</strong></span>.
  Wenn du merkwürdige Effekte bei der Verwendung von <tt class="option">-vo xv</tt>
  bemerkst, dann probier aus, ob mit SDL, das ebenfalls XVideo nutzen kann,
  diese Effekte verschwinden. In der <a href="output-trad.html#sdl" title="8.2.3. SDL">SDL</a> stehen
  Details darüber.
</p><p>
  <span class="bold"><strong>Alternativ</strong></span> kannst du auch den NEUEN
  tdfxfb-Treiber mit <tt class="option">-vo tdfxfb</tt> verwenden!
  Lies dazu die <a href="output-trad.html#tdfxfb" title="8.2.7. 3dfx-YUV-Unterstützung (tdfxfb)">tdfxfb</a>-Sektion.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="s3"></a>8.2.1.2. S3-Karten</h4></div></div></div><p>
  S3 Savage3D-Karten sollten problemlos funktionieren, aber bei Savage4-
  Chips solltest du XFree86 4.0.3 oder neuer verwenden. Probier bei Problemen
  den 16bpp-Farbmodus aus. Und der S3 Virge... Es gibt für ihn zwar Xv-
  Unterstützung, aber die Karte selbst ist so langsam, dass du sie besser
  verkaufst.
</p><p>
  Es gibt inzwischen einen nativen Framebuffer-Treiber für S3 Virge-Karten, ähnlich
  tdfxfb. Mache die Einstellungen (hänge z.B.
  "<tt class="option">vga=792 video=vesa:mtrr</tt>" an den Kernel an) und benutze
  <tt class="option">-vo s3fb</tt> (<tt class="option">-vf yuy2</tt> und <tt class="option">-dr</tt>
  helfen auch).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Anmerkung</h3><p>
  Momentan ist nicht ganz klar, welche Savage-Modelle keine Unterstützung
  für YV12 in Hardware haben, sodass bei ihnen der Treiber diese Konvertierung
  sehr langsam vornimmt. Hast du deine Karte in Verdacht, dann
  besorg dir einen neueren Treiber, oder frag auf der MPlayer-Users-Mailingliste
  freundlich nach einem Treiber, der MMX/3DNow unterstützt.
</p></div></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="nvidia"></a>8.2.1.3. nVidia-Karten</h4></div></div></div><p>
  nVidia ist für Linux keine optimale Wahll.
  XFree86's Open-Source-Treiber unterstützt die meisten dieser Karten, jedoch
  musst du in einigen Fällen die binären Closed-Source-Treiber von nVidia
  verwenden, verfügbar auf der
  <a href="http://www.nvidia.com/object/linux.html" target="_top">nVidia-Webseite</a>.
  Du brauchst diese Treiber immer, wenn du zusätzlich 3D-Beschleunigung
  haben willst.
</p><p>
  Riva128-Karten bieten nicht einmal mit den binären nVidia-Treibern
  XVideo-Unterstützung (beklag dich bei nVidia).
</p><p>
  Wie auch immer, <span class="application">MPlayer</span> enthält einen
  <a href="output-trad.html#vidix" title="8.2.13. VIDIX">VIDIX</a> -Treiber für die meisten nVidia-Karten.
  Er ist aktuell in der Beta-Phase und besitzt einige Nachteile. Mehr
  Informationen findest du in der
  <a href="output-trad.html#vidix-nvidia" title="8.2.13.5. nVidia-Karten">nVidia-VIDIX</a>-Sektion.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="ati"></a>8.2.1.4. ATI-Karten</h4></div></div></div><p>
  Die <a href="http://gatos.sf.net" target="_top">GATOS-Treiber</a>, die du
  einsetzen solltest, sofern du keine Rage128- oder Radeon-Karte hast,
  haben per Voreinstellung VSYNC angeschaltet. Dies bedeutet, dass
  die Decodiergeschwindigkeit (!) zur Bildwiederholrate des Monitors
  synchronisiert wird. Wenn dir die Wiedergabe langsam vorkommt, dann
  versuche, irgendwie VSYNC abzuschalten, oder setze die Bildwiederholrate
  des Monitors auf n * (fps des Films) Hz.
</p><p>
  Radeon VE - wenn du X benötigst, verwende XFree86 4.2.0 oder höher für
  diese Karte. Außerdem gibt es keine Unterstützung für den TV-Ausgang.
  Natürlich bekommst du mit <span class="application">MPlayer</span>
  <span class="bold"><strong>Hardware-beschleunigte</strong></span> Wiedergabe, das
  ganze wahlweise <span class="bold"><strong>mit oder ohne TV-Ausgang</strong></span>,
  und es werden dabei nicht einmal weitere Bibliotheken oder X selber benötigt.
  Lies dazu die <a href="output-trad.html#vidix" title="8.2.13. VIDIX">VIDIX-Sektion</a>.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="neomagic"></a>8.2.1.5. NeoMagic-Karten</h4></div></div></div><p>
  Diese Chips befinden sich in vielen Laptops. Du musst XFree86 4.3.0 oder
  höher oder andernfalls die
  <a href="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/" target="_top">Xv-fähigen
  Treiber</a> von Stefan Seyfried verwenden.
  Wähle einfach einen, der zu deiner XFree86-Version passt.
</p><p>
  XFree86 4.3.0 beinhaltet die Unterstützung für Xv, Bohdan Horst schickte jetzt
  einen kleinen
  <a href="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/neo_driver.patch" target="_top">Patch</a>
  auf die XFree86-Quellen, der Framebuffer-Operationen (daher XVideo)
  bis auf das Vierfache beschleunigt. Der Patch wurde in das XFree86-CVS
  eingebunden und sollte im nächsten Release nach 4.3.0 vorhanden sein.
</p><p>
  Um die Wiedergabe von Video in DVD-Auflösung zu ermöglichen,
  ändere deine XF86Config wie folgt:
</p><pre class="programlisting">
Section "Device"
    [...]
    Driver "neomagic"
    <span class="emphasis"><em>Option "OverlayMem" "829440"</em></span>
    [...]
EndSection</pre><p>
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="trident"></a>8.2.1.6. Trident-Karten</h4></div></div></div><p>
  Wenn du Xv mit einer Trident-Grafikkarte benutzen willst, dann installiere
  XFree86 4.2.0, sofern Xv nicht schon mit 4.1.0 funktioniert. Version 4.2.0
  enthält Unterstützung für Xv im Vollbild für Cyberblade XP-Karten.
</p><p>
  Alternativ enthält <span class="application">MPlayer</span> einen
  <a href="output-trad.html#vidix" title="8.2.13. VIDIX">VIDIX</a>-Treiber für the Cyberblade/i1-Karten.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="kyro"></a>8.2.1.7. Kyro/PowerVR-Karten</h4></div></div></div><p>
  Wenn du Xv mit einer Kyro-basierten Karte (wie z.B. der Hercules Prophet 4000XT)
  verwenden möchstest, dann solltest du die Treiber von der
  <a href="http://www.powervr.com/" target="_top">PowerVR-Seite</a> herunterladen.
</p></div></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="dga"></a>8.2.2. DGA</h3></div></div></div><p><b>PRÄAMBEL. </b>
  Dieser Abschnitt versucht, in wenigen Worten zu beschreiben, was DGA
  generell ist und was der DGA-Videotreiber in <span class="application">MPlayer</span>
  erreichen kann, und was nicht.
</p><p><b>WAS IST DGA? </b>
  <span class="acronym">DGA</span> ist die Abkürzung für
  <span class="emphasis"><em>Direct Graphics Access</em></span> (direkter Zugriff auf die
  Grafikhardware) und gibt Programmen die Möglichkeit, unter Umgehung
  des X-Servers direkt den Framebuffer der Grafikkarte zu verändern.
  Technisch gesehen wird das dadurch realisiert, dass der
  Framebuffer-Speicher in den virtuellen Adressraum des jeweiligen Prozesses
  abgebildet wird. Das wird vom Kernel aber nur dann zugelassen, wenn der
  Prozess Superuserprivilegien besitzt. Dazu musst du dich entweder als
  <code class="systemitem">root</code> anmelden oder das SUID-bit
  des <span class="application">MPlayer</span>-Binaries setzen (was
  <span class="bold"><strong>nicht empfohlen wird</strong></span>).
</p><p>
  Von DGA gibt es zwei Versionen: DGA1 kommt mit XFree 3.x.x, und DGA2
  wurde mit XFree 4.0.1 eingeführt.
</p><p>
  DGA1 bietet nur den oben beschriebenen Zugriff auf den Framebuffer. Die
  Umschaltung des Videomodus klappt nur mit der XVidMode-Erweiterung.
</p><p>
  DGA2 beinhaltet die Features der XVidMode-Erweiterung und erlaubt
  außerdem, die Farbtiefe zu ändern. Damit kannst du also auf 32bit
  Farbtiefe umschalten, auch wenn der X-Server gerade mit 15bit Farbtiefe
  läuft und umgekehrt.
</p><p>
  DGA hat aber auch ein paar Nachteile. Die Funktionsweise scheint ein wenig
  von der Grafikkarte und der Implementierung des Grafikkartentreibers
  im X-Server abhängig zu sein, der diesen Chip kontrolliert.
  Es fuktioniert also nicht auf jedem System...
</p><p><b>DGA-UNTERSTÜTZUNG FÜR MPLAYER INSTALLIEREN. </b>
  Stelle als erstes sicher, dass X die DGA-Erweiterung lädt. Schau
  in <tt class="filename">/var/log/XFree86.0.log</tt> nach:

</p><pre class="programlisting">(II) Loading extension XFree86-DGA</pre><p>

  Wie du siehst, ist XFree86 4.0.x oder neuer
  <span class="bold"><strong>sehr zu empfehlen</strong></span>!
  <span class="application">MPlayer</span>s DGA-Treiber wird von
  <tt class="filename">./configure</tt> automatisch erkannt. Alternativ
  kannst du seine Compilierung mit <tt class="option">--enable-dga</tt> erzwingen.
</p><p>
  Falls der Treiber nicht zu einer kleineren Auflösung wechseln
  konnte, dann experimentiere mit den Optionen <tt class="option">-vm</tt> (nur bei
  X 3.3.x), <tt class="option">-fs</tt>, <tt class="option">-bpp</tt>,
  <tt class="option">-zoom</tt> herum, um einen Videomodus zu finden,
  in den der Film reinpasst. Momentan gibt es keinen Konverter :(
</p><p>
  Werde <code class="systemitem">root</code>.
  DGA braucht <code class="systemitem">root</code>-Privilegien,
  um direkt in den Grafikspeicher zu schreiben. Wenn du MPlayer als
  normaler Nutzer starten möchtest, dann installiere
  <span class="application">MPlayer</span> mit dem SUID-Bit:

</p><pre class="screen">
chown root <em class="replaceable"><code>/usr/local/bin/mplayer</code></em>
chmod 750 <em class="replaceable"><code>/usr/local/bin/mplayer</code></em>
chmod +s <em class="replaceable"><code>/usr/local/bin/mplayer</code></em>
</pre><p>

  Jetzt funktioniert es auch als normaler Benutzer.
</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warnung: Sicherheitsrisiko!</h3><p>
  Dieses ist ein <span class="bold"><strong>großes</strong></span> Sicherheitsloch.
  Tu das <span class="bold"><strong>niemals</strong></span> auf einem Server oder
  auf einem Computer, auf den auch andere Leute Zugriff haben, da sie durch einen
  SUID-<code class="systemitem">root</code>-<span class="application">MPlayer</span>
  <code class="systemitem">root</code>-Privilegien erlangen können.
</p></div><p>
  Benutze jetzt die Option <tt class="option">-vo dga</tt>, und ab geht's (hoffe ich
  zumindest :))! Du solltest auch ausprobieren, ob bei dir die Option
  <tt class="option">-vo sdl:dga</tt> funktioniert. Sie ist viel schneller.
</p><p><a name="dga-modelines"></a><b>ÄNDERN DER AUFLÖSUNG. </b>
  Der DGA-Treiber ermöglicht es, die Auflösung des Output-Signals zu ändern.
  Damit entfällt die Notwendigkeit der (langsamen) Softwareskalierung und
  bietet gleichzeitig ein Vollbild. Idealerweise würde DGA in die gleiche
  Auflösung schalten, die das Video (natürlich unter Beachtung des
  Höhen-/Breitenverhältnisses) hat, aber der X-Server lässt nur
  Auflösungen zu, die vorher in der <tt class="filename">/etc/X11/XF86Config</tt> bzw.
  <tt class="filename">/etc/X11/XF86Config-4</tt> definiert wurden, bezüglich XFree 4.X.X.
  Diese werden durch sogenannte Modelines festgelegt und hängen von den Fähigkeiten
  deiner Grafikhardware ab. Der X-Server liest diese Konfigurationsdatei beim
  Start ein und deaktiviert alle Modelines, die sich nicht mit deiner Hardware
  vertragen. Du kannst die überlebenden Modelines anhand der X11-Logdatei
  herausfinden (normalerweise <tt class="filename">/var/log/XFree86.0.log</tt>).
</p><p>
  Diese Einträge funktionieren mit einem Riva128-Chip und dem
  nv.o-X-Server-Treibermodul.
</p><pre class="programlisting">
Section "Modes"
  Identifier "Modes[0]"
  Modeline "800x600"  40     800 840 968 1056  600 601 605 628
  Modeline "712x600"  35.0   712 740 850 900   400 410 412 425
  Modeline "640x480"  25.175 640 664 760 800   480 491 493 525
  Modeline "400x300"  20     400 416 480 528   300 301 303 314 Doublescan
  Modeline "352x288"  25.10  352 368 416 432   288 296 290 310
  Modeline "352x240"  15.750 352 368 416 432   240 244 246 262 Doublescan
  Modeline "320x240"  12.588 320 336 384 400   240 245 246 262 Doublescan
EndSection
</pre><p><b>DGA &amp; MPLAYER. </b>
  DGA wird bei <span class="application">MPlayer</span> an zwei Stellen benutzt:
  beim SDL-Treiber mit (<tt class="option">-vo sdl:driver=dga</tt>) oder beim
  DGA-Treiber selbst (<tt class="option">-vo dga</tt>).
  Das oben gesagte gilt für beide Treiber. In den folgenden Abschnitten
  erkläre ich, wie der DGA-Treiber von <span class="application">MPlayer</span>
  selber arbeitet.
</p><p><b>FEATURES DES DGA-TREIBERS. </b>
  Der DGA-Treiber wird durch die Option <tt class="option">-vo dga</tt> aktiviert.
  Sein Standardverhalten sieht vor, dass er in die Auflösung schaltet, die
  der Videoauflösung am nächsten kommt. Der Treiber ignoriert absichtlich
  die Optionen <tt class="option">-vm</tt> (Videomodusumschaltung aktivieren) und
  <tt class="option">-fs</tt> (Vollbildmodus erzwingen) - er versucht immer, so viel
  Bildfläche wie möglich durch eine Änderung der Auflösung zu bedecken.
  Dadurch wird nicht ein einziger weiterer CPU-Takt für die Skalierung des
  Bildes verwendet. Wenn du mit dem Modus nicht zufrieden bist, den der Treiber
  gewählt hat, dann kannst du ihn zwingen, denjenigen Modus zu
  wählen, der am besten zu dem mit den Optionen <tt class="option">-x</tt> und
  <tt class="option">-y</tt> angegebenen Werten passt. Die Option <tt class="option">-v</tt>
  veranlasst den DGA-Treiber, neben einigen anderen Dingen auch alle von deiner
  <tt class="filename">XF86Config</tt>-Datei unterstützen Videomodi aufzulisten.
  Wenn DGA2 verwendet wird, dann kannst du mit der Option <tt class="option">-bpp</tt> die
  Verwendung einer bestimmten Farbtiefe erzwingen. Gültige Werte sind 15,
  16, 24 und 32. Es hängt dann von deiner Hardware ab, ob der Modus nativ
  unterstützt wird oder ob eine (möglicherweise langsame)
  Konvertierung stattfindet.
</p><p>
  Wenn du Glück hast und dir genug unbenutzter Grafikspeicher zur
  Verfügung steht, um ein komplettes Bild aufzunehmen, dann wird der
  DGA-Treiber Doppelpufferung verwenden, was zu einer regelmäßigeren
  Wiedergabe führt. Der DGA-Treiber wird dir mitteilen, ob Doppelpufferung
  angeschaltet ist oder nicht.
</p><p>
  Doppelpufferung bedeutet, dass das nächste Bild deines Videos bereits
  an einer anderen Stelle im Grafikspeicher aufgebaut wird, während das
  aktuelle Bild angezeigt wird. Ist das nächste Bild fertig, so wird
  dem Grafikchip nur noch mitgeteilt, wo er das neue Bild im Speicher finden
  kann. Somit holt sich der Chip seine Daten einfach von dort. In der
  Zwischenzeit wird der andere, jetzt unbenutze Puffer wieder mit neuen
  Videodaten gefüllt.
</p><p>
  Doppelpufferung kann mit der Option <tt class="option">-double</tt> aktiviert und mit
  <tt class="option">-nodouble</tt> deaktiviert werden. Momentan ist die Doppelpufferung
  per Voreinstellung deaktiviert. Wird der DGA-Treiber verwendet,
  dann funktioniert das Onscreen-Display (ODS) nur dann, wenn auch die
  Doppelpufferung aktiviert ist. Andererseits kann die Doppelpufferung auch
  einen großen Geschwindigkeitseinbruch hervorrufen, was stark von
  der DGA-Implementierung der Treiber für deine Hardware abhängt (auf
  meinem K6-II+ 525 benötigt Doppelpufferung weitere 20% CPU-Zeit!).
</p><p><b>PUNKTE BEZÜGLICH DER GESCHWINDIGKEIT. </b>
  Generell gesehen sollte der Zugriff auf den DGA-Framebuffer genauso
  schnell sein wie der X11-Treiber, wobei man zusätzlich noch ein Vollbild
  erhält. Die prozentualen Geschwindigkeitswerte, die <span class="application">MPlayer</span>
  ausgibt, müssen mit Vorsicht genossen werden, da sie z.B. beim X11-Treiber
  nicht die Zeit beinhalten, die der X-Server tatsächlich zum
  Anzeigen des Bildes benötigt. Klemm ein Terminal an deinen seriellen
  Port und starte <span><strong class="command">top</strong></span>, wenn du wissen willst, wie's wirklich mit
  der Geschwindigkeit aussieht.
</p><p>
  Allgemein betrachtet hängt die Geschwindigkeitsverbesserung von DGA
  gegenüber dem 'normalen' X11-Treiber sehr von deiner Grafikkarte und
  davon ab, wie gut das X-Servermodul optimiert ist.
</p><p>
  Wenn du ein langsames System hast, dann benutz besser eine Farbtiefe von
  15 oder 16bit, da sie nur die halbe Bandbreite des 32bit-Farbmodus
  benötigen.
</p><p>
  Einge gute Idee ist auch die Verwendung von 24bit Farbtiefe, selbst dann,
  wenn deine Grafikkarte nativ nur 32bit unterstützt, da bei 24bit 25%
  weniger Daten im Vergleich zum 32/32-Modus über den Bus transferiert
  werden müssen.
</p><p>
  Ich habe schon gesehen, wie einige AVI-Dateien auf einem Pentium MMX 266
  wiedergegeben werden konnten. AMD K6-2-CPUs werden ab ca. 400 MHz oder
  höher funktionieren.
</p><p><b>BEKANNTE FEHLER. </b>
  Die Entwickler von XFree sagen selbst, dass DGA ein ganz schönes
  Monstrum ist. Sie raten eher davon ab, es zu benutzen, da seine
  Implementierung in einige Chipset-Treiber für XFree nicht immer
  ganz fehlerfrei war.
</p><div class="itemizedlist"><ul type="disc"><li>
  Bei der Kombination aus XFree 4.0.3 und dem
  <tt class="filename">nv.o</tt>-Treiber gibt es einen Fehler, der zu
  merkwürdigen Farben führt.
</li><li>
  Die ATI-Treiber müssen den Videomodus mehrmals zurückstellen,
  nachdem der DGA-Modus verlassen wurde.
  </li><li>
  Einige Treiber schaffen es manchmal einfach nicht, in die vorherige
  Auflösung zurückzuschalten. Benutze in solch einem Fall
  <span class="keycap"><b>Strg</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>Keypad +</b></span> und
  <span class="keycap"><b>Strg</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>Keypad -</b></span>,
  um manuell die Auflösung zu ändern.
</li><li>
  Einige Treiber zeigen einfach nur merkwürdige Farben an.
</li><li>
  Manche Treiber lügen, was die von ihnen in den Prozessorspeicher
  eingeblendete Menge Grafikspeicher anbelangt, weswegen vo_dga
  nicht die Doppelpufferung verwendet (SIS?).
</li><li>
  Einige Treiber schaffen es nicht einmal, auch nur einen einzigen
  gültigen Grafikmodus bereitzustellen. In solchen Fällen
  gibt der DGA-Treiber schwachsinnige Modi wie z.B. 100000x100000 oder
  so ähnlich aus.
</li><li>
  Das OSD funktioniert nur, wenn auch die Doppelpufferung aktiviert
  ist (sonst flimmert es).
</li></ul></div></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="sdl"></a>8.2.3. SDL</h3></div></div></div><p>
  <span class="acronym">SDL</span> (Simple Directmedia Layer, einfacher Layer für
  den direkten Zugriff auf Mediengeräte) bietet grundsätzlich eine einheitliche
  Schnittstelle zu Audio- und Videogeräten. Programme, die SDL
  benutzen, kennen nur SDL und brauchen nichts darüber zu wissen, welche
  Video- oder Audiotreiber SDL tatsächlich benutzt. So kann z.B. eine
  Doom-Portierung mit SDL die Svgalib, aalib, X11, fbdev und andere Treiber
  nutzen. Dazu musst du z.B. nur den Videotreiber angeben, indem du die
  Umgebungsvariable <code class="envar">SDL_VIDEODRIVER</code> setzt.
  So lautet zumindest die Theorie.
</p><p>
  Bei <span class="application">MPlayer</span> benutzten wir damals die
  Softwareskalierungsroutinen der X11-Treiber von SDL bei Grafikkarten/-treibern,
  die keine Unterstützung für XVideo hatten, bis wir unsere eigenen schrieben,
  die schneller und hübscher waren. Wir benutzten damals außerdem SDLs
  aalib-Ausgabe. Jetzt haben wir unsere eigenen, was wesentlich komfortabler
  ist. Auch davon haben wir selber eine komfortablere Version geschrieben.
  SDLs DGA-Code war besser als unserer - zumindest bis vor kurzem.
  Verstehst du, worauf ich hinauswill? :)
</p><p>
  SDL ist auch bei einigen fehlerbehafteten Treibern/Karten nützlich,
  wenn das Video ruckelig abgespielt wird (und es nicht an einem langsamen
  System liegt), oder wenn der Ton hinterherhinkt.
</p><p>
  Die SDL-Videoausgabe unterstützt die Anzeige von Untertiteln unterhalb
  des Films auf den schwarzen Balken (sofern diese vorhanden sind).
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="svgalib"></a>8.2.4. SVGAlib</h3></div></div></div><p><b>INSTALLATION. </b>
  Du musst zuerst die svgalib und die dazugehörigen Entwicklerpakete
  installieren, bevor du <span class="application">MPlayer</span> compilierst,
  da er sonst die Svgalib nicht automatisch findet und den Treiber dazu
  nicht compiliert (das kann aber trotzdem erzwungen werden). Vergiss auch
  nicht, in <tt class="filename">/etc/vga/libvga.config</tt> richtige Werte
  für deine Grafikkarte und deinen Monitor anzugeben.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Anmerkung</h3><p>
  Verwende nicht die Option <tt class="option">-fs</tt>, da sie die Benutzung des
  Softwareskalierers erzwingt und das ganze dann langsam wird. Wenn du diese
  Option wirklich brauchst, dann verwende auch <tt class="option">-sws 4</tt>,
  welche zwar schlechte Qualität produziert, dafür aber auch ein wenig
  schneller ist.
</p></div><p><b>EGA(4bpp)-UNTERSTÜTZUNG. </b>
  SVGAlib beinhaltet die EGAlib, und MPlayer kann damit jeden Film in
  16 Farben bei folgenden Modi anzeigen:
</p><div class="itemizedlist"><ul type="disc"><li>
  EGA-Karte mit EGA-Monitor: 320x200x4bpp, 640x200x4bpp, 640x350x4bpp
</li><li>
  EGA-Karte mit CGA-Monitor: 320x200x4bpp, 640x200x4bpp
</li></ul></div><p>
  Der bpp-Wert (Bits pro Pixel) muss von Hand auf vier gesetzt werden:
  <tt class="option">-bpp 4</tt>
</p><p>
  Die Auflösung des Films muss wahrscheinlich verkleinert werden, damit
  er in den EGA-Modus reinpasst:
  </p><pre class="screen">-vf scale=640:350</pre><p>
  oder
  </p><pre class="screen">-vf scale=320:200</pre><p>
</p><p>
  Dafür brauchen wir eine schnelle, aber schlechte Qualität
  produzierende Skalierroutine:
  </p><pre class="screen">-sws 4</pre><p>
</p><p>
  Eventuell muss die automatische Anpassung des
  Höhen-/Breitenverhältnisses ausgeschaltet werden:
  </p><pre class="screen">-noaspect</pre><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Anmerkung</h3><p>
  Die besten Ergebnisse bei EGA-Bildschirmen erhält man meiner Erfahrung nach,
  wenn man die Helligkeit ein wenig verringert:
  <tt class="option">-vf eq=-20:0</tt>. Ich musste auch die Audiosamplerate reduzieren,
  weil bei 44KHz der Sound nicht richtig funktionierte:
  <tt class="option">-srate 22050</tt>.
</p></div><p>
  Du kannst das OSD und Untertitel mit dem <tt class="option">expand</tt>-Filter
  aktivieren. Die Manpage enthält die exakten Parameter.
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="fbdev"></a>8.2.5. Framebuffer-Ausgabe (FBdev)</h3></div></div></div><p>
  <tt class="filename">./configure</tt> erkennt automatisch, ob es den Framebuffertreiber
  (fbdev) compilieren soll oder nicht. Lies die Framebufferdokumentation in den
  Kernelquellen (<tt class="filename">Documentation/fb/*</tt>); dort stehen mehr
  Informationen.
</p><p>
  Falls deine Karte den VBE 2.0-Standard nicht unterstützt (wie z.B.
  ältere ISA-/PCI-Karten wie die S3 Trio64) oder nur VBE 1.2 und
  älter unterstützt: Tja, dann kannst du immer noch VESAfb benutzen,
  benötigst aber den SciTech Display Doctor (ehemals UniVBE), der vor dem
  Booten von Linux geladen werden muss. Nimm dazu eine DOS-Bootdiskette oder
  was auch immer. Vergiss nicht, deine Kopie von UniVBE zu registrieren ;).
</p><p>
  Die Fbdev-Ausgabe kennt neben den üblichen Parametern noch einige andere:
</p><div class="variablelist"><dl><dt><span class="term"><tt class="option">-fb</tt></span></dt><dd>
  Gibt das zu verwendende Framebuffergerät an (Standard: <tt class="filename">/dev/fb0</tt>)
  </dd><dt><span class="term"><tt class="option">-fbmode</tt></span></dt><dd>
  Gibt zu benutzenden Modusnamen an (wie sie in <tt class="filename">/etc/fb.modes</tt> stehen)
  </dd><dt><span class="term"><tt class="option">-fbmodeconfig</tt></span></dt><dd>
  Konfigurationsdatei für die Modi (Standard: <tt class="filename">/etc/fb.modes</tt>)
  </dd><dt><span class="term"><tt class="option">-monitor-hfreq</tt>, </span><span class="term"><tt class="option">-monitor-vfreq</tt>, </span><span class="term"><tt class="option">-monitor-dotclock</tt>, </span></dt><dd>
  <span class="bold"><strong>Wichtige</strong></span> Werte, schau dir die
  <tt class="filename">example.conf</tt> an.
  </dd></dl></div><p>
  Wenn du in einen speziellen Modus wechseln willst, dann benutze
</p><pre class="screen">
mplayer -vm -fbmode <em class="replaceable"><code>Modusname</code></em> <em class="replaceable"><code>Dateiname</code></em>
</pre><p>
</p><div class="itemizedlist"><ul type="disc"><li><p>
  <tt class="option">-vm</tt> ohne weitere Optionen wird den am besten passenden Modus
  aus <tt class="filename">/etc/fb.modes</tt> auswählen. Kann auch zusammen mit
  <tt class="option">-x</tt> und <tt class="option">-y</tt> benutzt werden. Die Option
  <tt class="option">-flip</tt> wird nur dann unterstützt, wenn das Pixelformat des
  Films mit dem Pixelformat des Videomodus übereinstimmt. Pass auf den
  bpp-Wert auf. fbdev wird den aktuell eingestellten benutzen, wenn du
  nicht mit <tt class="option">-bpp</tt> einen bestimmten angibst.
</p></li><li><p>
  Die Option <tt class="option">-zoom</tt> wird nicht unterstützt (Softwareskalierung
  ist langsam, verwende <tt class="option">-vf scale</tt>). Du kannst keine Modi mit
  8bpp oder weniger benutzen.
</p></li><li><p>
  Wahrscheinlich wirst du den Cursor (</p><pre class="screen">echo -e '\033[?25l'</pre><p>
  oder </p><pre class="screen">setterm -cursor off</pre><p>) und den Bildschirmschoner
  (<tt class="option">setterm -blank 0</tt>) deaktivieren wollen. Um den Cursor wieder
  zu aktivieren: </p><pre class="screen">echo -e '\033[?25h'</pre><p> oder
  </p><pre class="screen">setterm -cursor on</pre><p>.
  </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Anmerkung</h3><p>
  fbdev kann den Videomodus in Verbindung mit dem VESA-Framebuffer
  <span class="emphasis"><em>nicht</em></span> ändern. Frag auch nicht danach - das ist
  keine Einschränkung seitens <span class="application">MPlayer</span>.
</p></div></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="mga_vid"></a>8.2.6. Matrox-Framebuffer (mga_vid)</h3></div></div></div><p>
  Dieser Abschnitt beschäftigt sich mit der Unterstützung für
  den BES (Back-End Scaler, Hardwareskalierungseinheit) bei Karten mit dem
  Matrox-G200/G400/G450/G550-Chip durch das <code class="systemitem">mga_vid</code>-Kernelmodul.
  Es bietet Unterstützung für Hardware-
  VSYNC und Dreifachpufferung. Dieser Treiber funktioniert sowohl unter der
  Framebufferconsole als auch unter X.
</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warnung</h3><p>
  Das Modul ist nur für Linux-Systeme verfügbar!
  Auf nicht-Linux-Systemen solltest du statt dessen <a href="output-trad.html#vidix" title="8.2.13. VIDIX">VIDIX</a>
  benutzen!
</p></div><div class="procedure"><a name="id2559594"></a><p class="title"><b>Installation:</b></p><ol type="1"><li><p>
  Um den Treiber benutzen zu können, musst du erstmal <tt class="filename">mga_vid.o</tt>
  compilieren:
  </p><pre class="screen">
cd drivers
make</pre><p>
  </p></li><li><p>
  Jetzt erstelle das Gerät <tt class="filename">/dev/mga_vid</tt>:
  </p><pre class="screen">mknod /dev/mga_vid c 178 0</pre><p>
  und lade das Kernelmodul:
  </p><pre class="screen">insmod mga_vid.o</pre><p>
  </p></li><li><p>
  Du solltest sicherstellen, dass das Modul die Größe des
  Grafikkartenspeichers korrekt ermittelt hat. Benutze dazu
  <span><strong class="command">dmesg</strong></span>. Wenn die Angabe nicht stimmt, dann gib nach
  <span><strong class="command">rmmod mga_vid</strong></span> mit Hilfe der Option
  <tt class="option">mga_ram_size</tt> die Größe explizit an:
  </p><pre class="screen">insmod mga_vid.o mga_ram_size=16</pre><p>
</p></li><li><p>
  Wenn das Modul automatisch geladen und entladen werden soll, sobald
  es benötigt wird, so füge die folgende Zeile in der Datei
  <tt class="filename">/etc/modules.conf</tt> ein:

  </p><pre class="programlisting">alias char-major-178 mga_vid</pre><p>

  Jetzt kopiere <tt class="filename">mga_vid.o</tt> in das entsprechende Verzeichnis
  unterhalb von
  <tt class="filename">/lib/modules/<em class="replaceable"><code>kernel_version</code></em>/<em class="replaceable"><code>/irgendwo</code></em></tt>.
  </p><p>
  Jetzt gib ein:
  </p><pre class="screen">depmod -a</pre><p>
  </p></li><li><p>
  Schließlich musst du noch <span class="application">MPlayer</span> (erneut) compilieren.
  <tt class="filename">configure</tt> wird automatisch <tt class="filename">/dev/mga_vid</tt>
  finden und den 'mga'-Treiber erstellen. Die entsprechende Option für
  <span class="application">MPlayer</span> lautet <tt class="option">-vo mga</tt>, wenn du mit
  dem matroxfb auf der Console arbeitest, oder <tt class="option">-vo xmga</tt>, wenn du
  unter XFree 3.x.x oder XFree 4.x.x arbeitest.
  </p></li></ol></div><p>
  Der mga_vid-Treiber kooperiert mit Xv.
</p><p>
  Das Gerät <tt class="filename">/dev/mga_vid</tt> kann z.B. mit
  </p><pre class="screen">cat /dev/mga_vid</pre><p>
  ausgelesen werden, um ein paar Informationen über
  den aktuellen Zustand zu erhalten. Die Helligkeit kann zusätzlich mit z.B.
  </p><pre class="screen">echo "brightness=120" &gt; /dev/mga_vid</pre><p>
  angepasst werden.
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="tdfxfb"></a>8.2.7. 3dfx-YUV-Unterstützung (tdfxfb)</h3></div></div></div><p>
  Dieser Treiber verwendet den tdfx-Framebuffertreiber des Kernels, um Filme
  mit YUV-Beschleunigung abzuspielen. Deswegen benötigst du einen Kernel
  mit tdfxfb-Unterstütztung. Danach musst du MPlayer compilieren mit
  </p><pre class="screen">./configure --enable-tdfxfb</pre><p>
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="opengl"></a>8.2.8. OpenGL-Ausgabe</h3></div></div></div><p>
  <span class="application">MPlayer</span> unterstützt die Ausgabe von Filmen via
  OpenGL. Wenn aber deine Plattform/dein Treiber Xv unterstützt (was bei PCs
  mit Linux praktisch immer der Fall ist), dann benutze besser Xv, da die
  OpenGL-Geschwindigkeit deutlich geringer als die von Xv ist. Wenn du dagegen
  eine X11-Implementierung hast, die Xv nicht unterstützt, so mag OpenGL eine
  brauchbare Alternative sein.
</p><p>
  Leider unterstützen nicht alle Treiber die erforderlichen Features.
  Die Utah-GLX-Treiber (für XFree86 3.3.6) unterstützen sie für
  alle Karten. Auf <a href="http://utah-glx.sf.net" target="_top">http://utah-glx.sf.net</a>
  findest du Details zur Installation.
</p><p>
  XFree86(DRI) 4.0.3 oder neuer unterstützt OpenGL mit Matrox- und
  Radeon-Karten, 4.2.0 und neuer unterstützen zusätzlich Rage128.
  Auf <a href="http://dri.sf.net" target="_top">http://dri.sf.net</a> findest du Details zur Installation.
</p><p>
  Ein Hinweis von einem unserer User: der GL-Video-Output kann dazu verwendet
  werden, einen vertikal synchronisierten TV-Output zu bekommen.
  Du musst dann eine Umgebungsvariable setzen (zumindest bei nVidia):
</p><p>
<span><strong class="command">export $__GL_SYNC_TO_VBLANK=1</strong></span>
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="aalib"></a>8.2.9. AAlib - Ausgabe im Textmodus</h3></div></div></div><p>
  AAlib ist eine Bilbiothek, mit der Grafiken im Textmodus angezeigt
  werden, wobei ein mächtiger Textmodusrenderer angewandt wird. Es gibt SEHR
  viele Programme, die das bereits unterstützen, wie z.B. Doom, Quake etc.
  <span class="application">MPlayer</span> enthält einen sehr gut brauchbaren
  Treiber für AAlib. Wenn <tt class="filename">./configure</tt> feststellt,
  dass die AAlib installiert ist, dann wird anschließend der AAlib-Treiber
  gebaut.
</p><p>
  Du kannst diese Tasten im AA-Fenster benutzen, um die Render-Optionen
  zu beeinflussen:
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Taste</th><th>Aktion</th></tr></thead><tbody><tr><td><span class="keycap"><b>1</b></span></td><td>
  Kontrast verringern
  </td></tr><tr><td><span class="keycap"><b>2</b></span></td><td>
  Kontrast erhöhen
  </td></tr><tr><td><span class="keycap"><b>3</b></span></td><td>
  Helligkeit verringern
  </td></tr><tr><td><span class="keycap"><b>4</b></span></td><td>
  Helligkeit erhöhen
  </td></tr><tr><td><span class="keycap"><b>5</b></span></td><td>
  Schnelles Rendern an-/ausschalten
  </td></tr><tr><td><span class="keycap"><b>6</b></span></td><td>
  Wahl des Farbverteilungsmodus (keiner, Fehlerverteilung, Floyd Steinberg)
  </td></tr><tr><td><span class="keycap"><b>7</b></span></td><td>
  Bild invertieren
  </td></tr><tr><td><span class="keycap"><b>8</b></span></td><td>
  schaltet zwischen den <span class="application">MPlayer</span>- und den AA-Tastenbelegungen um
  </td></tr></tbody></table></div><div class="variablelist"><p class="title"><b>Die folgenden Kommandozeilenparamter stehen zur Verfügungung:</b></p><dl><dt><span class="term"><tt class="option">-aaosdcolor=<em class="replaceable"><code>V</code></em></tt></span></dt><dd><p>
  OSD-Farbe ändern
  </p></dd><dt><span class="term"><tt class="option">-aasubcolor=<em class="replaceable"><code>V</code></em></tt></span></dt><dd><p>
  Farbe der Untertitel ändern,
  </p><p>
    <em class="replaceable"><code>V</code></em> kann folgende Werte annehmen:
    <code class="literal">0</code> (normal),
    <code class="literal">1</code> (dunkel),
    <code class="literal">2</code> (fett),
    <code class="literal">3</code> (fette Schrift),
    <code class="literal">4</code> (negative Farben),
    <code class="literal">5</code> (spezial).
    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Die AAlib selbst bietet ebenfalls eine große Anzahl von Optionen.
  Hier sind die wichtigsten:</b></p><dl><dt><span class="term"><tt class="option">-aadriver</tt></span></dt><dd>
  Wählt den empfohlenen aa-Treiber (X11, curses, Linux).
    </dd><dt><span class="term"><tt class="option">-aaextended</tt></span></dt><dd>
  Benutze alle 256 Zeichen.
    </dd><dt><span class="term"><tt class="option">-aaeight</tt></span></dt><dd>
  Benutze 8 Bit ASCII-Zeichen.
    </dd><dt><span class="term"><tt class="option">-aahelp</tt></span></dt><dd>
  Gib alle aalib-Optionen aus.
    </dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Anmerkung</h3><p>
  Das Rendern ist sehr CPU-intensiv, vor allem, wenn AA unter X
  benutzt wird. AAlib braucht auf einer Nicht-Framebuffer-Console am
  wenigstens CPU-Zeit. Benutze SVGATextMode, um einen möglichst
  großen Textmodus zu wählen, und genieß den Film! (Hercules-Karten
  als zweites Ausgabegerät rocken :)) (Aber IMHO kannst du die Option
  <tt class="option">-vf 1bpp</tt> anwenden, um Grafiken auf hgafb zu bekommen :)
</p></div><p>
  Wenn dein Computer nicht schnell genug ist, um alle Frames anzuzeigen,
  dann benutze die Option <tt class="option">-framedrop</tt>.
</p><p>
  Wenn du auf einem Terminal abspielst, dann erzielst du mit dem Linux-
  Treiber (<tt class="option">-aadriver linux</tt>) bessere Ergebnisse als mit dem curses-
  Treiber. Allerdings benötigst du dafür auch Schreibrechte auf
  <tt class="filename">/dev/vcsa<em class="replaceable"><code>&lt;Terminal&gt;</code></em></tt>.
  Das wird von aalib nicht automatisch festgestellt, aber vo_aa versucht, den
  besten Modus herauszufinden. Lies
  <a href="http://aa-project.sf.net/tune" target="_top">http://aa-project.sf.net/tune</a> für weitere Tuningtipps.
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="caca"></a>8.2.10. <code class="systemitem">libcaca</code> - Color ASCII Art-Bibliothek</h3></div></div></div><p>
  Die Bibliothek
  <a href="http://sam.zoy.org/projects/libcaca/" target="_top"><code class="systemitem">libcaca</code></a>
  ist eine Grafik-Bibliothek, die Text anstatt Pixel ausgibt, sodass sie auf älteren
  Grafikkarten oder Text-Terminals läuft. Sie ist der bekannten Bibliothek
  <code class="systemitem">AAlib</code> nicht unähnlich.
  <code class="systemitem">libcaca</code> benötigt ein Terminal, um zu
  funktionieren, deshalb sollte sie auf allen Unix-Systemen (inklusive Mac OS X) funktionieren,
  wenn man entweder die <code class="systemitem">slang</code>-Bibliothek oder die
  <code class="systemitem">ncurses</code>-Bibliothek, unter DOS die
  <code class="systemitem">conio.h</code>-Bibliothek und auf Windows-Systemen
  entweder <code class="systemitem">slang</code> oder
  <code class="systemitem">ncurses</code> (durch Cygwin-Emulation) oder
  <code class="systemitem">conio.h</code> verwendet. Wenn
  <tt class="filename">./configure</tt> <code class="systemitem">libcaca</code>
  entdeckt, wird der caca-Treiber gebaut.
</p><div class="itemizedlist"><p class="title"><b>Die Unterschiede zu <code class="systemitem">AAlib</code> sind
  folgende:</b></p><ul type="disc"><li>
  16 verfügbare Farben für die Zeichenausgabe (256 Farbpaare)
 </li><li>
  Farbbild-Dithering
 </li></ul></div><div class="itemizedlist"><p class="title"><b>Aber <code class="systemitem">libcaca</code> hat auch folgende
  Einschränkungen:</b></p><ul type="disc"><li>
   keine Unterstützung für Helligkeit, Kontrast, Gamma
  </li></ul></div><p>
  Du kannst diese Tasten im caca-Fenster benutzen, um die Render-Optionen
  zu beeinflussen:
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Taste</th><th>Aktion</th></tr></thead><tbody><tr><td><span class="keycap"><b>d</b></span></td><td>
  zwischen den Dithering-Methoden von
  <code class="systemitem">libcaca</code> umschalten.
  </td></tr><tr><td><span class="keycap"><b>a</b></span></td><td>
  zwischen dem Antialiasing von <code class="systemitem">libcaca</code>
  umschalten.
  </td></tr><tr><td><span class="keycap"><b>b</b></span></td><td>
  zwischen dem Hintergrund <code class="systemitem">libcaca</code>
  umschalten.
  </td></tr></tbody></table></div><div class="variablelist"><p class="title"><b><code class="systemitem">libcaca</code> sucht auch nach
  bestimmten Umgebungsvariablen:</b></p><dl><dt><span class="term"><tt class="option">CACA_DRIVER</tt></span></dt><dd>
  Setze den empfohlenen caca-Treiber. z.B. ncurses, slang, x11.
  </dd><dt><span class="term"><tt class="option">CACA_GEOMETRY (nur bei X11)</tt></span></dt><dd>
  Spezifiziere die Anzahl der Spalten und Zeilen, z.B. 128x50.
  </dd><dt><span class="term"><tt class="option">CACA_FONT (nur bei X11)</tt></span></dt><dd>
  Legt die zu verwendende Schrift fest, z.B. fixed, nexus.
  </dd></dl></div><p>
  Nimm die Option <tt class="option">-framedrop</tt>, wenn dein Rechner nicht schnell
  genug für die Darstellung aller Frames ist.
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="vesa"></a>8.2.11. VESA-Ausgabe über das VESA-BIOS</h3></div></div></div><p>
  Dieser Treiber ist vom Design her ein <span class="bold"><strong>generischer Treiber</strong></span>
  für alle Grafikkarten, deren Bios VESA VBE 2.0 unterstützt. Ein weiterer
  Vorteil dieses Treibers liegt darin, dass er versucht, den TV-Ausgang anzuschalten.
  <em class="citetitle">VESA BIOS EXTENSION (VBE) Version 3.0 Date: September 16, 1998</em>
  (Seite 70) hat folgendes zu sagen:
</p><div class="blockquote"><blockquote class="blockquote"><p><b>Designs für zwei Controller. </b>
  VBE 3.0 unterstützt zwei Controller dadurch, dass angenommen wird,
  dass beide Controller vom gleichen OEM (Hardwarehersteller) stammen und
  unter Kontrolle desselben BIOS auf derselben Grafikkarte sitzen. Somit ist
  es möglich, die Tatsache, dass zwei Controller vorhanden sind, vor der
  Anwendung zu verbergen. Dies verhindert zwar, dass beide Controller
  unabhängig voneinander gesteuert werden, erlaubt andererseits aber,
  dass Anwendungen weiterhin problemlos funktionieren, die vor Erscheinen der
  VBE-3.0-Spezifikation geschrieben wurden. Die VBE-Funktion 00h (Auskunft
  über die Controller, Return Controller Information) gibt
  dementsprechend die kombinierten Informationen über beide Controller
  zurück, was auch eine kombinierte Liste der vorhandenen Grafikmodi
  einschließt. Sobald eine Anwendung einen Grafikmodus wählt, wird
  der entsprechende Controller aktiviert. Alle weiteren VBE-Funtkionen werden
  dann auf diesem Controller ausgeführt.
</p></blockquote></div><p>
  Somit hast du also eine Chance, den TV-Ausgang mit diesem Treiber zum
  Laufen zu bringen.
  (Ich vermute, dass der TV-Ausgang normalerweise auf einer separaten
  Grafikkarte oder zumindest ein separater Ausgang ist.)
</p><div class="itemizedlist"><p class="title"><b>VORTEILE</b></p><ul type="disc" compact><li>
  Du hast die Möglichkeit, selbst dann Filme anzusehen, wenn
  <span class="bold"><strong>Linux nichts von deiner Grafikhardware weiß</strong></span>.
</li><li>
  Du musst keine einzige Grafikanwendung installiert haben (wie
  X11/XFree86, fbdev usw.). Dieser Treiber wird im
  <span class="bold"><strong>Textmodus</strong></span>
  benutzt.
</li><li>
  Die Chancen stehen gut, dass der <span class="bold"><strong>TV-Ausgang funktioniert</strong></span>.
  (Es läuft nachweislich zumindest auf ATI-Karten.)
</li><li>
  Dieser Treiber ruft die <code class="function">int 10h</code>-Routine wirklich auf und ist
  dementsprechend kein Emulator - er ruft <span class="bold"><strong>echte</strong></span>
  Funktionen des <span class="emphasis"><em>echten</em></span> BIOS im <span class="emphasis"><em>Real</em></span>-Modus
  auf (bzw. im vm68-Modus).
</li><li>
  Du kannst den Treiber zusammen mit VIDIX verwenden und erhältst
  dadurch gleichzeitig eine hardwarebeschleunigte Grafikanzeige
  <span class="bold"><strong>und</strong></span> den TV-Ausgang! (für ATI-Karten empfohlen)
</li><li>
  Wenn du ein VESA-VBE-3.0+-BIOS hast und irgendwo die Optionen
  <tt class="option">monitor-hfreq</tt>, <tt class="option">monitor-vfreq</tt>,
  <tt class="option">monitor-dotclock</tt> angegeben werden (Kommandozeile,
  Konfigurationsdatei), dann bekommst du die höchstmögliche
  Bildwiederholrate (mit den generischen Timingformeln). Um dieses Feature
  zu aktivieren, müssen <span class="bold"><strong>alle</strong></span>
  Monitoroptionen angegeben werden.
</li></ul></div><div class="itemizedlist"><p class="title"><b>NACHTEILE</b></p><ul type="disc" compact><li>
  Der Treiber funtkioniert nur auf <span class="bold"><strong>x86-Systemen</strong></span>.
</li><li>
  Er kann nur von <code class="systemitem">root</code> benutzt werden.
</li><li>
  Momentan ist er nur für <span class="bold"><strong>Linux</strong></span> verfügbar.
</li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Wichtig</h3><p>
  Benutze diesen Treiber nicht mit <span class="bold"><strong>GCC 2.96</strong></span>!
  Das wird nicht funktionieren!
</p></div><div class="variablelist"><p class="title"><b>BEI VESA VERFÜGBARE KOMMANDOZEILENOPTIONEN</b></p><dl><dt><span class="term"><tt class="option">-vo vesa:<em class="replaceable"><code>opts</code></em></tt></span></dt><dd>
  Momentan erkannt: <code class="literal">dga</code>, um den DGA-Modus zu erzwingen
  und <code class="literal">nodga</code>, um ihn zu deaktivieren. Im DGA-Modus kannst du den
  Doppelpuffermodus mit <tt class="option">-double</tt> aktivieren. Anmerkung: Du
  kannst diese Parameter auch weglassen, um die <span class="bold"><strong>automatische
  Erkennung</strong></span> des DGA-Modus zu ermöglichen.
  </dd></dl></div><div class="itemizedlist"><p class="title"><b>BEKANNTE PROBLEME UND WIE MAN SIE UMGEHT</b></p><ul type="disc" compact><li>
  Wenn du unter Linux eine <span class="bold"><strong>NLS</strong></span>-Schrift
  verwendest und du den VESA-Treiber aus dem Textmodus heraus aufrufst,
  dann wird nach dem Beenden von <span class="application">MPlayer</span> die
  <span class="bold"><strong>ROM-Schrift</strong></span> anstelle der nationalen
  geladen sein. Du kannst die nationale Schriftart erneut mit
  <span><strong class="command">setsysfont</strong></span> laden, das z.B. bei Mandrake zur
  Distribution gehört. (<span class="bold"><strong>Tip:</strong></span> Das
  gleiche Tool wird für die Lokalisation von fbdev verwendet.)
</li><li>
  Manche <span class="bold"><strong>Linux-Grafiktreiber</strong></span> aktualisieren
  nicht den aktiven <span class="bold"><strong>BIOS-Modus</strong></span> im DOS-Speicher.
  Wenn du also so ein Problem hast, dann verwende den VESA-Treiber nur aus dem
  <span class="bold"><strong>Textmodus</strong></span> heraus. Andernfalls
  wird immer der Textmodus (#03) aktiviert werden, und du wirst den
  Computer neustarten müssen.
</li><li>
  Oftmals siehst du nur einen <span class="bold"><strong>schwarzen Bildschirm</strong></span>,
  wenn der VESA-Treiber beendet wird. Um die Anzeige wieder in den richtigen Zustand
  zu versetzen, wechsele einfach zu einer anderen Console (mit
  <span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>F&lt;x&gt;</b></span>) und wieder zurück.
</li><li>
  Um eine <span class="bold"><strong>funktionierende TV-Ausgabe</strong></span> zu erhalten,
  musst du das TV-Kabel eingesteckt haben, bevor du deinen PC bootest, da das BIOS
  nur einmal während der POST-Phase initialisiert wird.
</li></ul></div></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="x11"></a>8.2.12. X11</h3></div></div></div><p>
  Vermeide diesen Treiber, wenn's geht. Er benutzt X11 (mit den Shared-
  Memory-Erweiterungen) ohne jegliche Hardwarebeschleunigung. Unterstützt
  MMX-/3DNow/SSE-beschleunigte Softwareskalierung mit den Optionen
  <tt class="option">-fs -zoom</tt>, aber die ist trotzdem langsam. Die meisten
  Karten bieten Unterstützung für Hardwareskalierung. Benutze also
  <tt class="option">-vo xv</tt> in den meisten Fällen bzw. <tt class="option">-vo xmga</tt>
  bei Matrox-Karten.
</p><p>
  Ein Problem liegt darin, dass die meisten Grafikkartentreiber
  Hardwarebeschleunigung nicht beim zweiten Ausgang/beim TV-Ausgang
  unterstützen. In diesen Fällen siehst du nur ein grünes/blaues
  Fenster anstelle des Films. Hier ist der X11-Treiber ganz praktisch, aber du
  brauchst trotzdem eine schnelle CPU für die Softwareskalierung. Benutze
  nicht den SDL-Ausgabetreiber und SDLs Skalierer, da dieser eine schlechtere
  Qualität bietet!
</p><p>
  Softwareskalierung ist sehr langsam. Versuch also besser, vorher in einen
  anderen Videomodus zu schalten. Das ist sehr einfach. Such die
  <a href="output-trad.html#dga-modelines">Modelines in der DGA-Sektion</a> und füge sie
  in deine <tt class="filename">XF86Config</tt> ein.

</p><div class="itemizedlist"><ul type="disc" compact><li>
  Wenn du XFree86 4.x.x hast, dann benutze die Option <tt class="option">-vm</tt>.
  MPlayer wird dann die Auflösung in diejenige ändern,
  in die dein Film am besten hineinpasst. Wenn das nicht funktioniert:
</li><li>
  Unter XFree86 3.x.x musst du mit
  <span class="keycap"><b>Strg</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>plus</b></span>
  und
  <span class="keycap"><b>Strg</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>minus</b></span>
  die Auflösung ändern.
</li></ul></div><p>
</p><p>
  Wenn du die soeben eingefügten Modi nicht wiederfindest, dann schau
  dir die Ausgabe von XFree86 an. Einige Treiber können nicht die
  niedrigen Pixelclock-Werte benutzen, die für niedrige Auflösungen
  vonnöten sind.
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="vidix"></a>8.2.13. VIDIX</h3></div></div></div><p><b>EINLEITUNG. </b>
  <span class="acronym">VIDIX</span> ist die Abkürzung für <span class="bold"><strong>VID</strong></span>eo
  <span class="bold"><strong>I</strong></span>nterface für
  *ni<span class="bold"><strong>X</strong></span> (Video-Schnittstelle für *n*x).
  VIDIX wurde entworfen, um eine Schnittstelle für schnelle Userspacetreiber für
  Grafikkarten zur Verfügung zu stellen, so wie es mga_vid für
  Matrox-Karten tut. VIDIX ist ebenfalls sehr portabel.
</p><p>
  Diese Schnittstelle wurde als Versuch entworfen, den vorhandenen
  Schnittstellen für Videobeschleunigung (mga_vid, rage128_vid,
  radeon_vid, pm3_vid) ein einheitliches Dach zu geben. Sie stellt einen
  einheitlichen Highlevel-Zugang zu BES- und OV-Chips zur Verfügung
  (BackEnd Scaler und Video Overlays). Sie stellt keine Lowlevel-Funktionen
  für z.B. Grafikserver zur Verfügung. (Ich möchte nicht mit dem
  X11-Leuten in Sachen Grafikmodusumschaltung konkurrieren.) Das Ziel dieser
  Schnittstelle liegt also einfach darin, die höchstmögliche
  Geschwindigkeit bei der Videowiedergabe zu erreichen.
</p><div class="itemizedlist"><p class="title"><b>VERWENDUNG</b></p><ul type="disc" compact><li>
  Du kannst den eigenständigen Videotreiber benutzen:
  <tt class="option">-vo vidix</tt>
  Dieser Treiber wurde als das X11-Frontend für die VIDIX-Technologie
  entwickelt. Er benötigt dementsprechend einen X-Server und
  funktioniert auch nur unter X. Beachte, dass der Pixmap-Cache korrumpiert
  werden kann, weil der Treiber unter Umgehung des X-Treibers direkt auf
  die Hardware zugreift. Du kannst das dadurch verhindern, dass du die von
  X verwendete Menge des Grafikspeichers verringerst. Benutze dafür
  die Option "VideoRam" in der "device"-Sektion der
  <tt class="filename">XF86Config</tt>. Du solltest da die installierte Menge
  Grafikspeicher minus 4MB eintragen. Wenn du über weniger als 8MB
  Grafikspeicher verfügst, dann solltest du stattdessen die Option
  "XaaNoPixmapCache" in der "screen"-Sektion verwenden.
  </li><li>
  Es gibt einen VIDIX-Treiber für die Konsole: <tt class="option">-vo cvidix</tt>.
  Dieser benötigt für die meisten Karten einen funktionierenden und
  initialisierten Framebuffer (oder du wirst stattdessen den Bildschirm
  in Unordnung bringen) und wirst einen Effekt ähnlich wie mit
  <tt class="option">-vo mga</tt> oder <tt class="option">-vo fbdev</tt> bekommen.
  nVidia-Karten sind dagegen in der Lage, wirklich grafisches Video
  auf einer echten Text-Konsole auszugeben. Im Abschnitt
  <a href="output-trad.html#vidix-nvidia" title="8.2.13.5. nVidia-Karten">nvidia_vid</a> wirst du mehr Informationen
  dazu finden.
  </li><li>
  Du kannst auch das VIDIX-Untergerät verwenden, das bei vielen
  Treibern zur Verfügung steht:
  <tt class="option">-vo vesa:vidix</tt> (<span class="bold"><strong>nur unter Linux</strong></span>)
  und <tt class="option">-vo fbdev:vidix</tt>
  </li></ul></div><p>
  Es ist in der Tat nicht wichtig, welcher Videoausgabetreiber mit
  <span class="bold"><strong>VIDIX</strong></span> verwendet wird.
</p><div class="itemizedlist"><p class="title"><b>ANFORDERUNGEN</b></p><ul type="disc" compact><li>
  Die Grafikkarte sollte sich gerade im Grafikmodus befinden (ausser
  nVidia-Karten mit den <tt class="option">-vo cvidix</tt> Ausgabe-Treibern).
</li><li>
  <span class="application">MPlayer</span>s Videoausgabetreiber sollte den
  aktiven Videomodus kennen und in der Lage sein, dem VIDIX-Untergerät
  ein paar Charakteristika des X-Servers mitzuteilen.
</li></ul></div><p><b>BEDIENUNGSMETHODEN. </b>
  Wenn VIDIX als <span class="bold"><strong>Subgerät</strong></span>
  (<tt class="option">-vo vesa:vidix</tt>) benutzt wird, dann wird die Konfiguration
  des Videomodus vom Videoausgabegerät erledigt (kurz
  <span class="bold"><strong>vo_server</strong></span>). Deswegen kannst du für
  <span class="application">MPlayer</span> die gleichen Kommandozeilenparameter wie
  für vo_server verwenden.
  Zusätzlich ist die Option <tt class="option">-double</tt> als global sichtbarer
  Parameter verfügbar. (Ich empfehle diese Option zumindest bei VIDIX und
  ATI-Karten.) <tt class="option">-vo xvidix</tt> erkennt momentan die folgenden
  Optionen: <tt class="option">-fs -zoom -x -y -double</tt>.
</p><p>
  Du kannst den VIDIX-Treiber auch direkt als drittes Teilargument auf der
  Kommandozeile angeben:

  </p><pre class="screen">mplayer -vo xvidix:mga_vid.so -fs -zoom -double <em class="replaceable"><code>Datei.avi</code></em></pre><p>
  oder
  </p><pre class="screen">mplayer -vo vesa:vidix:radeon_vid.so -fs -zoom -double -bpp 32 <em class="replaceable"><code>Datei.avi</code></em></pre><p>

  Das ist allerdings gefährlich, und du solltest das lieber nicht tun.
  Hierbei wird die Verwendung des angegebenen Treibers erzwungen, und das
  Resultat ist unklar (dein Computer könnte sogar
  <span class="bold"><strong>abstürzen</strong></span>).
  Du solltest das wirklich NUR DANN tun, wenn du absolut sicher bist, dass es
  funktioniert und <span class="application">MPlayer</span> es nicht eh schon
  automatisch auswählt.
  Berichte den Entwicklern von deinen Erfahrungen. Die korrekte Art, VIDIX zu
  benutzen, ist ohne das dritte Teilargument, sodass <span class="application">MPlayer</span>
  automatisch den richtigen Treiber aussucht.
</p><p>
  Da VIDIX direkten Zugriff auf die Hardware benötigt, musst du
  <span class="application">MPlayer</span> entweder als
  <code class="systemitem">root</code> starten oder der
  Programmdatei das SUID-Bit setzen (<span class="bold"><strong>WARNUNG:
  Das ist ein Sicherheitsrisiko!</strong></span>).
  Alternativ kannst du auch spezielle Kernelmodule benutzen:
</p><div class="procedure"><ol type="1"><li><p>
  Lade dir die
  <a href="http://www.arava.co.il/matan/svgalib/" target="_top">Entwicklerversion</a>
  der svgalib herunter (z.B. 1.9.17),
  <span class="bold"><strong>ODER</strong></span> lade dir eine von Alex speziell für
  die Benutzung mit <span class="application">MPlayer</span> modifizierte Version
  (die nicht die svgalib-Sourcen zum Compilieren benötigt)
  <a href="http://www.mplayerhq.hu/MPlayer/contrib/svgalib/svgalib_helper-1.9.17-mplayer.tar.bz2" target="_top">hier</a>
  herunter.
</p></li><li><p>
  Compiliere das Modul im <tt class="filename">svgalib_helper</tt>-Verzeichnis
  (das im Verzeichnis <tt class="filename">svgalib-1.9.17/kernel/</tt>
  gefunden werden kann, wenn du die Sourcen von der svgalib-Seite heruntergeladen hast),
  und lade es mit insmod.
</p></li><li><p>
  Um die entsprechenden Geräte im <tt class="filename">/dev</tt>-Verzeichnis
  zu erstellen, führe ein </p><pre class="screen">make device</pre><p> im Verzeichnis
  <tt class="filename">svgalib_helper</tt> als
  <code class="systemitem">root</code> aus.
</p></li><li><p>
  Verschiebe das Verzeichnis <tt class="filename">svgalib_helper</tt>
  nach <tt class="filename">mplayer/main/libdha/svgalib_helper</tt>.
</p></li><li><p>
  Wenn du die Sourcen von der svgalib-Seite heruntergeladen hast, dann musst
  du den Kommentar vor der CFLAGS-Zeile entfernen, die "svgalib_helper"
  enthält, und die sich in <tt class="filename">libdha/Makefile</tt>
  befindet.
</p></li><li><p>
  Compiliere erneut und installiere libdha.
</p></li></ol></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-ati"></a>8.2.13.1. ATI-Karten</h4></div></div></div><p>
  Momentan werden die meisten ATI-Karten unterstützt, von der Mach64
  bis hin zur neuesten Radeon.
</p><p>
  Es gibt zwei compilierte Binaries: <tt class="filename">radeon_vid</tt> für Radeons
  und <tt class="filename">rage128_vid</tt> für Rage128-Karten. Du kannst entweder eine
  der beiden erzwingen oder das VIDIX-System automatisch alle verfügbaren
  Treiber ausprobieren lassen.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-mga"></a>8.2.13.2. Matrox-Karten</h4></div></div></div><p>
  Matrox G200, G400, G450 und G550 sollen funktionieren.
</p><p>
  Der Treiber unterstützt Videoequalizer und sollte fast genauso schnell
  wie der <a href="output-trad.html#mga_vid" title="8.2.6. Matrox-Framebuffer (mga_vid)">Matrox-Framebuffer</a> sein.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-trident"></a>8.2.13.3. Trident-Karten</h4></div></div></div><p>
  Es gibt einen Treiber für den Trident Cyberblade/i1-Chipsatz, der auf
  VIA Epia-Mainboards eingesetzt wird.
</p><p>
  Der Treiber wurde von
  <a href="http://www.blackfiveservices.co.uk/EPIAVidix.shtml" target="_top">Alastair M. Robinson</a>
  geschrieben und weiterentwickelt.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-3dlabs"></a>8.2.13.4. 3DLabs-Karten</h4></div></div></div><p>
  Auch wenn es einen Treiber für 3DLabs GLINT R3-Chips und Permedia3-Chips
  gibt, so hat noch niemand diese getestet. Feedback wird deswegen gern gesehen.
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-nvidia"></a>8.2.13.5. nVidia-Karten</h4></div></div></div><p>
  Ein einmaliges Feature des nvidia_vid-Treibers ist seine Fähigkeit, Video auf
  <span class="bold"><strong>einfacher, purer Textkonsole</strong></span> darzustellen - ohne
  Framebuffer oder X magic oder was auch immer. Zu diesem Zweck müssen wir
  die <tt class="option">cvidix</tt>-Videoausgabe verwenden, wie folgendes Beispiel zeigt:
  </p><pre class="screen">mplayer -vo cvidix <em class="replaceable"><code>example.avi</code></em></pre><p>
</p></div><div class="sect3" lang="de"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-sis"></a>8.2.13.6. SiS-Karten</h4></div></div></div><p>
  Dies ist ein sehr experimenteller Code, ähnlich nvidia_vid.
</p><p>
  Er wurde auf SiS 650/651/740 getestet (die verbreitetsten Chipsets in den
  SiS-Versionen der Boxen von "Shuttle XPC"-Barebones)
</p><p>
  Berichte erwartet!
</p></div></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="directfb"></a>8.2.14. DirectFB</h3></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>
  "DirectFB ist eine Grafikbibliothek, deren Zielplattform eingebettete
  Systeme sind. Sie bietet maximale Hardwarebeschleunigung bei minimalem
  Ressourcenverbrauch und minimalem Overhead." - Zitat von
  <a href="http://www.directfb.org" target="_top">http://www.directfb.org</a>.
</p></blockquote></div><p>
  Ich lasse die DirectFB-Features in dieser Sektion weg.
</p><p>
  Obwohl <span class="application">MPlayer</span> nicht als "Videoprovider"
  bei DirectFB unterstützt wird, bietet dieser Treiber Videowiedergabe mittels
  DirectFB. Die Wiedergabe ist - natürlich - hardwarebeschleunigt. Bei
  meiner Matrox G400 war der DirectFB genauso schnell wie XVideo.
</p><p>
  Versuche immer die neueste Version von DirectFB zu verwenden. Du kannst
  DirectFB-Optionen mit der <tt class="option">-dfbopts</tt>-Option auf der Kommandozeile
  angeben. Layer-Auswahl erfolgt durch Angabe als Teilargument, z.B. mit
  <tt class="option">-vo directfb:2</tt> (Layer -1 ist der Standardwert: automatische
  Layerauswahl).
</p></div><div class="sect2" lang="de"><div class="titlepage"><div><div><h3 class="title"><a name="dfbmga"></a>8.2.15. DirectFB/Matrox (dfbmga)</h3></div></div></div><p>
  Bitte lies die
  <a href="output-trad.html#directfb" title="8.2.14. DirectFB">DirectFB-Sektion</a> zu generellen
  Informationen über DiretcFB.
</p><p>
  Dieser Videoausgabetreiber wird auf einer Matrox G400/G450/G550-Karten
  den CRTC2 (des zweiten Ausgangs) aktivieren und damit das Video
  <span class="bold"><strong>unabhängig</strong></span> vom primären Ausgang anzeigen.
</p><p>
  Anweisungen, um dies zum Laufen zu bringen, stehen direkt in der
  <a href="http://www.sci.fi/~syrjala/directfb/matrox-tv-out-howto" target="_top">HOWTO</a>
  oder der
  <a href="http://www.sci.fi/~syrjala/directfb/Matrox_TV-out_README.txt" target="_top">README</a>
  auf der Homepage von Ville Syrjala.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Anmerkung</h3><p>
  Die erste DirectFB-Version, mit der wir das zum Laufen gebracht haben, war
  0.9.17 (sie ist fehlerhaft, benötigt den <code class="systemitem">surfacemanager</code> von
  oben erwähnter URL). Wie auch immer, eine Portierung des CRTC2-Codes für
  <a href="output-trad.html#mga_vid" title="8.2.6. Matrox-Framebuffer (mga_vid)">mga_vid</a> ist bereits in Arbeit.
  <a href="../../tech/patches.txt" target="_top">Patches</a> sind willkommen.
</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mtrr.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="video.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="mpeg_decoders.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">8.1. MTRR einrichten </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 8.3. MPEG-Dekoderkarten</td></tr></table></div></body></html>
