diff -urN ffmpeg-svn-20060630.orig/libavcodec/allcodecs.c ffmpeg-svn-20060630/libavcodec/allcodecs.c
--- ffmpeg-svn-20060630.orig/libavcodec/allcodecs.c	2006-06-29 14:00:09 +0300
+++ ffmpeg-svn-20060630/libavcodec/allcodecs.c	2006-06-30 16:11:23 +0300
@@ -567,6 +567,14 @@
     register_avcodec(&mmvideo_decoder);
 #endif //CONFIG_MMVIDEO_DECODER
 
+/* dirac codec */
+#ifdef CONFIG_DIRAC
+     register_avcodec(&dirac_decoder);
+#ifdef CONFIG_ENCODERS
+     register_avcodec(&dirac_encoder);
+#endif 
+#endif
+
     /* pcm codecs */
 #if defined (CONFIG_ENCODERS) && defined (CONFIG_DECODERS)
     #define PCM_CODEC(id, name) \
diff -urN ffmpeg-svn-20060630.orig/libavcodec/avcodec.h ffmpeg-svn-20060630/libavcodec/avcodec.h
--- ffmpeg-svn-20060630.orig/libavcodec/avcodec.h	2006-06-29 14:00:09 +0300
+++ ffmpeg-svn-20060630/libavcodec/avcodec.h	2006-06-30 16:11:23 +0300
@@ -171,7 +171,7 @@
     CODEC_ID_INTERPLAY_DPCM,
     CODEC_ID_XAN_DPCM,
     CODEC_ID_SOL_DPCM,
-
+    CODEC_ID_DIRAC,
     CODEC_ID_MP2= 0x15000,
     CODEC_ID_MP3, /* prefered ID for MPEG Audio layer 1, 2 or3 decoding */
     CODEC_ID_AAC,
@@ -2103,7 +2103,8 @@
 extern AVCodec sonic_ls_encoder;
 extern AVCodec svq1_encoder;
 extern AVCodec x264_encoder;
-
+extern AVCodec dirac_encoder;
+extern AVCodec dirac_decoder;
 extern AVCodec h263_decoder;
 extern AVCodec h261_decoder;
 extern AVCodec mpeg4_decoder;
diff -urN ffmpeg-svn-20060630.orig/libavcodec/dirac.c ffmpeg-svn-20060630/libavcodec/dirac.c
--- ffmpeg-svn-20060630.orig/libavcodec/dirac.c	1970-01-01 03:00:00 +0300
+++ ffmpeg-svn-20060630/libavcodec/dirac.c	2006-06-30 16:11:23 +0300
@@ -0,0 +1,506 @@
+/**
+ * @file dirac.c
+ * Dirac codec support via dirac_encoder.
+ * @author Andrew Kennedy <dirac@rd.bbc.co.uk>
+ * www.sourceforge.net/projects/dirac
+ *
+ * This file is part of libavcodec.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include "avcodec.h"
+
+#undef NDEBUG
+#include <assert.h>
+
+
+#include <libdirac_encoder/dirac_encoder.h>
+#include <libdirac_decoder/dirac_parser.h>
+
+/** ffmpeg qscale to Dirac quality conversion table */
+static const uint8_t quality_factor_conv[] = {10.0, 9.8, 9.6, 9.4, 9.2, 9.0, 8.8, 8.6, 8.4, 8.2, 8.0, 7.8, 7.6, 7.3, 7.0, 6.7, 6.4, 6.0, 5.6, 5.2, 4.8,
+    4.4, 4.0, 3.6, 3.2, 2.8, 2.4, 2.0, 1.6, 1.2, 1.0 };
+
+/** contains a single frame returned from Dirac*/
+typedef struct FfmpegDiracOutputFrame
+{
+    /** frame data */
+    unsigned char *p_data;
+
+    /** frame size */
+    int size;
+
+    /** frame type */
+    int type;
+
+    /** next frame to be output in sequence */
+    struct FfmpegDiracOutputFrame *p_next_frame;
+
+ } FfmpegDiracOutputFrame;
+
+typedef struct FfmpegDiracParams {
+
+    /* context params */
+    dirac_encoder_context_t enc_ctx;
+
+    /* frame being encoded */
+    AVFrame picture;
+
+      /* decoder */
+    dirac_decoder_t*  p_decoder;
+
+    /* encoder */
+    dirac_encoder_t*  p_encoder;
+
+    /* input frame buffer */
+    unsigned char *p_in_frame_buf;
+
+    /** output frame buf */
+    unsigned char* p_out_frame_buf;
+
+    /** next frame to be output*/
+    struct FfmpegDiracOutputFrame *p_next_output_frame;
+
+      /** last frame to be output*/
+    struct FfmpegDiracOutputFrame *p_last_output_frame;
+
+} FfmpegDiracParams;
+
+
+/**
+* Works out Dirac-compatible pre-set option from file size
+*/
+dirac_encoder_presets_t GetDiracPreset(AVCodecContext *avccontext)
+{
+
+   if(avccontext->width==720 && avccontext->height==576)
+       return SD576;
+
+   if(avccontext->height==1280 && avccontext->height==720)
+       return HD720;
+
+   if(avccontext->height==1920 && avccontext->width==1080)
+       return HD1080;
+
+   if(avccontext->height==352 && avccontext->width==288)
+       return CIF;
+
+   return CIF;
+}
+
+/**
+* Works out Dirac-compatible chroma format
+*/
+ dirac_chroma_t GetDiracChromaFormat(AVCodecContext *avccontext)
+ {
+
+   switch(avccontext->pix_fmt)
+   {
+   case PIX_FMT_YUV420P:
+       return format420;
+
+   case PIX_FMT_YUV422P:
+       return format422;
+
+   case PIX_FMT_YUV444P:
+       return format444;
+
+   case PIX_FMT_YUV411P:
+       return format411;
+
+   default:
+       av_log (avccontext, AV_LOG_ERROR, "this codec supports only YUV420P\n");
+       return format420;
+
+   }
+
+   return format420;
+
+ }
+
+ /**
+ * returns Ffmppeg chroma format
+ */
+ int GetFfmpegChromaFormat(dirac_chroma_t dirac_chroma)
+ {
+     switch(dirac_chroma)
+     {
+         case format420:
+             return PIX_FMT_YUV420P;
+         case format422:
+             return PIX_FMT_YUV422P;
+         case format444:
+             return PIX_FMT_YUV444P;
+         case format411:
+             return PIX_FMT_YUV411P;
+
+         default:
+             return PIX_FMT_YUV420P;
+      }
+
+      return PIX_FMT_YUV420P;
+ }
+
+
+ /**
+ * Calculates total size of frame
+ */
+int GetFrameBufferSize (const dirac_encoder_context_t* p_enc_ctx)
+{
+
+    int xl = p_enc_ctx->seq_params.width;
+    int yl = p_enc_ctx->seq_params.height;
+
+    int size;
+
+    switch (p_enc_ctx->seq_params.chroma)
+    {
+    case format411:
+    case format420:
+        size = (xl*yl*3)/2;
+        break;
+    case format422:
+        size = (xl*yl)*2;
+        break;
+    case format444:
+        size = (xl*yl)*3;
+        break;
+    case Yonly:
+    default:
+        size = xl * yl;
+        break;
+    }
+    return size;
+}
+
+static int dirac_encode_init(AVCodecContext *avccontext) {
+
+   FfmpegDiracParams* p_dirac_params = avccontext->priv_data;
+   int no_local=0;
+   int i;
+   int verbose=avccontext->debug;
+
+   /** get dirac preset*/
+   dirac_encoder_presets_t preset = GetDiracPreset(avccontext);
+
+    /** set data to zero */
+    memset (p_dirac_params, 0, sizeof(FfmpegDiracParams));
+
+
+     /** initialise the encoder context */
+    dirac_encoder_context_init (&(p_dirac_params->enc_ctx), preset);
+
+    p_dirac_params->enc_ctx.seq_params.chroma=GetDiracChromaFormat(avccontext);
+    p_dirac_params->enc_ctx.seq_params.frame_rate.numerator=avccontext->time_base.den;
+    p_dirac_params->enc_ctx.seq_params.frame_rate.denominator=avccontext->time_base.num;
+    p_dirac_params->enc_ctx.seq_params.width=avccontext->width;
+    p_dirac_params->enc_ctx.seq_params.height=avccontext->height;
+
+    avccontext->frame_size = GetFrameBufferSize(&(p_dirac_params->enc_ctx));
+    avccontext->coded_frame= &p_dirac_params->picture;
+
+    if (no_local)
+    {
+        p_dirac_params->enc_ctx.decode_flag = 0;
+        p_dirac_params->enc_ctx.instr_flag = 0;
+    }
+    else
+    {
+        p_dirac_params->enc_ctx.decode_flag = 1;
+        p_dirac_params->enc_ctx.instr_flag = 1;
+    }
+    
+    if(avccontext->global_quality!=0)
+       p_dirac_params->enc_ctx.enc_params.qf=quality_factor_conv[(avccontext->global_quality/FF_QP2LAMBDA)-1];
+
+    p_dirac_params->p_encoder = dirac_encoder_init( &(p_dirac_params->enc_ctx), verbose );
+
+
+
+    if (!p_dirac_params->p_encoder)
+    {
+        av_log(avccontext, AV_LOG_ERROR, "Unrecoverable Error: dirac_encoder_init failed. ");
+        return EXIT_FAILURE;
+    }
+
+
+    /** allocate enough memory for the incoming data */
+    p_dirac_params->p_in_frame_buf = (unsigned char*) av_malloc(avccontext->frame_size);
+
+    return 0 ;
+}
+
+
+static int dirac_encode_frame(AVCodecContext *avccontext,
+                 unsigned char *frame,
+                 int buf_size, void *data)
+{
+    int enc_size=0;
+    int frames_written = 0;
+    dirac_encoder_state_t state;
+    FfmpegDiracParams* p_dirac_params = avccontext->priv_data;
+    AVFrame* p_frame_src;
+    struct FfmpegDiracOutputFrame* p_frame_output=NULL;
+    struct FfmpegDiracOutputFrame* p_next_output_frame=NULL;
+
+
+    if(data==0)
+    {
+       /** look for any delayed frames at EOF*/
+       p_next_output_frame=p_dirac_params->p_next_output_frame;
+   if(p_next_output_frame==NULL)
+   {
+       /* get terminate data*/
+       p_dirac_params->p_encoder->enc_buf.buffer=frame;
+       p_dirac_params->p_encoder->enc_buf.size = buf_size;
+       if (dirac_encoder_end_sequence( p_dirac_params->p_encoder ) > 0)
+              return p_dirac_params->p_encoder->enc_buf.size;
+
+       return 0;
+   }
+
+
+   memcpy(frame, p_next_output_frame->p_data, p_next_output_frame->size);
+   enc_size=p_next_output_frame->size;
+
+   /*remove frame*/
+   p_dirac_params->p_next_output_frame=p_next_output_frame->p_next_frame;
+   av_free(p_next_output_frame->p_data);
+   av_free(p_next_output_frame);
+
+   return enc_size;
+    }
+
+    p_dirac_params->picture = *(AVFrame*)data;
+   p_frame_src=(AVFrame*)data;
+
+    /** allocate frame data to dirac input buffer */
+   /*
+   * input line size may differe from what the codec supports. Especially
+   * when transcoding from one format to another. So use avpicture_layout
+   * to copy the frame.
+   */
+   avpicture_layout ((AVPicture *)data, avccontext->pix_fmt, avccontext->width, avccontext->height,p_dirac_params->p_in_frame_buf, avccontext->frame_size);
+
+    /** load next frame*/
+    if (dirac_encoder_load( p_dirac_params->p_encoder, p_dirac_params->p_in_frame_buf, avccontext->frame_size ) < 0)
+    {
+                av_log(avccontext, AV_LOG_ERROR, "Unrecoverable Encoder Error. Quitting...\n");
+                return -1;
+     }
+
+
+     do {
+           p_dirac_params->p_encoder->enc_buf.buffer = frame;
+           p_dirac_params->p_encoder->enc_buf.size = buf_size;
+           /** process frame */
+           state = dirac_encoder_output ( p_dirac_params->p_encoder );
+
+           switch (state)
+           {
+               case ENC_STATE_AVAIL:
+                   assert (p_dirac_params->p_encoder->enc_buf.size > 0);
+           /** create output frame*/
+           p_frame_output=(struct FfmpegDiracOutputFrame*)av_malloc(sizeof(FfmpegDiracOutputFrame));
+           memset(p_frame_output, 0, sizeof(FfmpegDiracOutputFrame));
+
+           /** set output data */
+           p_frame_output->p_data=(unsigned char*)av_malloc(p_dirac_params->p_encoder->enc_buf.size);
+           memcpy(p_frame_output->p_data,p_dirac_params->p_encoder->enc_buf.buffer,p_dirac_params->p_encoder->enc_buf.size);
+           p_frame_output->size=p_dirac_params->p_encoder->enc_buf.size;
+           p_frame_output->type=p_dirac_params->p_encoder->enc_fparams.ftype;
+           if(p_dirac_params->p_next_output_frame==NULL)
+           {
+               p_dirac_params->p_next_output_frame=p_frame_output;
+               p_dirac_params->p_last_output_frame=p_frame_output;
+           }
+           else
+           {
+               p_dirac_params->p_last_output_frame->p_next_frame=p_frame_output;
+               p_dirac_params->p_last_output_frame=p_frame_output;
+           }
+
+           break;
+
+               case ENC_STATE_BUFFER:
+                   break;
+
+               case ENC_STATE_INVALID:
+                   av_log(avccontext, AV_LOG_ERROR, "Unrecoverable Encoder Error. Quitting...\n");
+                   return -1;
+               default:
+                   av_log(avccontext, AV_LOG_ERROR, "Unknown Encoder state\n");
+                   return -1;
+           }
+     }
+   while(state==ENC_STATE_AVAIL);
+
+   /* copy 'next' frame in queue */
+   p_next_output_frame=p_dirac_params->p_next_output_frame;
+   if(p_next_output_frame==NULL)
+       return 0;
+
+   memcpy(frame, p_next_output_frame->p_data, p_next_output_frame->size);
+    avccontext->coded_frame->key_frame= p_next_output_frame->type == I_frame;
+    avccontext->coded_frame->pts= 0;
+   enc_size=p_next_output_frame->size;
+
+   /*remove frame*/
+   p_dirac_params->p_next_output_frame=p_next_output_frame->p_next_frame;
+   av_free(p_next_output_frame->p_data);
+   av_free(p_next_output_frame);
+
+   return enc_size;
+}
+
+
+static int dirac_encode_close(AVCodecContext *avccontext) {
+
+
+    FfmpegDiracParams* p_dirac_params = avccontext->priv_data;
+
+     // close the encoder
+    dirac_encoder_close(p_dirac_params->p_encoder );
+
+    av_free(p_dirac_params->p_in_frame_buf);
+
+    return 0 ;
+}
+
+
+AVCodec dirac_encoder = {
+    "dirac",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_DIRAC,
+    sizeof(FfmpegDiracParams),
+    dirac_encode_init,
+    dirac_encode_frame,
+    dirac_encode_close,
+   .capabilities= CODEC_CAP_DELAY,
+} ;
+
+/**-----------------------------------------------------DECODER-----------------------------------------------------------------------------------------*/
+
+static int dirac_decode_init(AVCodecContext *avccontext) {
+
+    FfmpegDiracParams *p_dirac_params = (FfmpegDiracParams*)avccontext->priv_data ;
+    p_dirac_params->p_decoder =  dirac_decoder_init(avccontext->debug);
+
+    if (!p_dirac_params->p_decoder)
+        return -1;
+
+    return 0 ;
+}
+
+static int dirac_decode_frame(AVCodecContext *avccontext,
+                                void *data, int *data_size,
+                                uint8_t *buf, int buf_size)
+{
+
+    FfmpegDiracParams *p_dirac_params=(FfmpegDiracParams*)avccontext->priv_data;
+    AVPicture *picture = (AVPicture*)data;
+    AVPicture pic;
+    int drop_frame, framedrop, pict_size;
+    unsigned char *buffer[3];
+
+    if(buf_size<=0)
+         return 0; /** skipped null frame */
+
+    /** set data to decode into buffer */
+    dirac_buffer (p_dirac_params->p_decoder, buf, buf+buf_size);
+    while (1)
+    {
+         /** parse data and process result */
+         DecoderState state = dirac_parse (p_dirac_params->p_decoder);
+         switch (state)
+         {
+            case STATE_BUFFER:
+                 return 0;
+
+            case STATE_SEQUENCE:
+
+                /** tell ffmpeg about sequence details*/
+                avccontext->height=p_dirac_params->p_decoder->seq_params.height;
+                avccontext->width=p_dirac_params->p_decoder->seq_params.width;
+                avccontext->pix_fmt=GetFfmpegChromaFormat(p_dirac_params->p_decoder->seq_params.chroma);
+                avccontext->time_base.den=p_dirac_params->p_decoder->seq_params.frame_rate.numerator;
+                avccontext->time_base.num=p_dirac_params->p_decoder->seq_params.frame_rate.denominator;
+
+                /** calc output dimensions */
+                avpicture_fill(&pic, NULL, avccontext->pix_fmt, avccontext->width, avccontext->height);
+                pict_size = avpicture_get_size(avccontext->pix_fmt, avccontext->width, avccontext->height);
+
+                   /** allocate output buffer */
+                p_dirac_params->p_out_frame_buf = (unsigned char *)av_malloc (pict_size);
+                buffer[0]=p_dirac_params->p_out_frame_buf;
+                buffer[1]=p_dirac_params->p_out_frame_buf+(pic.linesize[0]*avccontext->height);
+                buffer[2]=buffer[1]+(pic.linesize[1]*p_dirac_params->p_decoder->seq_params.chroma_height);
+
+                /** tell dirac about output destination */
+                dirac_set_buf(p_dirac_params->p_decoder, buffer, NULL);
+                break;
+
+            case STATE_SEQUENCE_END:
+                break;
+
+            case STATE_PICTURE_AVAIL:
+                /** fill pic with current buffer data from dirac*/
+                avpicture_fill(picture, p_dirac_params->p_out_frame_buf, avccontext->pix_fmt, avccontext->width, avccontext->height);
+                *data_size=1;
+                return buf_size;
+
+            case STATE_PICTURE_START:
+                 break;
+
+            case STATE_INVALID:
+                return -1;
+
+            default:
+                break;
+            }
+        }
+
+
+        return 0;
+
+
+}
+
+
+static int dirac_decode_close(AVCodecContext *avccontext) {
+
+    FfmpegDiracParams *p_dirac_params=(FfmpegDiracParams*)avccontext->priv_data;
+
+    dirac_decoder_close (p_dirac_params->p_decoder);
+
+    av_free(p_dirac_params->p_out_frame_buf);
+
+    return 0 ;
+}
+
+
+AVCodec dirac_decoder = {
+     "dirac",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_DIRAC,
+    sizeof(FfmpegDiracParams),
+    dirac_decode_init,
+    NULL,
+    dirac_decode_close,
+    dirac_decode_frame,
+    CODEC_CAP_DELAY
+} ;
diff -urN ffmpeg-svn-20060630.orig/libavcodec/Makefile ffmpeg-svn-20060630/libavcodec/Makefile
--- ffmpeg-svn-20060630.orig/libavcodec/Makefile	2006-06-29 14:00:09 +0300
+++ ffmpeg-svn-20060630/libavcodec/Makefile	2006-06-30 16:11:23 +0300
@@ -263,6 +263,12 @@
        amrwb_float/enc_util.o  amrwb_float/if_rom.o
 endif
 
+ifeq ($(CONFIG_DIRAC),yes)
+OBJS+= dirac.o
+EXTRALIBS+= $(DIRAC_LIB)
+CFLAGS+= $(DIRAC_INC)
+endif
+
 
 ifeq ($(HAVE_PTHREADS),yes)
 OBJS+= pthread.o
diff -urN ffmpeg-svn-20060630.orig/libavformat/allformats.c ffmpeg-svn-20060630/libavformat/allformats.c
--- ffmpeg-svn-20060630.orig/libavformat/allformats.c	2006-06-06 18:39:25 +0300
+++ ffmpeg-svn-20060630/libavformat/allformats.c	2006-06-30 16:11:23 +0300
@@ -92,6 +92,10 @@
     libogg_init();
 #endif
 
+#ifdef CONFIG_DIRAC
+    drc_init();
+#endif
+
     ffm_init();
 #if defined(CONFIG_VIDEO4LINUX2)
     v4l2_init();
diff -urN ffmpeg-svn-20060630.orig/libavformat/avienc.c ffmpeg-svn-20060630/libavformat/avienc.c
--- ffmpeg-svn-20060630.orig/libavformat/avienc.c	2006-06-06 18:39:25 +0300
+++ ffmpeg-svn-20060630/libavformat/avienc.c	2006-06-30 16:11:23 +0300
@@ -203,6 +203,7 @@
     { CODEC_ID_CSCD, MKTAG('C', 'S', 'C', 'D') },
     { CODEC_ID_ZMBV, MKTAG('Z', 'M', 'B', 'V') },
     { CODEC_ID_KMVC, MKTAG('K', 'M', 'V', 'C') },
+    { CODEC_ID_DIRAC, MKTAG('d', 'r', 'a', 'c') },
     { CODEC_ID_RAWVIDEO, 0 },
     { CODEC_ID_NONE, 0 },
 };
diff -urN ffmpeg-svn-20060630.orig/libavformat/drc.c ffmpeg-svn-20060630/libavformat/drc.c
--- ffmpeg-svn-20060630.orig/libavformat/drc.c	1970-01-01 03:00:00 +0300
+++ ffmpeg-svn-20060630/libavformat/drc.c	2006-06-30 16:16:17 +0300
@@ -0,0 +1,300 @@
+/**
+ * @file drc.c
+ * Dirac streaming support
+ * @author Andrew Kennedy <dirac@rd.bbc.co.uk>
+ * www.sourceforge.net/projects/dirac
+ *
+ * This file is part of libavformat.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+
+#include "avformat.h"
+
+#undef NDEBUG
+#include <assert.h>
+
+
+typedef struct FfmpegDrcParams {
+
+    /** in initialization mode? */
+    int initializing;
+
+    /** sequence data */
+    char *p_seq_buf;
+
+    /** size of sequence buffer */
+    int seq_size;
+
+} FfmpegDrcParams ;
+
+
+
+static int drc_write_header(AVFormatContext *avfcontext)
+{
+
+    return 0 ;
+}
+
+static int drc_write_packet(AVFormatContext *avfcontext, AVPacket *pkt)
+{
+
+  put_buffer(&avfcontext->pb, pkt->data, pkt->size);
+  put_flush_packet(&avfcontext->pb);
+
+
+    return 0;
+}
+
+
+static int drc_write_trailer(AVFormatContext *avfcontext) {
+
+
+
+
+   return 0 ;
+}
+
+
+static AVOutputFormat drc_oformat = {
+    "drc",
+    "Dirac",
+    "",
+    "drc",
+    sizeof(FfmpegDrcParams),
+    0,
+    CODEC_ID_DIRAC,
+    drc_write_header,
+    drc_write_packet,
+    drc_write_trailer,
+} ;
+
+
+/**------------------------------------------------------------input---------------------------------------------------------------------*/
+
+static int drc_read_header(AVFormatContext *avfcontext, AVFormatParameters *ap)
+{
+    AVStream *st;
+    FfmpegDrcParams *p_drc_params = (FfmpegDrcParams*)avfcontext->priv_data;
+
+    memset(p_drc_params, sizeof(FfmpegDrcParams), 0);
+
+    /** create new stream */
+    st = av_new_stream(avfcontext, 0);
+    st->codec->codec_type = CODEC_TYPE_VIDEO;
+    st->codec->codec_id = CODEC_ID_DIRAC;
+    st->start_time = 0;
+
+    p_drc_params->initializing=1;
+
+    return 0 ;
+}
+
+
+#define DIRAC_VIDEOBUFFER_SIZE 0x100000
+static unsigned char* dirac_videobuffer = 0;
+static int dirac_videobuf_len =0;
+static unsigned char dirac_videobuf_code[5];
+static int dirac_videobuf_code_len = 0;
+
+int dirac_sync_video_packet (ByteIOContext *p_byte_context)
+{
+    int skipped = 0;
+    dirac_videobuf_len = 0;
+    while(dirac_videobuf_code_len<5)
+    {
+        dirac_videobuf_code[dirac_videobuf_code_len++]=url_fgetc(p_byte_context);
+    }
+    while (1)
+    {
+                int c;
+                if(dirac_videobuf_code[0]==0x42 && dirac_videobuf_code[1]==0x42 && dirac_videobuf_code[2]==0x43 && dirac_videobuf_code[3]==0x44)
+                {
+                    break;
+                }
+                ++skipped;
+                dirac_videobuffer[0] = dirac_videobuf_code[0]=dirac_videobuf_code[1];
+                dirac_videobuffer[1] = dirac_videobuf_code[1]=dirac_videobuf_code[2];
+                dirac_videobuffer[2] = dirac_videobuf_code[2]=dirac_videobuf_code[3];
+                dirac_videobuffer[3] = dirac_videobuf_code[3]=dirac_videobuf_code[4];
+                c = url_fgetc(p_byte_context);
+                if (c < 0 )
+                    return 0;
+                dirac_videobuffer[4] = dirac_videobuf_code[4]=c;
+                dirac_videobuf_len = 5;
+    }
+
+
+    return dirac_videobuf_code[4];
+}
+
+/** RAP Frame start = 0xD7
+ Non-RAP I Frame start = 0xD6
+ L1 Frame start = 0xD4
+ L2 Frame start = 0xD7*/
+#define FRAME_START(c) ((c) == 0xD4 || (c) == 0xD5 || (c) == 0xD6 || (c) == 0xD7)
+
+static int drc_read_packet(AVFormatContext *avfcontext, AVPacket *pkt) {
+
+    int in_frame = 0;
+    int offset=0;
+    unsigned char* start;
+    unsigned int shift = 0xffffffff;
+    int msg_type = 0xFF;
+    dirac_videobuf_len=0;
+    FfmpegDrcParams *p_drc_params = (FfmpegDrcParams*)avfcontext->priv_data ;
+
+    if (!dirac_videobuffer)
+    {
+        dirac_videobuffer = (unsigned char *)av_malloc(DIRAC_VIDEOBUFFER_SIZE);
+        if(!dirac_videobuffer)
+        {
+            return 0;
+        }
+    }
+
+    start = dirac_videobuffer;
+
+    /** if we have any valid sequence data, then need to send to decoder */
+    if(p_drc_params->initializing==0 && p_drc_params->seq_size > 0)
+    {
+        memcpy(start, p_drc_params->p_seq_buf, p_drc_params->seq_size);
+        dirac_videobuf_len+=p_drc_params->seq_size;
+        av_free(p_drc_params->p_seq_buf);
+        p_drc_params->seq_size=0;
+    }
+
+    /** find start of data */
+    while (msg_type != 0 && msg_type == 0xFF)
+        msg_type = dirac_sync_video_packet(&avfcontext->pb);
+
+    if (msg_type == 0)
+        return -1;
+
+    /* find start of frame */
+    while (!in_frame)
+    {
+        int byte;
+        if (FRAME_START(msg_type))
+        {
+            in_frame = 1;
+            break;
+        }
+
+        byte = url_fgetc(&avfcontext->pb);
+        if (byte < 0)
+        {
+            dirac_videobuf_code_len = 0;
+            if (dirac_videobuf_len)
+                return dirac_videobuf_len;
+            else
+                return -1;
+         }
+
+           dirac_videobuffer[dirac_videobuf_len++] = byte;
+           if (shift == 0x42424344)
+           {
+                if (FRAME_START(byte))
+                    {
+                        in_frame = 1;
+                        break;
+                    }
+            }
+        shift = (shift << 8 ) | byte;
+      }
+
+    /* find end of frame */
+    shift = 0xffffffff;
+    dirac_videobuf_code_len = 0;
+    while (in_frame)
+    {
+        int byte;
+        byte = url_fgetc(&avfcontext->pb);
+        if (byte < 0)
+            return dirac_videobuf_len;
+
+        dirac_videobuffer[dirac_videobuf_len++] = byte;
+        if (shift == 0x42424344)
+        {
+            if (byte != 0xFF)
+            {
+                in_frame = 0;
+                dirac_videobuf_code_len = 5;
+                dirac_videobuf_code[0] = 0x42;
+                dirac_videobuf_code[1] = 0x42;
+                dirac_videobuf_code[2] = 0x43;
+                dirac_videobuf_code[3] = 0x44;
+                dirac_videobuf_code[4] = byte;
+                break;
+            }
+        }
+        shift = (shift << 8 ) | byte;
+    }
+
+    if (av_new_packet(pkt, dirac_videobuf_len))
+        return AVERROR_IO;
+
+    pkt->stream_index = 0;
+
+
+
+    /** reset input buffer to beggining if we are still initialzing*/
+    if(p_drc_params->initializing)
+    {
+        p_drc_params->p_seq_buf=(unsigned char *)av_malloc(dirac_videobuf_len);
+        memcpy(p_drc_params->p_seq_buf,start, pkt->size);
+        p_drc_params->seq_size=dirac_videobuf_len;
+        p_drc_params->initializing=0;
+    }
+
+    memcpy(pkt->data, start, dirac_videobuf_len);
+
+    return dirac_videobuf_len;
+}
+
+
+static int drc_read_close(AVFormatContext *avfcontext) {
+
+    av_free(dirac_videobuffer);
+    dirac_videobuffer=0;
+
+    return 0;
+ }
+
+
+static AVInputFormat drc_iformat = {
+    "drc",
+    "Dirac",
+    sizeof(FfmpegDrcParams),
+    NULL,
+    drc_read_header,
+    drc_read_packet,
+    drc_read_close,
+    .extensions = "drc",
+} ;
+
+
+int drc_init(void) {
+
+#ifdef CONFIG_ENCODERS
+    av_register_output_format(&drc_oformat) ;
+#endif
+    av_register_input_format(&drc_iformat);
+
+    return 0 ;
+}
+
diff -urN ffmpeg-svn-20060630.orig/libavformat/Makefile ffmpeg-svn-20060630/libavformat/Makefile
--- ffmpeg-svn-20060630.orig/libavformat/Makefile	2006-06-06 18:39:25 +0300
+++ ffmpeg-svn-20060630/libavformat/Makefile	2006-06-30 16:11:23 +0300
@@ -30,6 +30,12 @@
 OBJS+= amr.o
 endif
 
+ifeq ($(CONFIG_DIRAC),yes)
+OBJS+= drc.o
+EXTRALIBS+= $(DIRAC_LIB)
+CFLAGS+= $(DIRAC_INC)
+endif
+
 # image formats
 OBJS+= pnm.o yuv.o png.o jpeg.o gifdec.o sgi.o
 OBJS+= framehook.o
diff -urN ffmpeg-svn-20060630.orig/libavformat/utils.c ffmpeg-svn-20060630/libavformat/utils.c
--- ffmpeg-svn-20060630.orig/libavformat/utils.c	2006-06-30 13:59:06 +0300
+++ ffmpeg-svn-20060630/libavformat/utils.c	2006-06-30 16:11:23 +0300
@@ -2019,6 +2019,7 @@
              st->codec->codec_id == CODEC_ID_PBM ||
              st->codec->codec_id == CODEC_ID_PPM ||
              st->codec->codec_id == CODEC_ID_SHORTEN ||
+             st->codec->codec_id == CODEC_ID_DIRAC ||
              (st->codec->codec_id == CODEC_ID_MPEG4 && !st->need_parsing))*/)
             try_decode_frame(st, pkt->data, pkt->size);
 
diff -urN ffmpeg-svn-20060630.orig/Makefile ffmpeg-svn-20060630/Makefile
--- ffmpeg-svn-20060630.orig/Makefile	2006-06-29 14:00:09 +0300
+++ ffmpeg-svn-20060630/Makefile	2006-06-30 16:11:23 +0300
@@ -47,6 +47,11 @@
 DEP_LIBS=libavcodec/$(LIBPREF)avcodec$(LIBSUF) libavformat/$(LIBPREF)avformat$(LIBSUF)
 endif
 
+ifeq ($(CONFIG_DIRAC),yes)
+EXTRALIBS+= $(DIRAC_LIB)
+CFLAGS+= $(DIRAC_INC)
+endif
+
 ifeq ($(BUILD_VHOOK),yes)
 VHOOK=videohook
 INSTALLVHOOK=install-vhook
